<!-- QA Dashboard -->

<?!= include('layout', {
      baseUrl: baseUrl,
      scriptUrl: scriptUrl,
      currentPage: currentPage || 'qadashboard',
      userList: userList,
      granularity: granularity,
      periodValue: periodValue,
      selectedAgent: selectedAgent,
      user: user,
      campaignId: campaignId,
      campaignName: campaignName
    }) ?>

<style>
  :root {
    /* Brand Color Palette */
    --navy-primary: #003177;
    --cyan-accent: #00BFFF;
    --gold-highlight: #FFB800;
    --fire-red: #FF4000;

    /* Modern UI Colors */
    --primary-gradient: linear-gradient(135deg, var(--navy-primary) 0%, #004ba0 100%);
    --info-gradient: linear-gradient(135deg, var(--cyan-accent) 0%, #0099cc 100%);
    --success-gradient: linear-gradient(135deg, #10b981 0%, #059669 100%);
    --warning-gradient: linear-gradient(135deg, var(--gold-highlight) 0%, #d97706 100%);
    --danger-gradient: linear-gradient(135deg, var(--fire-red) 0%, #dc2626 100%);
    --surface-gradient: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
    --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    --card-shadow-hover: 0 20px 60px rgba(0, 0, 0, 0.15);
    --glass-bg: rgba(255, 255, 255, 0.25);
    --glass-border: rgba(255, 255, 255, 0.18);
    --backdrop-blur: blur(10px);
    --border-radius-lg: 16px;
    --border-radius-xl: 24px;
    --transition-smooth: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Modern Page Header with Live Status */
  .modern-page-header {
    background: var(--primary-gradient);
    border-radius: var(--border-radius-xl);
    padding: 2rem;
    margin-bottom: 2rem;
    color: white;
    position: relative;
    overflow: hidden;
  }

  .modern-page-header::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 200px;
    height: 200px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    transform: translate(50%, -50%);
  }

  .modern-page-header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin: 0;
    position: relative;
    z-index: 2;
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .modern-page-header p {
    font-size: 1.1rem;
    opacity: 0.9;
    margin: 0.5rem 0 0 0;
    position: relative;
    z-index: 2;
  }

  .live-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(255, 255, 255, 0.15);
    padding: 1rem 1.5rem;
    border-radius: 12px;
    margin-top: 1.5rem;
    font-size: 1rem;
    position: relative;
    z-index: 2;
    border: 1px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
  }

  .live-status {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-weight: 600;
  }

  .live-indicator {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #10b981;
    animation: pulse-live 2s infinite;
    box-shadow: 0 0 15px rgba(16, 185, 129, 0.6);
    position: relative;
  }

  .live-indicator::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    border-radius: 50%;
    border: 2px solid rgba(16, 185, 129, 0.3);
    animation: ripple 2s infinite;
  }

  .datetime-display {
    font-family: 'Courier New', monospace;
    font-weight: 600;
    letter-spacing: 0.5px;
    font-size: 1rem;
    padding: 0.5rem 1rem;
    background: rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .status-text {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .status-text i {
    color: #10b981;
    font-size: 1.1rem;
  }

  @keyframes pulse-live {
    0%, 100% {
      opacity: 1;
      transform: scale(1);
      box-shadow: 0 0 15px rgba(16, 185, 129, 0.6);
    }
    50% {
      opacity: 0.7;
      transform: scale(1.3);
      box-shadow: 0 0 25px rgba(16, 185, 129, 0.8);
    }
  }

  @keyframes ripple {
    0% {
      transform: scale(1);
      opacity: 1;
    }
    100% {
      transform: scale(2);
      opacity: 0;
    }
  }

  /* Modern Control Panel */
  .modern-controls {
    background: white;
    border-radius: var(--border-radius-lg);
    padding: 1.5rem;
    margin-bottom: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .modern-controls .control-section {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .modern-controls .control-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .modern-controls label {
    font-size: 0.875rem;
    font-weight: 600;
    color: #64748b;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .modern-controls select,
  .modern-controls input {
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    padding: 0.75rem 1rem;
    font-size: 0.9rem;
    transition: var(--transition-smooth);
    background: white;
    min-width: 140px;
  }

  .modern-controls select:focus,
  .modern-controls input:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    outline: none;
  }

  /* Modern Action Buttons */
  .modern-actions {
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 2rem;
  }

  .modern-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.875rem 1.5rem;
    border: none;
    border-radius: 12px;
    font-weight: 600;
    font-size: 0.9rem;
    text-decoration: none;
    transition: var(--transition-smooth);
    position: relative;
    overflow: hidden;
  }

  .modern-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
  }

  .modern-btn:hover::before {
    left: 100%;
  }

  .modern-btn-primary {
    background: var(--primary-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
  }

  .modern-btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    color: white;
  }

  .modern-btn-secondary {
    background: #f8fafc;
    color: #475569;
    border: 2px solid #e2e8f0;
  }

  .modern-btn-secondary:hover {
    background: #f1f5f9;
    transform: translateY(-2px);
    color: #475569;
  }

  .modern-btn-success {
    background: var(--success-gradient);
    color: white;
    box-shadow: 0 4px 15px rgba(17, 153, 142, 0.3);
  }

  .modern-btn-success:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(17, 153, 142, 0.4);
    color: white;
  }

  /* Modern KPI Cards */
  .modern-kpi-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .modern-kpi-card {
    background: white;
    border-radius: var(--border-radius-lg);
    padding: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: var(--transition-smooth);
    position: relative;
    overflow: hidden;
  }

  .modern-kpi-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--primary-gradient);
    transform: scaleX(0);
    transition: transform 0.3s ease;
  }

  .modern-kpi-card:hover {
    transform: translateY(-8px);
    box-shadow: var(--card-shadow-hover);
  }

  .modern-kpi-card:hover::before {
    transform: scaleX(1);
  }

  .modern-kpi-card .kpi-icon {
    width: 60px;
    height: 60px;
    border-radius: 16px;
    background: var(--primary-gradient);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 1.5rem;
    color: white;
    font-size: 1.5rem;
  }

  .modern-kpi-card .kpi-value {
    font-size: 2.5rem;
    font-weight: 800;
    background: var(--primary-gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin: 0;
    line-height: 1;
  }

  .modern-kpi-card .kpi-label {
    font-size: 0.9rem;
    color: #64748b;
    font-weight: 600;
    margin-top: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .modern-kpi-card .kpi-trend {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 1rem;
    font-size: 0.85rem;
    font-weight: 600;
  }

  .modern-kpi-card .kpi-trend.positive {
    color: #10b981;
  }

  .modern-kpi-card .kpi-trend.negative {
    color: #ef4444;
  }

  /* Modern Category KPIs */
  .category-kpis-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
  }

  .category-kpi-card {
    background: white;
    border-radius: var(--border-radius-lg);
    padding: 1.5rem;
    box-shadow: var(--card-shadow);
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: var(--transition-smooth);
    text-align: center;
  }

  .category-kpi-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--card-shadow-hover);
  }

  .category-kpi-card h6 {
    font-size: 0.9rem;
    color: #475569;
    font-weight: 600;
    margin-bottom: 1rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .category-metrics {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .category-metric {
    text-align: center;
  }

  .category-metric .value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #1e293b;
  }

  .category-metric .label {
    font-size: 0.75rem;
    color: #64748b;
    text-transform: uppercase;
    font-weight: 600;
    letter-spacing: 0.5px;
  }

  /* Modern Chart Cards */
  .modern-chart-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    margin-bottom: 2rem;
  }

  .modern-chart-card {
    background: white;
    border-radius: var(--border-radius-lg);
    padding: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: var(--transition-smooth);
  }

  .modern-chart-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--card-shadow-hover);
  }

  .modern-chart-card h6 {
    font-size: 1.1rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 1.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .modern-chart-card h6::before {
    content: '';
    width: 4px;
    height: 20px;
    background: var(--primary-gradient);
    border-radius: 2px;
  }

  /* Chart Container Constraints */
  .chart-container {
    position: relative;
    height: 300px;
    width: 100%;
    margin-bottom: 1rem;
  }

  .chart-container.small {
    height: 200px;
  }

  .chart-container canvas {
    max-height: 100% !important;
    max-width: 100% !important;
  }

  /* Full width chart container */
  .full-width-chart {
    position: relative;
    height: 250px;
    width: 100%;
    margin-bottom: 1rem;
  }

  /* Modern Tables */
  .modern-table-card {
    background: white;
    border-radius: var(--border-radius-lg);
    padding: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid rgba(255, 255, 255, 0.2);
    margin-bottom: 2rem;
    overflow: hidden;
  }

  /* AI Intelligence Cards */
  .ai-intel-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
  }

  .ai-intel-card {
    background: white;
    border-radius: var(--border-radius-lg);
    padding: 1.75rem;
    box-shadow: var(--card-shadow);
    border: 1px solid rgba(226, 232, 240, 0.6);
    position: relative;
    overflow: hidden;
  }

  .ai-intel-card::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.08), rgba(118, 75, 162, 0.05));
    opacity: 0.75;
    pointer-events: none;
  }

  .ai-card-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-weight: 700;
    font-size: 1.1rem;
    margin-bottom: 1rem;
    position: relative;
    z-index: 2;
  }

  .ai-card-header i {
    color: #667eea;
    font-size: 1.25rem;
  }

  .ai-header-meta {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .ai-confidence-badge,
  .ai-source-chip {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 0.35rem 0.6rem;
    border-radius: 999px;
    background: rgba(102, 126, 234, 0.12);
    color: #4338ca;
  }

  .ai-source-chip {
    background: rgba(79, 70, 229, 0.08);
    color: #3730a3;
  }

  .ai-source-chip.server {
    background: rgba(16, 185, 129, 0.12);
    color: #047857;
  }

  .ai-source-chip.client {
    background: rgba(59, 130, 246, 0.12);
    color: #1d4ed8;
  }

  .ai-automation-state {
    margin-left: auto;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 0.35rem 0.6rem;
    border-radius: 999px;
    background: rgba(102, 126, 234, 0.12);
    color: #4338ca;
  }

  .ai-automation-state.active {
    background: rgba(245, 158, 11, 0.15);
    color: #b45309;
  }

  .ai-trend-health {
    margin-left: auto;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 0.35rem 0.6rem;
    border-radius: 999px;
    background: rgba(59, 130, 246, 0.12);
    color: #1d4ed8;
  }

  .ai-trend-health.improving {
    background: rgba(16, 185, 129, 0.18);
    color: #047857;
  }

  .ai-trend-health.risk {
    background: rgba(248, 113, 113, 0.18);
    color: #b91c1c;
  }

  .ai-insights-summary,
  .ai-automation-summary {
    position: relative;
    z-index: 2;
    color: #475569;
    font-size: 0.95rem;
    line-height: 1.6;
    margin-bottom: 1.25rem;
  }

  .ai-insights-list,
  .ai-actions-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 0.85rem;
    position: relative;
    z-index: 2;
  }

  .ai-insight-item,
  .ai-action-item {
    display: flex;
    gap: 0.85rem;
    align-items: flex-start;
    border-radius: 14px;
    padding: 0.85rem 1rem;
    background: rgba(102, 126, 234, 0.08);
    border: 1px solid rgba(226, 232, 240, 0.6);
    backdrop-filter: blur(6px);
  }

  .ai-insight-item.negative,
  .ai-action-item.urgent {
    background: rgba(248, 113, 113, 0.12);
    border-color: rgba(248, 113, 113, 0.3);
  }

  .ai-insight-item.positive {
    background: rgba(16, 185, 129, 0.12);
    border-color: rgba(16, 185, 129, 0.25);
  }

  .ai-icon {
    width: 32px;
    height: 32px;
    border-radius: 10px;
    display: grid;
    place-items: center;
    flex-shrink: 0;
    background: white;
    color: #4338ca;
    box-shadow: 0 6px 15px rgba(102, 126, 234, 0.18);
  }

  .ai-insight-item.negative .ai-icon,
  .ai-action-item.urgent .ai-icon {
    color: #b91c1c;
    box-shadow: 0 6px 15px rgba(248, 113, 113, 0.25);
  }

  .ai-insight-item.positive .ai-icon {
    color: #059669;
    box-shadow: 0 6px 15px rgba(16, 185, 129, 0.25);
  }

  .ai-insight-content strong,
  .ai-action-content strong {
    display: block;
    font-size: 0.95rem;
    margin-bottom: 0.25rem;
  }

  .ai-insight-content span,
  .ai-action-content span {
    font-size: 0.9rem;
    color: #475569;
    line-height: 1.5;
  }

  .ai-next-best-action {
    margin-top: 1.5rem;
    padding: 1rem 1.2rem;
    border-radius: 14px;
    background: rgba(59, 130, 246, 0.1);
    border: 1px dashed rgba(59, 130, 246, 0.3);
    position: relative;
    z-index: 2;
    font-size: 0.9rem;
    color: #1d4ed8;
    display: flex;
    gap: 0.75rem;
    align-items: flex-start;
  }

  .ai-next-best-action i {
    font-size: 1.1rem;
    margin-top: 0.1rem;
  }

  .ai-next-best-action strong {
    display: block;
    font-size: 0.95rem;
  }

  .ai-trend-summary {
    position: relative;
    z-index: 2;
    color: #475569;
    font-size: 0.95rem;
    line-height: 1.6;
    margin-bottom: 1.25rem;
  }

  .ai-trend-visual {
    position: relative;
    z-index: 2;
    background: rgba(102, 126, 234, 0.06);
    border: 1px solid rgba(226, 232, 240, 0.6);
    border-radius: 14px;
    padding: 1rem;
    margin-bottom: 1.25rem;
  }

  .ai-trend-visual canvas {
    width: 100% !important;
    height: 180px !important;
  }

  .ai-trend-forecast {
    margin-top: 0.75rem;
    font-size: 0.85rem;
    color: #334155;
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }

  .ai-trend-forecast span {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.25rem 0.6rem;
    border-radius: 999px;
    background: rgba(15, 118, 110, 0.12);
    color: #0f766e;
    font-weight: 600;
  }

  @media (max-width: 992px) {
    .ai-intel-grid {
      grid-template-columns: 1fr;
    }
  }

  /* AI Intelligence Cards */
  .ai-intel-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
  }

  .ai-intel-card {
    background: white;
    border-radius: var(--border-radius-lg);
    padding: 1.75rem;
    box-shadow: var(--card-shadow);
    border: 1px solid rgba(226, 232, 240, 0.6);
    position: relative;
    overflow: hidden;
  }

  .ai-intel-card::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.08), rgba(118, 75, 162, 0.05));
    opacity: 0.75;
    pointer-events: none;
  }

  .ai-card-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-weight: 700;
    font-size: 1.1rem;
    margin-bottom: 1rem;
    position: relative;
    z-index: 2;
  }

  .ai-card-header i {
    color: #667eea;
    font-size: 1.25rem;
  }

  .ai-header-meta {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .ai-confidence-badge,
  .ai-source-chip {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 0.35rem 0.6rem;
    border-radius: 999px;
    background: rgba(102, 126, 234, 0.12);
    color: #4338ca;
  }

  .ai-source-chip {
    background: rgba(79, 70, 229, 0.08);
    color: #3730a3;
  }

  .ai-source-chip.server {
    background: rgba(16, 185, 129, 0.12);
    color: #047857;
  }

  .ai-source-chip.client {
    background: rgba(59, 130, 246, 0.12);
    color: #1d4ed8;
  }

  .ai-automation-state {
    margin-left: auto;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 0.35rem 0.6rem;
    border-radius: 999px;
    background: rgba(102, 126, 234, 0.12);
    color: #4338ca;
  }

  .ai-automation-state.active {
    background: rgba(245, 158, 11, 0.15);
    color: #b45309;
  }

  .ai-trend-health {
    margin-left: auto;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 0.35rem 0.6rem;
    border-radius: 999px;
    background: rgba(59, 130, 246, 0.12);
    color: #1d4ed8;
  }

  .ai-trend-health.improving {
    background: rgba(16, 185, 129, 0.18);
    color: #047857;
  }

  .ai-trend-health.risk {
    background: rgba(248, 113, 113, 0.18);
    color: #b91c1c;
  }

  .ai-insights-summary,
  .ai-automation-summary {
    position: relative;
    z-index: 2;
    color: #475569;
    font-size: 0.95rem;
    line-height: 1.6;
    margin-bottom: 1.25rem;
  }

  .ai-insights-list,
  .ai-actions-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 0.85rem;
    position: relative;
    z-index: 2;
  }

  .ai-insight-item,
  .ai-action-item {
    display: flex;
    gap: 0.85rem;
    align-items: flex-start;
    border-radius: 14px;
    padding: 0.85rem 1rem;
    background: rgba(102, 126, 234, 0.08);
    border: 1px solid rgba(226, 232, 240, 0.6);
    backdrop-filter: blur(6px);
  }

  .ai-insight-item.negative,
  .ai-action-item.urgent {
    background: rgba(248, 113, 113, 0.12);
    border-color: rgba(248, 113, 113, 0.3);
  }

  .ai-insight-item.positive {
    background: rgba(16, 185, 129, 0.12);
    border-color: rgba(16, 185, 129, 0.25);
  }

  .ai-icon {
    width: 32px;
    height: 32px;
    border-radius: 10px;
    display: grid;
    place-items: center;
    flex-shrink: 0;
    background: white;
    color: #4338ca;
    box-shadow: 0 6px 15px rgba(102, 126, 234, 0.18);
  }

  .ai-insight-item.negative .ai-icon,
  .ai-action-item.urgent .ai-icon {
    color: #b91c1c;
    box-shadow: 0 6px 15px rgba(248, 113, 113, 0.25);
  }

  .ai-insight-item.positive .ai-icon {
    color: #059669;
    box-shadow: 0 6px 15px rgba(16, 185, 129, 0.25);
  }

  .ai-insight-content strong,
  .ai-action-content strong {
    display: block;
    font-size: 0.95rem;
    margin-bottom: 0.25rem;
  }

  .ai-insight-content span,
  .ai-action-content span {
    font-size: 0.9rem;
    color: #475569;
    line-height: 1.5;
  }

  .ai-next-best-action {
    margin-top: 1.5rem;
    padding: 1rem 1.2rem;
    border-radius: 14px;
    background: rgba(59, 130, 246, 0.1);
    border: 1px dashed rgba(59, 130, 246, 0.3);
    position: relative;
    z-index: 2;
    font-size: 0.9rem;
    color: #1d4ed8;
    display: flex;
    gap: 0.75rem;
    align-items: flex-start;
  }

  .ai-next-best-action i {
    font-size: 1.1rem;
    margin-top: 0.1rem;
  }

  .ai-next-best-action strong {
    display: block;
    font-size: 0.95rem;
  }

  .ai-trend-summary {
    position: relative;
    z-index: 2;
    color: #475569;
    font-size: 0.95rem;
    line-height: 1.6;
    margin-bottom: 1.25rem;
  }

  .ai-trend-visual {
    position: relative;
    z-index: 2;
    background: rgba(102, 126, 234, 0.06);
    border: 1px solid rgba(226, 232, 240, 0.6);
    border-radius: 14px;
    padding: 1rem;
    margin-bottom: 1.25rem;
  }

  .ai-trend-visual canvas {
    width: 100% !important;
    height: 180px !important;
  }

  .ai-trend-forecast {
    margin-top: 0.75rem;
    font-size: 0.85rem;
    color: #334155;
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }

  .ai-trend-forecast span {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.25rem 0.6rem;
    border-radius: 999px;
    background: rgba(15, 118, 110, 0.12);
    color: #0f766e;
    font-weight: 600;
  }

  @media (max-width: 992px) {
    .ai-intel-grid {
      grid-template-columns: 1fr;
    }
  }

  .modern-table-card h6 {
    font-size: 1.1rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 1.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .modern-table-card h6::before {
    content: '';
    width: 4px;
    height: 20px;
    background: var(--success-gradient);
    border-radius: 2px;
  }

  .modern-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
  }

  .modern-table th {
    background: #f8fafc;
    color: #475569;
    font-weight: 600;
    padding: 1rem;
    text-align: left;
    border-bottom: 2px solid #e2e8f0;
    text-transform: uppercase;
    font-size: 0.8rem;
    letter-spacing: 0.5px;
  }

  .modern-table td {
    padding: 1rem;
    border-bottom: 1px solid #f1f5f9;
    color: #334155;
  }

  .modern-table tbody tr {
    transition: background-color 0.2s ease;
  }

  .modern-table tbody tr:hover {
    background: #f8fafc;
  }

  /* Badge styles for agent table */
  .status-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .status-badge.excellent {
    background: rgba(16, 185, 129, 0.1);
    color: #10b981;
    border: 1px solid rgba(16, 185, 129, 0.2);
  }

  .status-badge.good {
    background: rgba(59, 130, 246, 0.1);
    color: #3b82f6;
    border: 1px solid rgba(59, 130, 246, 0.2);
  }

  .status-badge.needs-improvement {
    background: rgba(245, 158, 11, 0.1);
    color: #f59e0b;
    border: 1px solid rgba(245, 158, 11, 0.2);
  }

  .status-badge .badge-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: currentColor;
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .modern-page-header {
      padding: 1.5rem;
      text-align: center;
    }

    .modern-page-header h1 {
      font-size: 2rem;
      justify-content: center;
    }

    .live-header {
      flex-direction: column;
      gap: 1rem;
      text-align: center;
    }

    .datetime-display {
      font-size: 0.9rem;
    }

    .modern-controls .control-section {
      flex-direction: column;
      align-items: stretch;
    }

    .modern-controls select,
    .modern-controls input {
      min-width: auto;
    }

    .modern-chart-grid {
      grid-template-columns: 1fr;
    }

    .chart-container {
      height: 250px;
    }

    .full-width-chart {
      height: 200px;
    }

    .modern-kpi-grid {
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }

    .modern-actions {
      justify-content: center;
    }

    .modern-btn {
      font-size: 0.8rem;
      padding: 0.75rem 1.25rem;
    }
  }

  /* Animation Enhancements */
  .fade-in {
    animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .stagger-animation>* {
    opacity: 0;
    animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  .stagger-animation>*:nth-child(1) {
    animation-delay: 0.1s;
  }

  .stagger-animation>*:nth-child(2) {
    animation-delay: 0.2s;
  }

  .stagger-animation>*:nth-child(3) {
    animation-delay: 0.3s;
  }

  .stagger-animation>*:nth-child(4) {
    animation-delay: 0.4s;
  }

  .stagger-animation>*:nth-child(5) {
    animation-delay: 0.5s;
  }

  .stagger-animation>*:nth-child(6) {
    animation-delay: 0.6s;
  }
</style>

<!-- Modern Page Header with Live Status -->
<div class="modern-page-header fade-in">
  <p>
    Monitor performance metrics and quality assurance
    <? if (typeof campaignName !== 'undefined' && campaignName) { ?>
    for <strong><?= campaignName ?></strong> campaign
    <? } else { ?>
    across all agents
    <? } ?>
  </p>
  
  <div class="live-header">
    <div class="live-status">
      <div class="live-indicator"></div>
    </div>
  </div>
</div>

<!-- Modern Control Panel -->
<div class="modern-controls fade-in">
  <div class="row">
    <div class="col-md-8">
      <div class="control-section">
        <div class="control-group">
          <label>Report Type</label>
          <select id="reportTypeSelect" class="form-select">
                <option value="dashboard" <?= currentPage==="Dashboard" ? "selected":"" ?>>Dashboard</option>
                <option value="callreports" <?= currentPage==="CallReports" ? "selected":"" ?>>Call Reports</option>
                <option value="attendancereports" <?= currentPage==="AttendanceReports" ? "selected":"" ?>>Attendance Reports</option>
                <option value="ibtrqualityreports" <?= currentPage==="QualityReports" ? "selected":"" ?>>Quality Report</option>
                <option value="incentives" <?= currentPage==="Incentives" ? "selected":"" ?>>Incentives</option>
              </select>
        </div>

        <div class="control-group">
          <label>Time Period</label>
          <select class="form-select" id="granularitySelect">
                <option value="Week" selected>Week</option>
                <option value="Month">Month</option>
                <option value="Quarter">Quarter</option>
                <option value="Year">Year</option>
              </select>
        </div>

        <div class="control-group">
          <label>Agent Filter</label>
          <select class="form-select" id="agentSelect">
                <option value="">
                    All Agents
                </option>
                <? userList.forEach(function(u) { ?>
                  <option value="<?= u ?>" <?= u === selectedAgent ? "selected" : "" ?>>
                    <?= u ?>
                  </option>
                <? }); ?>
              </select>
        </div>

        <!-- Period Pickers -->
        <div class="control-group" id="weekPicker" style="display: none;">
          <label>Week</label>
          <input type="week" class="form-control" id="weekInput" />
        </div>
        <div class="control-group" id="monthPicker" style="display: none;">
          <label>Month</label>
          <input type="month" class="form-control" id="monthInput" />
        </div>
        <div class="control-group" id="quarterPicker" style="display: none;">
          <label>Quarter</label>
          <div class="d-flex gap-2">
            <select class="form-select" id="quarterSelect">
                  <option value="Q1">Q1</option>
                  <option value="Q2">Q2</option>
                  <option value="Q3">Q3</option>
                  <option value="Q4">Q4</option>
                </select>
            <input type="number" class="form-control" id="quarterYearInput" placeholder="YYYY" min="2000" max="2100" style="width: 100px;" />
          </div>
        </div>
        <div class="control-group" id="yearPicker" style="display: none;">
          <label>Year</label>
          <input type="number" class="form-control" id="yearInput" placeholder="YYYY" min="2000" max="2100"/>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modern Action Buttons -->
<div class="modern-actions fade-in">
  <? 
        // Build clean URLs without exposing campaign context
        function buildUrl(page) {
          return baseUrl + '?page=' + page;
        }
      ?>
  <a href="<?= buildUrl('qualityform') ?>" class="modern-btn modern-btn-primary">
    <i class="fas fa-clipboard-check"></i> New Quality
  </a>
  <a href="<?= buildUrl('qualitylist') ?>" class="modern-btn modern-btn-secondary">
    <i class="fas fa-list"></i> Quality List
  </a>
  <button id="exportCsvBtn" class="modern-btn modern-btn-success">
        <i class="fas fa-file-csv"></i> Export CSV
      </button>
  <a href="<?= buildUrl('coachinglist') ?>" class="modern-btn modern-btn-secondary">
    <i class="fas fa-chalkboard-teacher"></i> Coaching
  </a>
  <a href="<?= buildUrl('qualityform') ?>" class="modern-btn modern-btn-primary">
    <i class="fas fa-users"></i> New Collab Quality
  </a>
  <a href="<?= buildUrl('qacollablist') ?>" class="modern-btn modern-btn-secondary">
    <i class="fas fa-list-check"></i> Quality Collab List
  </a>
</div>

<!-- Modern KPI Cards -->
<div class="modern-kpi-grid stagger-animation">
  <div class="modern-kpi-card">
    <div class="kpi-icon">
      <i class="fas fa-chart-line"></i>
    </div>
    <div class="kpi-value" id="kpiAvgScore">0%</div>
    <div class="kpi-label">Average Score</div>
    <div class="kpi-trend" id="kpiAvgScoreTrend">
      <i class="fas fa-arrow-up"></i>
      <span>0% vs last period</span>
    </div>
  </div>

  <div class="modern-kpi-card">
    <div class="kpi-icon" style="background: var(--success-gradient);">
      <i class="fas fa-check-circle"></i>
    </div>
    <div class="kpi-value" id="kpiPassRate">0%</div>
    <div class="kpi-label">Pass Rate</div>
    <div class="kpi-trend" id="kpiPassRateTrend">
      <i class="fas fa-arrow-up"></i>
      <span>0% vs last period</span>
    </div>
  </div>

  <div class="modern-kpi-card">
    <div class="kpi-icon" style="background: var(--info-gradient);">
      <i class="fas fa-users"></i>
    </div>
    <div class="kpi-value" id="kpiAgentsEval">0%</div>
    <div class="kpi-label">Agents Evaluated</div>
    <div class="kpi-trend" id="kpiAgentsEvalTrend">
      <i class="fas fa-arrow-up"></i>
      <span>0% vs last period</span>
    </div>
  </div>

  <div class="modern-kpi-card">
    <div class="kpi-icon" style="background: var(--warning-gradient);">
      <i class="fas fa-tasks"></i>
    </div>
    <div class="kpi-value" id="kpiEvalsDone">0%</div>
    <div class="kpi-label">Evaluations Completed</div>
    <div class="kpi-trend" id="kpiEvalsDoneTrend">
      <i class="fas fa-arrow-up"></i>
      <span>0% vs last period</span>
    </div>
  </div>
</div>

<!-- Category KPIs -->
<div class="category-kpis-grid stagger-animation" id="categoryKpis">
  <!-- Dynamically populated by JavaScript -->
</div>

<!-- AI Intelligence Layer -->
<div class="ai-intel-grid fade-in">
  <div class="ai-intel-card">
    <div class="ai-card-header">
      <i class="fas fa-robot"></i>
      <span>Lumina QA Copilot</span>
      <div class="ai-header-meta">
        <span class="ai-source-chip client" id="aiInsightSource" title="Intelligence generated in-browser">Local AI</span>
        <span class="ai-confidence-badge" id="aiConfidenceBadge">Confidence 0%</span>
      </div>
    </div>
    <p class="ai-insights-summary" id="aiInsightsSummary">AI insights will appear once data loads.</p>
    <ul class="ai-insights-list" id="aiInsightsList"></ul>
  </div>

  <div class="ai-intel-card">
    <div class="ai-card-header">
      <i class="fas fa-bolt"></i>
      <span>Automation Playbook</span>
      <span class="ai-automation-state" id="aiAutomationState">Monitoring</span>
    </div>
    <p class="ai-automation-summary" id="aiAutomationSummary">AI recommendations will populate after analysis.</p>
    <ul class="ai-actions-list" id="aiRecommendationsList"></ul>
    <div class="ai-next-best-action" id="aiNextBestAction" style="display: none;">
      <i class="fas fa-magic"></i>
      <div>
        <strong>Next best automation</strong>
        <span id="aiNextBestActionText"></span>
      </div>
    </div>
  </div>
  <div class="ai-intel-card">
    <div class="ai-card-header">
      <i class="fas fa-chart-line"></i>
      <span>AI Trend Radar</span>
      <span class="ai-trend-health" id="aiTrendHealth">Monitoring</span>
    </div>
    <p class="ai-trend-summary" id="aiTrendSummary">Trend intelligence will populate after analysis.</p>
    <div class="ai-trend-visual" id="aiTrendVisual" style="display: none;">
      <canvas id="aiTrendSparkline"></canvas>
      <div class="ai-trend-forecast" id="aiTrendForecast"></div>
    </div>
    <ul class="ai-insights-list" id="aiTrendList"></ul>
  </div>
</div>

<!-- Modern Charts -->
<div class="modern-chart-grid stagger-animation">
  <div class="modern-chart-card">
    <h6><i class="fas fa-calendar-day me-2"></i>Daily Performance</h6>
    <div class="chart-container">
      <canvas id="dailyChart"></canvas>
    </div>
  </div>

  <div class="modern-chart-card">
    <h6><i class="fas fa-user-friends me-2"></i>Agent Activity</h6>
    <div class="chart-container">
      <canvas id="agentChart"></canvas>
    </div>
  </div>
</div>

<!-- Category Comparison Chart -->
<div class="modern-chart-card fade-in">
  <h6><i class="fas fa-chart-bar me-2"></i>Category Comparison</h6>
  <div class="full-width-chart">
    <canvas id="categoryChart"></canvas>
  </div>
</div>

<!-- Modern Tables -->
<div class="row">
  <div class="col-lg-6 mb-4 mt-4">
    <div class="modern-table-card fade-in">
      <h6><i class="fas fa-layer-group me-2"></i>Performance by Category</h6>
      <div class="table-responsive">
        <table class="modern-table" id="categoryTable">
          <thead>
            <tr>
              <th>Category</th>
              <th>Avg Score</th>
              <th>Pass Rate</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="col-lg-6 mb-4 mt-4">
    <div class="modern-table-card fade-in">
      <h6><i class="fas fa-users-cog me-2"></i>Agent Performance</h6>
      <div class="table-responsive">
        <table class="modern-table" id="agentTable">
          <thead>
            <tr>
              <th>Agent</th>
              <th>Evals %</th>
              <th>Avg Score</th>
              <th>Pass Rate</th>
              <th>Recent</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  const campaignId = '<?= typeof campaignId !== "undefined" ? campaignId : "" ?>';
      const campaignName = '<?= typeof campaignName !== "undefined" ? campaignName : "" ?>';

      let lastFilteredData = [];

      const PASS_MARK = 0.95;
      const PASS_SCORE_THRESHOLD = PASS_MARK * 100;

      const rawQA = JSON.parse('<?= qaRecords ?>');
      let currentGran = '<?= granularity ?>';
      let currentPeriod = '<?= periodValue ?>';
      let currentAgent = '<?= selectedAgent ?>';
      let userList = <?!= JSON.stringify(userList || []) ?>;
      let qaIntelligenceRequestToken = 0;

      const weightsMap = { Q1:5,Q2:5,Q3:8,Q4:10,Q5:5,Q6:5,Q7:5,Q8:10,Q9:10,Q10:5,Q11:5,Q12:5,Q13:8,Q14:5,Q15:2,Q16:1,Q17:1,Q18:5 };
      const categories = {
        'Courtesy & Communication':['Q1','Q2','Q3','Q4','Q5'],
        'Resolution':['Q6','Q7','Q8','Q9'],
        'Case Documentation':['Q10','Q11','Q12','Q13','Q14'],
        'Process Compliance':['Q15','Q16','Q17','Q18']
      };

      rawQA.forEach((record, index) => {
        rawQA[index] = normalizeClientQaRecord(record, index);
      });

      // Live datetime display function
      function updateLiveDatetime() {
        const now = new Date();
        
        const options = {
          weekday: 'short',
          year: 'numeric',
          month: 'short',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: true,
          timeZoneName: 'short'
        };
        
        const formatted = now.toLocaleDateString('en-US', options);
        const datetimeDisplay = document.getElementById('liveDatetime');
        
        if (datetimeDisplay) {
          datetimeDisplay.textContent = formatted;
        }
      }

      function safeToDate(value) {
        return coerceDateValue(value);
      }

      function safeToISOString(dateValue) {
          const date = safeToDate(dateValue);
          return date ? date.toISOString() : null;
      }

      function normalizeKeyName(key) {
        return String(key || '')
          .toLowerCase()
          .replace(/[^a-z0-9]/g, '');
      }

      function getRecordField(record, candidates) {
        if (!record || typeof record !== 'object') {
          return null;
        }

        const lookup = {};
        Object.keys(record).forEach(existingKey => {
          const normalized = normalizeKeyName(existingKey);
          if (!(normalized in lookup)) {
            lookup[normalized] = existingKey;
          }
        });

        for (let i = 0; i < candidates.length; i += 1) {
          const normalizedKey = normalizeKeyName(candidates[i]);
          const actualKey = lookup[normalizedKey];
          if (actualKey && record[actualKey] !== undefined && record[actualKey] !== null && record[actualKey] !== '') {
            return record[actualKey];
          }
        }

        return null;
      }

      function clamp01(value) {
        if (!isFinite(value)) {
          return 0;
        }
        if (value < 0) return 0;
        if (value > 1) return 1;
        return value;
      }

      function parsePercentageValue(value) {
        if (value === null || value === undefined || value === '') {
          return 0;
        }

        if (typeof value === 'number' && isFinite(value)) {
          const normalized = value > 1.0001 ? value / 100 : value;
          return clamp01(normalized);
        }

        const numeric = parseFloat(String(value).replace(/[^0-9.\-]/g, ''));
        if (!isFinite(numeric)) {
          return 0;
        }

        const normalized = numeric > 1.0001 ? numeric / 100 : numeric;
        return clamp01(normalized);
      }

      function excelSerialToDate(serial) {
        if (typeof serial !== 'number' || !isFinite(serial)) {
          return null;
        }

        if (serial <= 60) {
          return null;
        }

        const utcDays = Math.floor(serial - 25569);
        const utcMilliseconds = utcDays * 86400000;
        const remainder = serial - Math.floor(serial);
        const remainderMs = Math.round(remainder * 86400000);
        const date = new Date(utcMilliseconds + remainderMs);
        return isNaN(date.getTime()) ? null : date;
      }

      function parseFlexibleDateString(raw) {
        if (!raw) {
          return null;
        }

        const value = String(raw).trim();
        if (!value) {
          return null;
        }

        if (/^\d+(\.\d+)?$/.test(value)) {
          const asNumber = parseFloat(value);
          const excelDate = excelSerialToDate(asNumber);
          if (excelDate) {
            return excelDate;
          }
        }

        if (/^\d{8}$/.test(value)) {
          const year = Number(value.slice(0, 4));
          const month = Number(value.slice(4, 6)) - 1;
          const day = Number(value.slice(6, 8));
          const ymdDate = new Date(year, month, day);
          if (!isNaN(ymdDate.getTime())) {
            return ymdDate;
          }
        }

        let parsed = new Date(value);
        if (!isNaN(parsed.getTime())) {
          return parsed;
        }

        if (value.includes(' ') && !value.includes('T')) {
          parsed = new Date(value.replace(' ', 'T'));
          if (!isNaN(parsed.getTime())) {
            return parsed;
          }
        }

        const parts = value.split(/[\/\-]/).map(part => part.trim());
        if (parts.length === 3 && parts.every(part => /^\d+$/.test(part))) {
          let [p1, p2, p3] = parts.map(Number);
          if (p3 < 100) {
            p3 = p3 < 50 ? 2000 + p3 : 1900 + p3;
          }

          let month;
          let day;
          let year;

          if (p1 > 12 && p2 <= 12) {
            day = p1;
            month = p2;
            year = p3;
          } else if (p2 > 12 && p1 <= 12) {
            month = p1;
            day = p2;
            year = p3;
          } else {
            month = p1;
            day = p2;
            year = p3;
          }

          const manualDate = new Date(year, month - 1, day);
          if (!isNaN(manualDate.getTime())) {
            return manualDate;
          }
        }

        return null;
      }

      function coerceDateValue(value) {
        if (value === null || value === undefined || value === '') {
          return null;
        }

        if (value instanceof Date) {
          return isNaN(value.getTime()) ? null : value;
        }

        if (typeof value === 'number' && isFinite(value)) {
          const excelDate = excelSerialToDate(value);
          if (excelDate) {
            return excelDate;
          }

          const numericDate = new Date(value);
          return isNaN(numericDate.getTime()) ? null : numericDate;
        }

        return parseFlexibleDateString(value);
      }

      function normalizeClientQaRecord(record, index) {
        const normalized = { ...record };

        const agentValue = getRecordField(record, ['AgentName', 'Agent Name', 'Agent', 'AgentEmail', 'Agent Email', 'Associate']);
        const campaignValue = getRecordField(record, ['Campaign', 'Campaign Name', 'Program', 'Program Name', 'Line Of Business', 'LineOfBusiness', 'LOB']);
        const percentageValue = getRecordField(record, ['Percentage', 'QA Score', 'QA%', 'QA %', 'Final Score', 'FinalScore', 'Score', 'Overall Score']);
        const callDateValue = getRecordField(record, ['CallDate', 'Call Date', 'CallTime', 'Call Time', 'EvaluationDate', 'Evaluation Date', 'QA Date', 'Date', 'Timestamp']);

        const agentName = agentValue ? String(agentValue).trim() : '';
        const campaign = campaignValue ? String(campaignValue).trim() : '';
        const callDate = coerceDateValue(callDateValue);
        const percentage = parsePercentageValue(percentageValue);

        if (agentName) {
          normalized.AgentName = agentName;
        } else if (!normalized.AgentName) {
          normalized.AgentName = 'Unassigned';
        }

        if (campaign) {
          normalized.Campaign = campaign;
        }

        normalized.Percentage = percentage;
        normalized.callDateObj = callDate;
        normalized.CallDate = callDate instanceof Date ? callDate.toISOString() : null;
        normalized.__recordIndex = index;

        return normalized;
      }

      function isValidDate(dateValue) {
          return safeToDate(dateValue) !== null;
      }
      
      let dailyChart, agentChart, categoryChart, trendSparklineChart;

      function showLoader(detail = 'Loading QA metrics…') {
        const loaderApi = window.LuminaLoader;
        loaderApi?.show({
          title: 'Refreshing QA Dashboard',
          detail,
          tip: 'Crunching performance metrics…',
          progress: 25
        });
      }

      function hideLoader(delay = 250) {
        window.LuminaLoader?.hide(delay);
      }

      function toISOWeek(d){
        d=new Date(Date.UTC(d.getFullYear(),d.getMonth(),d.getDate()));
        const day=d.getUTCDay()||7; d.setUTCDate(d.getUTCDate()+4-day);
        const ys=new Date(Date.UTC(d.getUTCFullYear(),0,1));
        const w=Math.ceil((((d-ys)/86400000)+1)/7);
        return `${d.getUTCFullYear()}-W${String(w).padStart(2,'0')}`;
      }
      function getQuarter(d){ return 'Q'+(Math.floor(d.getMonth()/3)+1); }

      function getPreviousPeriod(granularity, period){
        if(!period) return '';
        switch(granularity){
          case 'Week':{ const [y,w]=period.split('-W'); const n=parseInt(w,10); return (n<=1)?`${parseInt(y,10)-1}-W52`:`${y}-W${String(n-1).padStart(2,'0')}`; }
          case 'Month':{ const [y,m]=period.split('-').map(Number); const date=new Date(y,m-1); date.setMonth(date.getMonth()-1); return `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}`; }
          case 'Quarter':{ const [q,y]=period.split('-'); const n=parseInt(q.replace('Q',''),10); return (n<=1)?`Q4-${parseInt(y,10)-1}`:`Q${n-1}-${y}`; }
          case 'Year': return String(parseInt(period,10)-1);
          default: return '';
        }
      }

      function computeCategoryMetrics(data){
        const out={};
        Object.entries(categories).forEach(([cat,keys])=>{
          const scores=[], passes=[];
          data.forEach(r=>{
            const ans=keys.map(k=>(r[k]||'').toString().toLowerCase()==='yes');
            const earned=keys.reduce((s,k,i)=> s + (ans[i]?weightsMap[k]:0),0);
            const totalW=keys.reduce((s,k)=> s + weightsMap[k],0);
            scores.push(totalW? Math.round(earned/totalW*100):0);
            passes.push(ans.every(Boolean)?1:0);
          });
          const avgScore=scores.length? Math.round(scores.reduce((a,b)=>a+b,0)/scores.length):0;
          const passPct=passes.length? Math.round(passes.reduce((a,b)=>a+b,0)/passes.length*100):0;
          out[cat]={ avgScore, passPct };
        });
        return out;
      }

      function formatPeriodLabel(granularity, period) {
        if (!period) return 'Period';
        switch (granularity) {
          case 'Week':
            return period.replace(/^[0-9]{4}-/, '');
          case 'Month': {
            const [y, m] = period.split('-');
            const date = new Date(Number(y), Number(m) - 1, 1);
            return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
          }
          case 'Quarter':
            return period.replace('-', ' ');
          case 'Year':
            return period;
          default:
            return period;
        }
      }

      function filterRecordsByPeriod(data, granularity, periodValue) {
        if (!periodValue) return [];
        return data.filter(record => {
          const dt = record.callDateObj;
          if (!dt) return false;
          try {
            switch (granularity) {
              case 'Week':
                return toISOWeek(dt) === periodValue;
              case 'Month':
                return dt.toISOString().slice(0, 7) === periodValue;
              case 'Quarter':
                return `${getQuarter(dt)}-${dt.getFullYear()}` === periodValue;
              case 'Year':
                return String(dt.getFullYear()) === periodValue;
              default:
                return true;
            }
          } catch (err) {
            console.warn('filterRecordsByPeriod error', record, err);
            return false;
          }
        });
      }

      function buildTrendSeries(granularity, currentPeriod, data, depth = 4) {
        const series = [];
        let cursor = currentPeriod;
        let steps = 0;
        const visited = new Set();

        while (cursor && steps < depth && !visited.has(cursor)) {
          visited.add(cursor);
          const bucket = filterRecordsByPeriod(data, granularity, cursor);
          const evalCount = bucket.length;
          const agentCount = new Set(bucket.map(r => r.AgentName)).size;
          const avgScore = evalCount ? Math.round(bucket.reduce((sum, r) => sum + (r.Percentage || 0), 0) / evalCount * 100) : 0;
          const passRate = safePercentage(bucket.filter(r => r.Percentage >= PASS_MARK).length, evalCount);
          const coverage = userList.length ? safePercentage(agentCount, userList.length) : (agentCount > 0 ? 100 : 0);

          series.push({
            period: cursor,
            label: formatPeriodLabel(granularity, cursor),
            avgScore,
            passRate,
            evalCount,
            agentCount,
            coverage
          });

          cursor = getPreviousPeriod(granularity, cursor);
          steps += 1;
        }

        return series.reverse();
      }

      function linearRegression(points) {
        if (!points || !points.length) {
          return { slope: 0, intercept: 0 };
        }

        if (points.length === 1) {
          return { slope: 0, intercept: points[0].y };
        }

        const n = points.length;
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumXX = 0;

        points.forEach(point => {
          sumX += point.x;
          sumY += point.y;
          sumXY += point.x * point.y;
          sumXX += point.x * point.x;
        });

        const denominator = (n * sumXX) - (sumX * sumX);
        if (denominator === 0) {
          return { slope: 0, intercept: sumY / n };
        }

        const slope = ((n * sumXY) - (sumX * sumY)) / denominator;
        const intercept = (sumY - slope * sumX) / n;
        return { slope, intercept };
      }

      function clampPercent(value) {
        if (Number.isNaN(value)) return 0;
        return Math.max(0, Math.min(100, Math.round(value)));
      }

      function analyzeTrendSeries(series, context = {}) {
        const { granularity = 'Period' } = context;
        const lowerGran = granularity.toLowerCase();

        if (!series || !series.length) {
          return {
            summary: `Lumina AI is waiting for enough history to analyze ${lowerGran} trends.`,
            points: [],
            health: 'monitoring',
            forecast: { avg: 0, pass: 0 },
            nextLabel: `next ${lowerGran}`
          };
        }

        const first = series[0];
        const last = series[series.length - 1];

        const avgPoints = series.map((point, index) => ({ x: index, y: point.avgScore }));
        const passPoints = series.map((point, index) => ({ x: index, y: point.passRate }));
        const avgReg = linearRegression(avgPoints);
        const passReg = linearRegression(passPoints);

        const avgDelta = last.avgScore - first.avgScore;
        const passDelta = last.passRate - first.passRate;
        const volumeDelta = last.evalCount - first.evalCount;

        const slopeAvg = avgReg.slope;
        const slopePass = passReg.slope;

        const improving = slopeAvg > 0.5 || slopePass > 0.5;
        const declining = slopeAvg < -0.5 || slopePass < -0.5;

        let health = 'stable';
        if (improving) health = 'improving';
        if (declining) health = 'risk';

        const summaryParts = [];
        summaryParts.push(`Average quality is ${avgDelta >= 0 ? 'up' : 'down'} ${Math.abs(avgDelta).toFixed(1)} pts`);
        summaryParts.push(`pass rate ${passDelta >= 0 ? 'gained' : 'slid'} ${Math.abs(passDelta).toFixed(1)} pts`);
        summaryParts.push(`${last.evalCount} evaluations this ${lowerGran}`);

        const points = [];

        points.push({
          icon: improving ? 'fa-arrow-up' : declining ? 'fa-arrow-down' : 'fa-arrows-alt-h',
          tone: improving ? 'positive' : declining ? 'negative' : '',
          title: `Average score ${improving ? 'rising' : declining ? 'dropping' : 'steady'}`,
          text: `${first.avgScore}% → ${last.avgScore}% across the last ${series.length} ${series.length === 1 ? lowerGran : lowerGran + 's'}.`
        });

        points.push({
          icon: passDelta >= 0 ? 'fa-shield-alt' : 'fa-exclamation-triangle',
          tone: passDelta >= 0 ? 'positive' : 'negative',
          title: `Pass rate ${passDelta >= 0 ? 'improving' : 'at risk'}`,
          text: `${first.passRate}% → ${last.passRate}% (${passDelta >= 0 ? '+' : ''}${passDelta.toFixed(1)} pts).`
        });

        if (Math.abs(volumeDelta) > 0) {
          points.push({
            icon: volumeDelta >= 0 ? 'fa-users' : 'fa-user-slash',
            tone: volumeDelta >= 0 ? 'positive' : 'negative',
            title: `Evaluation volume ${volumeDelta >= 0 ? 'growing' : 'contracting'}`,
            text: `${first.evalCount} → ${last.evalCount} evaluations (${volumeDelta >= 0 ? '+' : ''}${volumeDelta}).`
          });
        } else {
          points.push({
            icon: 'fa-stopwatch',
            tone: '',
            title: 'Volume steady',
            text: `Evaluation count steady at ${last.evalCount} per ${lowerGran}.`
          });
        }

        if (last.coverage < 80) {
          points.push({
            icon: 'fa-user-shield',
            tone: 'negative',
            title: 'Coverage gap detected',
            text: `Only ${last.coverage}% of agents covered in the latest ${lowerGran}.`
          });
        }

        const avgForecast = clampPercent(avgReg.intercept + avgReg.slope * avgPoints.length);
        const passForecast = clampPercent(passReg.intercept + passReg.slope * passPoints.length);

        const summary = `${summaryParts.join(', ')}.`;

        return {
          summary,
          points,
          health,
          forecast: { avg: avgForecast, pass: passForecast },
          nextLabel: `next ${lowerGran}`
        };
      }

      function renderTrendSparkline(series, granularity) {
        const visual = document.getElementById('aiTrendVisual');
        const canvas = document.getElementById('aiTrendSparkline');

        if (!visual || !canvas) {
          return;
        }

        if (!series || !series.length) {
          visual.style.display = 'none';
          if (trendSparklineChart) {
            trendSparklineChart.destroy();
            trendSparklineChart = null;
          }
          return;
        }

        visual.style.display = '';

        if (trendSparklineChart) {
          trendSparklineChart.destroy();
          trendSparklineChart = null;
        }

        const labels = series.map(point => point.label || formatPeriodLabel(granularity, point.period));
        const avgData = series.map(point => point.avgScore);
        const passData = series.map(point => point.passRate);

        trendSparklineChart = new Chart(canvas, {
          type: 'line',
          data: {
            labels,
            datasets: [
              {
                label: 'Avg Score',
                data: avgData,
                borderColor: '#6366f1',
                backgroundColor: 'rgba(99,102,241,0.15)',
                tension: 0.4,
                pointRadius: 4,
                pointBackgroundColor: '#6366f1',
                fill: true
              },
              {
                label: 'Pass Rate',
                data: passData,
                borderColor: '#10b981',
                backgroundColor: 'rgba(16,185,129,0.12)',
                tension: 0.4,
                pointRadius: 4,
                pointBackgroundColor: '#10b981',
                fill: true
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                labels: {
                  usePointStyle: true,
                  font: {
                    family: "'Google Sans', sans-serif",
                    size: 11
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(15,23,42,0.9)',
                titleColor: '#fff',
                bodyColor: '#e2e8f0',
                cornerRadius: 10,
                padding: 10
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                grid: { color: 'rgba(15,23,42,0.05)' },
                ticks: { font: { family: "'Google Sans', sans-serif" } }
              },
              x: {
                grid: { display: false },
                ticks: { font: { family: "'Google Sans', sans-serif" } }
              }
            }
          }
        });
      }

      function updateAITrendPanel({ series, granularity }, analysisOverride = null) {
        const summaryEl = document.getElementById('aiTrendSummary');
        const listEl = document.getElementById('aiTrendList');
        const forecastEl = document.getElementById('aiTrendForecast');
        const healthEl = document.getElementById('aiTrendHealth');

        if (!summaryEl || !listEl) {
          return;
        }

        const analysis = analysisOverride || analyzeTrendSeries(series, { granularity });

        summaryEl.textContent = analysis.summary;
        listEl.innerHTML = '';

        if (analysis.points.length) {
          listEl.innerHTML = analysis.points.map(point => {
            const tone = point.tone ? ` ${point.tone}` : '';
            return `<li class="ai-insight-item${tone}"><div class="ai-icon"><i class="fas ${point.icon}"></i></div><div class="ai-insight-content"><strong>${point.title}</strong><span>${point.text}</span></div></li>`;
          }).join('');
        } else {
          listEl.innerHTML = '<li class="ai-insight-item"><div class="ai-icon"><i class="fas fa-info-circle"></i></div><div class="ai-insight-content"><strong>No trend data yet</strong><span>Capture a few periods of QA to unlock longitudinal intelligence.</span></div></li>';
        }

        if (forecastEl) {
          if (analysis.forecast && (analysis.forecast.avg || analysis.forecast.pass)) {
            forecastEl.innerHTML = `
              <span><i class="fas fa-forward"></i>${analysis.nextLabel}: ${analysis.forecast.avg}% avg</span>
              <span><i class="fas fa-shield-alt"></i>${analysis.forecast.pass}% pass</span>
            `;
          } else {
            forecastEl.innerHTML = '';
          }
        }

        if (healthEl) {
          healthEl.textContent = analysis.health === 'improving' ? 'Improving' : analysis.health === 'risk' ? 'At Risk' : analysis.health === 'monitoring' ? 'Monitoring' : 'Stable';
          healthEl.classList.remove('improving', 'risk');
          if (analysis.health === 'improving') {
            healthEl.classList.add('improving');
          } else if (analysis.health === 'risk') {
            healthEl.classList.add('risk');
          }
        }

        renderTrendSparkline(series, granularity);
      }

      function formatPeriodLabel(granularity, period) {
        if (!period) return 'Period';
        switch (granularity) {
          case 'Week':
            return period.replace(/^[0-9]{4}-/, '');
          case 'Month': {
            const [y, m] = period.split('-');
            const date = new Date(Number(y), Number(m) - 1, 1);
            return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
          }
          case 'Quarter':
            return period.replace('-', ' ');
          case 'Year':
            return period;
          default:
            return period;
        }
      }

      function filterRecordsByPeriod(data, granularity, periodValue) {
        if (!periodValue) return [];
        return data.filter(record => {
          const dt = record.callDateObj;
          if (!dt) return false;
          try {
            switch (granularity) {
              case 'Week':
                return toISOWeek(dt) === periodValue;
              case 'Month':
                return dt.toISOString().slice(0, 7) === periodValue;
              case 'Quarter':
                return `${getQuarter(dt)}-${dt.getFullYear()}` === periodValue;
              case 'Year':
                return String(dt.getFullYear()) === periodValue;
              default:
                return true;
            }
          } catch (err) {
            console.warn('filterRecordsByPeriod error', record, err);
            return false;
          }
        });
      }

      function buildTrendSeries(granularity, currentPeriod, data, depth = 4) {
        const series = [];
        let cursor = currentPeriod;
        let steps = 0;
        const visited = new Set();

        while (cursor && steps < depth && !visited.has(cursor)) {
          visited.add(cursor);
          const bucket = filterRecordsByPeriod(data, granularity, cursor);
          const evalCount = bucket.length;
          const agentCount = new Set(bucket.map(r => r.AgentName)).size;
          const avgScore = evalCount ? Math.round(bucket.reduce((sum, r) => sum + (r.Percentage || 0), 0) / evalCount * 100) : 0;
          const passRate = safePercentage(bucket.filter(r => r.Percentage >= PASS_MARK).length, evalCount);
          const coverage = userList.length ? safePercentage(agentCount, userList.length) : (agentCount > 0 ? 100 : 0);

          series.push({
            period: cursor,
            label: formatPeriodLabel(granularity, cursor),
            avgScore,
            passRate,
            evalCount,
            agentCount,
            coverage
          });

          cursor = getPreviousPeriod(granularity, cursor);
          steps += 1;
        }

        return series.reverse();
      }

      function linearRegression(points) {
        if (!points || !points.length) {
          return { slope: 0, intercept: 0 };
        }

        if (points.length === 1) {
          return { slope: 0, intercept: points[0].y };
        }

        const n = points.length;
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumXX = 0;

        points.forEach(point => {
          sumX += point.x;
          sumY += point.y;
          sumXY += point.x * point.y;
          sumXX += point.x * point.x;
        });

        const denominator = (n * sumXX) - (sumX * sumX);
        if (denominator === 0) {
          return { slope: 0, intercept: sumY / n };
        }

        const slope = ((n * sumXY) - (sumX * sumY)) / denominator;
        const intercept = (sumY - slope * sumX) / n;
        return { slope, intercept };
      }

      function clampPercent(value) {
        if (Number.isNaN(value)) return 0;
        return Math.max(0, Math.min(100, Math.round(value)));
      }

      function analyzeTrendSeries(series, context = {}) {
        const { granularity = 'Period' } = context;
        const lowerGran = granularity.toLowerCase();

        if (!series || !series.length) {
          return {
            summary: `Lumina AI is waiting for enough history to analyze ${lowerGran} trends.`,
            points: [],
            health: 'monitoring',
            forecast: { avg: 0, pass: 0 },
            nextLabel: `next ${lowerGran}`
          };
        }

        const first = series[0];
        const last = series[series.length - 1];

        const avgPoints = series.map((point, index) => ({ x: index, y: point.avgScore }));
        const passPoints = series.map((point, index) => ({ x: index, y: point.passRate }));
        const avgReg = linearRegression(avgPoints);
        const passReg = linearRegression(passPoints);

        const avgDelta = last.avgScore - first.avgScore;
        const passDelta = last.passRate - first.passRate;
        const volumeDelta = last.evalCount - first.evalCount;

        const slopeAvg = avgReg.slope;
        const slopePass = passReg.slope;

        const improving = slopeAvg > 0.5 || slopePass > 0.5;
        const declining = slopeAvg < -0.5 || slopePass < -0.5;

        let health = 'stable';
        if (improving) health = 'improving';
        if (declining) health = 'risk';

        const summaryParts = [];
        summaryParts.push(`Average quality is ${avgDelta >= 0 ? 'up' : 'down'} ${Math.abs(avgDelta).toFixed(1)} pts`);
        summaryParts.push(`pass rate ${passDelta >= 0 ? 'gained' : 'slid'} ${Math.abs(passDelta).toFixed(1)} pts`);
        summaryParts.push(`${last.evalCount} evaluations this ${lowerGran}`);

        const points = [];

        points.push({
          icon: improving ? 'fa-arrow-up' : declining ? 'fa-arrow-down' : 'fa-arrows-alt-h',
          tone: improving ? 'positive' : declining ? 'negative' : '',
          title: `Average score ${improving ? 'rising' : declining ? 'dropping' : 'steady'}`,
          text: `${first.avgScore}% → ${last.avgScore}% across the last ${series.length} ${series.length === 1 ? lowerGran : lowerGran + 's'}.`
        });

        points.push({
          icon: passDelta >= 0 ? 'fa-shield-alt' : 'fa-exclamation-triangle',
          tone: passDelta >= 0 ? 'positive' : 'negative',
          title: `Pass rate ${passDelta >= 0 ? 'improving' : 'at risk'}`,
          text: `${first.passRate}% → ${last.passRate}% (${passDelta >= 0 ? '+' : ''}${passDelta.toFixed(1)} pts).`
        });

        if (Math.abs(volumeDelta) > 0) {
          points.push({
            icon: volumeDelta >= 0 ? 'fa-users' : 'fa-user-slash',
            tone: volumeDelta >= 0 ? 'positive' : 'negative',
            title: `Evaluation volume ${volumeDelta >= 0 ? 'growing' : 'contracting'}`,
            text: `${first.evalCount} → ${last.evalCount} evaluations (${volumeDelta >= 0 ? '+' : ''}${volumeDelta}).`
          });
        } else {
          points.push({
            icon: 'fa-stopwatch',
            tone: '',
            title: 'Volume steady',
            text: `Evaluation count steady at ${last.evalCount} per ${lowerGran}.`
          });
        }

        if (last.coverage < 80) {
          points.push({
            icon: 'fa-user-shield',
            tone: 'negative',
            title: 'Coverage gap detected',
            text: `Only ${last.coverage}% of agents covered in the latest ${lowerGran}.`
          });
        }

        const avgForecast = clampPercent(avgReg.intercept + avgReg.slope * avgPoints.length);
        const passForecast = clampPercent(passReg.intercept + passReg.slope * passPoints.length);

        const summary = `${summaryParts.join(', ')}.`;

        return {
          summary,
          points,
          health,
          forecast: { avg: avgForecast, pass: passForecast },
          nextLabel: `next ${lowerGran}`
        };
      }

      function renderTrendSparkline(series, granularity) {
        const visual = document.getElementById('aiTrendVisual');
        const canvas = document.getElementById('aiTrendSparkline');

        if (!visual || !canvas) {
          return;
        }

        if (!series || !series.length) {
          visual.style.display = 'none';
          if (trendSparklineChart) {
            trendSparklineChart.destroy();
            trendSparklineChart = null;
          }
          return;
        }

        visual.style.display = '';

        if (trendSparklineChart) {
          trendSparklineChart.destroy();
          trendSparklineChart = null;
        }

        const labels = series.map(point => point.label || formatPeriodLabel(granularity, point.period));
        const avgData = series.map(point => point.avgScore);
        const passData = series.map(point => point.passRate);

        trendSparklineChart = new Chart(canvas, {
          type: 'line',
          data: {
            labels,
            datasets: [
              {
                label: 'Avg Score',
                data: avgData,
                borderColor: '#6366f1',
                backgroundColor: 'rgba(99,102,241,0.15)',
                tension: 0.4,
                pointRadius: 4,
                pointBackgroundColor: '#6366f1',
                fill: true
              },
              {
                label: 'Pass Rate',
                data: passData,
                borderColor: '#10b981',
                backgroundColor: 'rgba(16,185,129,0.12)',
                tension: 0.4,
                pointRadius: 4,
                pointBackgroundColor: '#10b981',
                fill: true
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                labels: {
                  usePointStyle: true,
                  font: {
                    family: "'Google Sans', sans-serif",
                    size: 11
                  }
                }
              },
              tooltip: {
                backgroundColor: 'rgba(15,23,42,0.9)',
                titleColor: '#fff',
                bodyColor: '#e2e8f0',
                cornerRadius: 10,
                padding: 10
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                grid: { color: 'rgba(15,23,42,0.05)' },
                ticks: { font: { family: "'Google Sans', sans-serif" } }
              },
              x: {
                grid: { display: false },
                ticks: { font: { family: "'Google Sans', sans-serif" } }
              }
            }
          }
        });
      }

      function updateAITrendPanel({ series, granularity }, analysisOverride = null) {
        const summaryEl = document.getElementById('aiTrendSummary');
        const listEl = document.getElementById('aiTrendList');
        const forecastEl = document.getElementById('aiTrendForecast');
        const healthEl = document.getElementById('aiTrendHealth');

        if (!summaryEl || !listEl) {
          return;
        }

        const analysis = analysisOverride || analyzeTrendSeries(series, { granularity });

        summaryEl.textContent = analysis.summary;
        listEl.innerHTML = '';

        if (analysis.points.length) {
          listEl.innerHTML = analysis.points.map(point => {
            const tone = point.tone ? ` ${point.tone}` : '';
            return `<li class="ai-insight-item${tone}"><div class="ai-icon"><i class="fas ${point.icon}"></i></div><div class="ai-insight-content"><strong>${point.title}</strong><span>${point.text}</span></div></li>`;
          }).join('');
        } else {
          listEl.innerHTML = '<li class="ai-insight-item"><div class="ai-icon"><i class="fas fa-info-circle"></i></div><div class="ai-insight-content"><strong>No trend data yet</strong><span>Capture a few periods of QA to unlock longitudinal intelligence.</span></div></li>';
        }

        if (forecastEl) {
          if (analysis.forecast && (analysis.forecast.avg || analysis.forecast.pass)) {
            forecastEl.innerHTML = `
              <span><i class="fas fa-forward"></i>${analysis.nextLabel}: ${analysis.forecast.avg}% avg</span>
              <span><i class="fas fa-shield-alt"></i>${analysis.forecast.pass}% pass</span>
            `;
          } else {
            forecastEl.innerHTML = '';
          }
        }

        if (healthEl) {
          healthEl.textContent = analysis.health === 'improving' ? 'Improving' : analysis.health === 'risk' ? 'At Risk' : analysis.health === 'monitoring' ? 'Monitoring' : 'Stable';
          healthEl.classList.remove('improving', 'risk');
          if (analysis.health === 'improving') {
            healthEl.classList.add('improving');
          } else if (analysis.health === 'risk') {
            healthEl.classList.add('risk');
          }
        }

        renderTrendSparkline(series, granularity);
      }

      // CHANGED: uses PASS_SCORE_THRESHOLD / no undefined class access
      function renderCategoryTable(metrics){
        const tbody=document.querySelector('#categoryTable tbody'); tbody.innerHTML='';
        Object.entries(metrics).forEach(([cat,m])=>{
          const passScore=PASS_SCORE_THRESHOLD;
          const goodScore=Math.round(passScore*0.8);
          const avgClass = m.avgScore>=passScore ? 'excellent' : m.avgScore>=goodScore ? 'good':'needs-improvement';
          const passClass= m.passPct >=passScore ? 'excellent' : m.passPct >=goodScore ? 'good':'needs-improvement';
          const row=document.createElement('tr');
          row.innerHTML=`
            <td><strong>${cat}</strong></td>
            <td><span class="status-badge ${avgClass}"><span class="badge-dot"></span>${m.avgScore}%</span></td>
            <td><span class="status-badge ${passClass}"><span class="badge-dot"></span>${m.passPct}%</span></td>`;
          tbody.appendChild(row);
        });
      }

      function renderCategoryChart(metrics){
        const labels=Object.keys(metrics);
        const data=labels.map(l=>metrics[l].avgScore);
        if(categoryChart){ categoryChart.destroy(); categoryChart=null; }
        const ctx=document.getElementById('categoryChart'); if(!ctx) return;
        categoryChart=new Chart(ctx,{type:'bar',data:{labels,datasets:[{label:'Average Score %',data,backgroundColor:'rgba(102,126,234,.1)',borderColor:'#667eea',borderWidth:2,borderRadius:8,borderSkipped:false}]},options:{...chartConfig,plugins:{...chartConfig.plugins,legend:{display:false}}}});
      }

      // CHANGED: weekday-only + correct thresholds
      function renderDailyChart(data) {
          const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
          const cnt = {}, sums = {}, ps = {};
          days.forEach(d => { cnt[d] = 0; sums[d] = 0; ps[d] = 0; });
          
          data.forEach(r => {
              // Use the cleaned date object
              const dt = r.callDateObj || safeToDate(r.CallDate);
              if (!dt) {
                  console.warn('Skipping record with invalid date in renderDailyChart:', r);
                  return;
              }
              
              const idx = (dt.getDay() + 6) % 7; 
              if (idx > 4) return; // skip Sat/Sun
              
              const day = days[idx];
              cnt[day]++; 
              sums[day] += r.recordScore;
              if (r.recordScore >= PASS_SCORE_THRESHOLD) ps[day]++;
          });
          
          const tot = data.length;
          const evalPct = days.map(d => tot ? Math.round(cnt[d] / tot * 100) : 0);
          const avgData = days.map(d => cnt[d] ? Math.round(sums[d] / cnt[d]) : 0);
          const passPct = days.map(d => cnt[d] ? Math.round(ps[d] / cnt[d] * 100) : 0);

          if (dailyChart) { dailyChart.destroy(); dailyChart = null; }
          const ctx = document.getElementById('dailyChart'); 
          if (!ctx) return;
          
          dailyChart = new Chart(ctx, {
              data: {
                  labels: days, 
                  datasets: [
                      { type: 'bar', label: 'Evaluations %', data: evalPct, backgroundColor: 'rgba(102,126,234,.1)', borderColor: '#667eea', borderWidth: 2, borderRadius: 6 },
                      { type: 'line', label: 'Average Score', data: avgData, yAxisID: 'y1', tension: .4, borderColor: '#10b981', backgroundColor: 'rgba(16,185,129,.1)', pointBackgroundColor: '#10b981', pointBorderColor: '#fff', pointBorderWidth: 2, pointRadius: 5 },
                      { type: 'line', label: 'Pass Rate', data: passPct, yAxisID: 'y1', tension: .4, borderColor: '#f59e0b', backgroundColor: 'rgba(245,158,11,.1)', pointBackgroundColor: '#f59e0b', pointBorderColor: '#fff', pointBorderWidth: 2, pointRadius: 5 }
                  ]
              },
              options: { ...chartConfig, scales: { y: chartConfig.scales.y, y1: { ...chartConfig.scales.y, position: 'right', grid: { drawOnChartArea: false } }, x: chartConfig.scales.x } }
          });
      }

      function renderAgentTable(data) {
          const tbody = document.querySelector('#agentTable tbody');
          if (!tbody) return;
          tbody.innerHTML = '';

          const { profiles } = calculateAgentProfiles(data);

          profiles.forEach(profile => {
              const recentDateFormatted = profile.recentDate ? profile.recentDate.toLocaleDateString() : 'N/A';
              const row = document.createElement('tr');
              row.innerHTML = `
                  <td><strong>${profile.name}</strong></td>
                  <td>${profile.evaluationShare}%</td>
                  <td><span class="status-badge ${profile.avgScore >= 95 ? 'excellent' : profile.avgScore >= 80 ? 'good' : 'needs-improvement'}"><span class="badge-dot"></span>${profile.avgScore}%</span></td>
                  <td><span class="status-badge ${profile.passRate >= 95 ? 'excellent' : profile.passRate >= 80 ? 'good' : 'needs-improvement'}"><span class="badge-dot"></span>${profile.passRate}%</span></td>
                  <td>${recentDateFormatted}</td>`;
              tbody.appendChild(row);
          });
      }

      function debugInvalidDates() {
          console.log('=== QA Data Date Debug ===');
          let invalidCount = 0;

          rawQA.forEach((record, index) => {
              if (!(record.callDateObj instanceof Date) || isNaN(record.callDateObj.getTime())) {
                  console.log(`Invalid date at index ${index}:`, {
                      CallDate: record.CallDate,
                      CallDateSource: getRecordField(record, ['CallDate', 'Call Date', 'CallTime', 'Call Time', 'EvaluationDate', 'Evaluation Date', 'QA Date', 'Date', 'Timestamp']),
                      AgentName: record.AgentName,
                      RecordIndex: record.__recordIndex,
                      record: record
                  });
                  invalidCount++;
              }
          });

          console.log(`Found ${invalidCount} records with invalid dates out of ${rawQA.length} total records`);
          return invalidCount;
      }

      function renderAgentChart(data){
        const { profiles } = calculateAgentProfiles(data);
        const agents = profiles.map(p => p.name);
        const evalPct = profiles.map(p => p.evaluationShare);
        const avgScore = profiles.map(p => p.avgScore);
        const passPct = profiles.map(p => p.passRate);

        if(agentChart){ agentChart.destroy(); agentChart=null; }
        const ctx=document.getElementById('agentChart'); if(!ctx) return;
        agentChart=new Chart(ctx,{type:'bar',data:{labels:agents,datasets:[
          {label:'Evaluations %',data:evalPct,backgroundColor:'rgba(102,126,234,.1)',borderColor:'#667eea',borderWidth:2,borderRadius:6},
          {label:'Average Score',data:avgScore,backgroundColor:'rgba(16,185,129,.1)',borderColor:'#10b981',borderWidth:2,borderRadius:6},
          {label:'Pass Rate',data:passPct,backgroundColor:'rgba(245,158,11,.1)',borderColor:'#f59e0b',borderWidth:2,borderRadius:6}]},
          options:chartConfig});
      }

      function renderCategoryKpis(metrics){
        const container=document.getElementById('categoryKpis'); container.innerHTML='';
        Object.entries(metrics).forEach(([cat,m])=>{
          const card=document.createElement('div'); card.className='category-kpi-card';
          card.innerHTML=`<h6>${cat}</h6>
            <div class="category-metrics">
              <div class="category-metric"><div class="value">${m.avgScore}%</div><div class="label">Avg Score</div></div>
              <div class="category-metric"><div class="value">${m.passPct}%</div><div class="label">Pass Rate</div></div>
            </div>`;
          container.appendChild(card);
        });
      }

      const chartConfig={responsive:true,maintainAspectRatio:false,interaction:{intersect:false,mode:'index'},plugins:{legend:{labels:{usePointStyle:true,padding:20,font:{family:"'Google Sans', sans-serif",size:12,weight:'500'}}},tooltip:{backgroundColor:'rgba(0,0,0,.8)',titleColor:'#fff',bodyColor:'#fff',borderColor:'#667eea',borderWidth:1,cornerRadius:8,padding:12}},scales:{y:{beginAtZero:true,max:100,grid:{color:'rgba(0,0,0,.05)'},ticks:{font:{family:"'Google Sans', sans-serif"}}},x:{grid:{display:false},ticks:{font:{family:"'Google Sans', sans-serif"}}}},layout:{padding:{top:10,bottom:10}}};

      function safePercentage(numerator, denominator, maxCap = 100, debugLabel = '') {
        if (debugLabel) {
          console.log(`${debugLabel}: ${numerator}/${denominator}`);
        }
        if (!denominator || denominator <= 0) return 0;
        const result = Math.round((numerator / denominator) * 100);
        return Math.min(result, maxCap);
      }

      function calculateAgentProfiles(data) {
          const totalEvaluations = data.length;
          const aggregates = {};

          data.forEach(record => {
              const agentName = record.AgentName || 'Unassigned';
              if (!aggregates[agentName]) {
                  aggregates[agentName] = {
                      count: 0,
                      scoreSum: 0,
                      passCount: 0,
                      recent: null
                  };
              }

              const bucket = aggregates[agentName];
              bucket.count += 1;
              bucket.scoreSum += record.recordScore || 0;
              if (record.Percentage >= PASS_MARK) {
                  bucket.passCount += 1;
              }

              const callDate = safeToDate(record.CallDate);
              if (callDate) {
                  if (!bucket.recent || callDate > bucket.recent) {
                      bucket.recent = callDate;
                  }
              }
          });

          const profiles = Object.entries(aggregates).map(([name, stats]) => {
              const avgScore = stats.count ? Math.round(stats.scoreSum / stats.count) : 0;
              const passRate = stats.count ? Math.round(stats.passCount / stats.count * 100) : 0;
              const evaluationShare = totalEvaluations ? Math.round(stats.count / totalEvaluations * 100) : 0;

              return {
                  name,
                  evaluations: stats.count,
                  avgScore,
                  passRate,
                  evaluationShare,
                  recentDate: stats.recent || null
              };
          }).sort((a, b) => b.avgScore - a.avgScore);

          return { totalEvaluations, profiles };
      }

      function summarizeCategoryChange(currentMetrics, previousMetrics = {}) {
          const details = Object.entries(currentMetrics).map(([category, metrics]) => {
              const prev = previousMetrics[category];
              const delta = prev ? Math.round((metrics.avgScore - prev.avgScore) * 10) / 10 : null;
              return {
                  category,
                  avgScore: metrics.avgScore,
                  passPct: metrics.passPct,
                  delta
              };
          });

          details.sort((a, b) => b.avgScore - a.avgScore);
          return details;
      }

      function buildAIIntelligenceAnalysis({ filtered, prevFiltered, catMetrics, prevCatMetrics, kpis }) {
          const { totalEvaluations, profiles } = calculateAgentProfiles(filtered || []);
          const { profiles: prevProfiles } = calculateAgentProfiles(prevFiltered || []);
          const categorySummary = summarizeCategoryChange(catMetrics || {}, prevCatMetrics || {});

          const metrics = kpis || {};
          const avgScore = Math.round(Math.min(metrics.avg ?? 0, 100));
          const passRate = Math.round(Math.min(metrics.pass ?? 0, 100));
          const coverage = Math.round(Math.min(metrics.coverage ?? 0, 100));
          const completion = Math.round(Math.min(metrics.completion ?? 0, 100));
          const confidenceScore = Math.max(5, Math.min(100, Math.round((coverage * 0.4) + (passRate * 0.3) + (avgScore * 0.3))));

          const base = {
              summary: '',
              automationSummary: '',
              confidence: confidenceScore,
              automationState: 'Monitoring',
              insights: [],
              actions: [],
              nextBest: null,
              meta: {
                  totalEvaluations,
                  totalAgents: profiles.length,
                  periodLabel: currentGran ? currentGran.toLowerCase() : 'period',
                  source: 'local',
                  generatedAt: new Date().toISOString(),
                  cache: 'miss'
              }
          };

          if (!totalEvaluations) {
              base.summary = 'Lumina AI is monitoring for new evaluations. Adjust your filters or capture fresh QA reviews to generate insights.';
              base.automationSummary = 'No automation required yet. Log additional evaluations to unlock targeted recommendations.';
              return base;
          }

          const totalAgents = profiles.length;
          const evaluationsWord = totalEvaluations === 1 ? 'evaluation' : 'evaluations';
          const agentWord = totalAgents === 1 ? 'agent' : 'agents';
          const periodLabel = base.meta.periodLabel;

          base.summary = `AI reviewed ${totalEvaluations} ${evaluationsWord} across ${totalAgents} ${agentWord} for this ${periodLabel}, spotlighting performance opportunities instantly.`;
          base.automationSummary = `Coverage at ${coverage}% and completion at ${completion}% give AI enough signal to trigger proactive workflows.`;

          if (profiles.length) {
              const topAgent = profiles[0];
              base.insights.push({
                  icon: 'fa-star',
                  tone: 'positive',
                  title: `${topAgent.name} is leading`,
                  text: `${topAgent.name} is averaging ${topAgent.avgScore}% quality with a ${topAgent.passRate}% pass rate.`
              });

              const bottomAgent = profiles[profiles.length - 1];
              if (bottomAgent && bottomAgent.avgScore < PASS_SCORE_THRESHOLD) {
                  base.insights.push({
                      icon: 'fa-life-ring',
                      tone: 'negative',
                      title: `${bottomAgent.name} needs attention`,
                      text: `${bottomAgent.name} is trending at ${bottomAgent.avgScore}% with ${bottomAgent.passRate}% pass rate.`
                  });
                  base.actions.push({
                      icon: 'fa-user-graduate',
                      tone: 'urgent',
                      title: `Launch coaching for ${bottomAgent.name}`,
                      text: `Auto-create a coaching session to lift ${bottomAgent.name}'s quality score back above ${PASS_SCORE_THRESHOLD}%.`
                  });
              }

              const prevProfileMap = Object.fromEntries(prevProfiles.map(p => [p.name, p]));
              let strongestImprovement = null;
              let largestRegression = null;

              profiles.forEach(profile => {
                  const prev = prevProfileMap[profile.name];
                  if (!prev) return;
                  const delta = profile.avgScore - prev.avgScore;
                  if (strongestImprovement === null || delta > strongestImprovement.delta) {
                      strongestImprovement = { ...profile, delta };
                  }
                  if (largestRegression === null || delta < largestRegression.delta) {
                      largestRegression = { ...profile, delta };
                  }
              });

              if (strongestImprovement && strongestImprovement.delta > 2) {
                  base.insights.push({
                      icon: 'fa-rocket',
                      tone: 'positive',
                      title: `${strongestImprovement.name} is improving`,
                      text: `Up ${strongestImprovement.delta.toFixed(1)} pts vs last period.`
                  });
              }

              if (largestRegression && largestRegression.delta < -2) {
                  base.actions.push({
                      icon: 'fa-reply',
                      tone: 'urgent',
                      title: `Check-in with ${largestRegression.name}`,
                      text: `${largestRegression.name} dropped ${Math.abs(largestRegression.delta).toFixed(1)} pts period-over-period.`
                  });
              }
          }

          if (categorySummary.length) {
              const bestCategory = categorySummary[0];
              base.insights.push({
                  icon: 'fa-thumbs-up',
                  tone: 'positive',
                  title: `${bestCategory.category} excels`,
                  text: `${bestCategory.category} is averaging ${bestCategory.avgScore}% quality.`
              });

              const weakestCategory = categorySummary[categorySummary.length - 1];
              if (weakestCategory && weakestCategory.avgScore < PASS_SCORE_THRESHOLD) {
                  base.actions.push({
                      icon: 'fa-sitemap',
                      tone: 'urgent',
                      title: `Reinforce ${weakestCategory.category}`,
                      text: `Automate a calibration focused on ${weakestCategory.category} where scores average ${weakestCategory.avgScore}%.`
                  });
              }

              const largestDelta = categorySummary.reduce((acc, entry) => {
                  if (entry.delta === null) return acc;
                  if (!acc || entry.delta < acc.delta) return entry;
                  return acc;
              }, null);

              if (largestDelta && largestDelta.delta < -3) {
                  base.actions.push({
                      icon: 'fa-exclamation-circle',
                      tone: 'urgent',
                      title: `Reverse slide in ${largestDelta.category}`,
                      text: `${largestDelta.category} fell ${Math.abs(largestDelta.delta).toFixed(1)} pts from the previous period.`
                  });
              }
          }

          if (passRate < 90) {
              base.actions.push({
                  icon: 'fa-headset',
                  tone: 'urgent',
                  title: 'Boost pass rate',
                  text: `Configure an automated refresher for agents with pass rates below 90%. Current pass rate is ${passRate}%.`
              });
          }

          if (coverage < 85) {
              base.actions.push({
                  icon: 'fa-user-check',
                  tone: 'urgent',
                  title: 'Increase agent coverage',
                  text: `Auto-assign additional evaluations to reach at least 90% agent coverage. Currently at ${coverage}%.`
              });
          }

          if (!base.insights.length) {
              base.insights.push({
                  icon: 'fa-lightbulb',
                  tone: 'positive',
                  title: 'All clear',
                  text: 'No critical anomalies detected. AI will notify if trends change.'
              });
          }

          base.automationState = base.actions.length ? 'Action Required' : 'Monitoring';
          base.nextBest = base.actions.length ? base.actions[0] : null;
          return base;
      }

      function renderAIIntelligence(analysis) {
          const summaryEl = document.getElementById('aiInsightsSummary');
          const automationSummaryEl = document.getElementById('aiAutomationSummary');
          const confidenceEl = document.getElementById('aiConfidenceBadge');
          const sourceEl = document.getElementById('aiInsightSource');
          const automationStateEl = document.getElementById('aiAutomationState');
          const nextBestWrapper = document.getElementById('aiNextBestAction');
          const nextBestText = document.getElementById('aiNextBestActionText');
          const insightsList = document.getElementById('aiInsightsList');
          const recommendationsList = document.getElementById('aiRecommendationsList');

          if (!insightsList || !recommendationsList) {
              return;
          }

          const {
              summary = '',
              automationSummary = '',
              confidence = null,
              automationState = 'Monitoring',
              insights = [],
              actions = [],
              nextBest = null
          } = analysis || {};

          if (confidenceEl && confidence !== null) {
              confidenceEl.textContent = `Confidence ${Math.round(confidence)}%`;
          }

          if (sourceEl) {
              const meta = analysis && analysis.meta ? analysis.meta : {};
              const source = (meta.source || 'local').toLowerCase();
              sourceEl.classList.remove('server', 'client');

              let label = 'Local AI';
              const tooltipParts = [];
              if (source === 'server') {
                  label = 'QA Service';
                  sourceEl.classList.add('server');
                  tooltipParts.push('Intelligence generated by the QA service');
              } else {
                  sourceEl.classList.add('client');
                  tooltipParts.push('Intelligence generated in-browser');
              }

              sourceEl.textContent = label;

              if (meta.generatedAt) {
                  try {
                      const generated = new Date(meta.generatedAt);
                      if (!Number.isNaN(generated.getTime())) {
                          tooltipParts.push(generated.toLocaleString());
                      }
                  } catch (dateError) {
                      console.warn('Unable to format AI intelligence timestamp:', dateError);
                  }
              }

              if (meta.cache === 'hit') {
                  tooltipParts.push('Served from cache');
              } else if (meta.cache === 'miss') {
                  tooltipParts.push('Fresh analysis');
              }

              sourceEl.title = tooltipParts.join(' • ');
          }

          if (summaryEl) {
              summaryEl.textContent = summary || 'Lumina AI is processing your QA signals.';
          }

          if (automationSummaryEl) {
              automationSummaryEl.textContent = automationSummary || 'AI recommendations will populate after analysis.';
          }

          insightsList.innerHTML = insights.length
              ? insights.map(item => {
                  const toneClass = item.tone ? ` ${item.tone}` : '';
                  return `<li class="ai-insight-item${toneClass}"><div class="ai-icon"><i class="fas ${item.icon}"></i></div><div class="ai-insight-content"><strong>${item.title}</strong><span>${item.text}</span></div></li>`;
              }).join('')
              : '<li class="ai-insight-item"><div class="ai-icon"><i class="fas fa-info-circle"></i></div><div class="ai-insight-content"><strong>Insights pending</strong><span>Collect more QA evaluations to surface intelligence.</span></div></li>';

          if (actions.length) {
              recommendationsList.innerHTML = actions.map(action => {
                  const toneClass = action.tone === 'urgent' ? ' urgent' : '';
                  return `<li class="ai-action-item${toneClass}"><div class="ai-icon"><i class="fas ${action.icon}"></i></div><div class="ai-action-content"><strong>${action.title}</strong><span>${action.text}</span></div></li>`;
              }).join('');
          } else {
              recommendationsList.innerHTML = `<li class="ai-action-item"><div class="ai-icon"><i class="fas fa-shield-alt"></i></div><div class="ai-action-content"><strong>Automations standing by</strong><span>All monitored metrics are stable. Lumina AI will trigger playbooks if trends shift.</span></div></li>`;
          }

          if (automationStateEl) {
              automationStateEl.textContent = automationState;
              if (automationState === 'Action Required') {
                  automationStateEl.classList.add('active');
              } else {
                  automationStateEl.classList.remove('active');
              }
          }

          if (nextBestWrapper) {
              if (nextBest && nextBestText) {
                  nextBestWrapper.style.display = '';
                  nextBestText.textContent = nextBest.text || '';
              } else {
                  nextBestWrapper.style.display = 'none';
                  if (nextBestText) {
                      nextBestText.textContent = '';
                  }
              }
          }
      }

      function updateAIIntelligencePanel(context, analysisOverride = null) {
          if (analysisOverride) {
              renderAIIntelligence(analysisOverride);
              return;
          }

          if (!context) {
              return;
          }

          const analysis = buildAIIntelligenceAnalysis(context);
          renderAIIntelligence(analysis);
      }

      function fetchServerQAIntelligence(context = {}, requestToken = null) {
          if (!context) {
              return Promise.resolve({ token: requestToken, result: null });
          }

          if (!(window.google && google.script && google.script.run)) {
              return Promise.resolve({ token: requestToken, result: null });
          }

          return new Promise(resolve => {
              try {
                  google.script.run
                      .withSuccessHandler(result => resolve({ token: requestToken, result: result || null }))
                      .withFailureHandler(error => {
                          console.warn('clientGetQAIntelligence failed:', error);
                          resolve({ token: requestToken, result: null });
                      })
                      .clientGetQAIntelligence(context);
              } catch (error) {
                  console.warn('Unable to request QA intelligence from service:', error);
                  resolve({ token: requestToken, result: null });
              }
          });
      }

      function applyFilters(){
          showLoader('Preparing filtered results…');
          setTimeout(()=>{
              // STEP 1: Clean and validate the raw QA data first
              const cleanedQA = rawQA.filter(r => {
                  const valid = r.callDateObj instanceof Date && !isNaN(r.callDateObj.getTime());
                  if (!valid) {
                      console.warn('Invalid CallDate found in record:', r);
                  }
                  return valid;
              });

              // STEP 2: Calculate scores safely
              const scored = cleanedQA.map(r => {
                  let s = 0; 
                  Object.entries(weightsMap).forEach(([q, w]) => { 
                      if ((r[q] || '').toString().toLowerCase() === 'yes') s += w; 
                  });
                  return { ...r, recordScore: s };
              });

              // STEP 3: Apply period and agent filters safely
              const filtered = scored.filter(r => {
                  // Agent filter
                  if (currentAgent && r.AgentName !== currentAgent) return false;
                  
                  // Use the cleaned Date object for period filtering
                  const dt = r.callDateObj;
                  
                  try {
                      switch (currentGran) {
                          case 'Week': 
                              return toISOWeek(dt) === currentPeriod;
                          case 'Month': 
                              return dt.toISOString().slice(0, 7) === currentPeriod;
                          case 'Quarter': 
                              return `${getQuarter(dt)}-${dt.getFullYear()}` === currentPeriod;
                          case 'Year': 
                              return String(dt.getFullYear()) === currentPeriod;
                          default: 
                              return true;
                      }
                  } catch (error) {
                      console.warn('Error filtering record by period:', r, error);
                      return false; // Exclude problematic records
                  }
              });

              lastFilteredData = filtered;

              const tot = filtered.length;
              const agentsInPeriod = new Set(filtered.map(r => r.AgentName)).size;
              const uniqueAgentsInData = Array.from(new Set(filtered.map(r => r.AgentName)));

              console.log('=== Agents Evaluated Debug ===');
              console.log('Total evaluations:', tot);
              console.log('Agents in current period:', agentsInPeriod);
              console.log('Agent names in period:', uniqueAgentsInData);
              console.log('userList length:', userList.length);
              console.log('userList:', userList);

              // Calculate KPIs with enhanced Agents Evaluated logic
              const avgPct = tot ? Math.round(filtered.reduce((s, r) => s + (r.Percentage || 0), 0) / tot * 100) : 0;
              const passPct = safePercentage(filtered.filter(r => r.Percentage >= PASS_MARK).length, tot);
              
              // Agents Evaluated: percentage of total agents that have evaluations
              let agentsEvalPct = 0;
              if (userList.length > 0) {
                  // Primary method: percentage of known agents that have evaluations
                  agentsEvalPct = safePercentage(agentsInPeriod, userList.length, 100, 'Agents Evaluated (primary)');
              } else {
                  // Fallback method: if userList is empty, use a different approach
                  // Get all unique agents from the entire QA dataset as the universe
                  const allAgentsInQA = new Set(rawQA.map(r => r.AgentName).filter(Boolean)).size;
                  if (allAgentsInQA > 0) {
                      agentsEvalPct = safePercentage(agentsInPeriod, allAgentsInQA, 100, 'Agents Evaluated (fallback)');
                      console.log('Using fallback: agents in period vs all agents in QA data');
                  } else {
                      // Last resort: show 100% if there are any evaluations
                      agentsEvalPct = agentsInPeriod > 0 ? 100 : 0;
                      console.log('Using last resort: 100% if any evaluations exist');
                  }
              }
              
              // Evaluations Completed: average evaluations per agent (capped at 100%)
              const evalsCompletedPct = agentsInPeriod > 0 ? 
                  Math.min(Math.round(tot / agentsInPeriod * 10), 100) : 0;

              console.log('Final agentsEvalPct:', agentsEvalPct);
              console.log('Final evalsCompletedPct:', evalsCompletedPct);

              // Previous period calculations...
              const prevPeriod = getPreviousPeriod(currentGran, currentPeriod);
              const prevFiltered = scored.filter(r => {
                  if (currentAgent && r.AgentName !== currentAgent) return false;
                  
                  const dt = r.callDateObj;
                  
                  try {
                      switch (currentGran) {
                          case 'Week': 
                              return toISOWeek(dt) === prevPeriod;
                          case 'Month': 
                              return dt.toISOString().slice(0, 7) === prevPeriod;
                          case 'Quarter': 
                              return `${getQuarter(dt)}-${dt.getFullYear()}` === prevPeriod;
                          case 'Year': 
                              return String(dt.getFullYear()) === prevPeriod;
                          default: 
                              return false;
                      }
                  } catch (error) {
                      console.warn('Error filtering previous period record:', r, error);
                      return false;
                  }
              });

              const prevTot = prevFiltered.length;
              const prevAgentsInPeriod = new Set(prevFiltered.map(r => r.AgentName)).size;
              
              // Previous period KPIs with same logic
              const prevAvgPct = prevTot ? Math.round(prevFiltered.reduce((s, r) => s + (r.Percentage || 0), 0) / prevTot * 100) : 0;
              const prevPassPct = safePercentage(prevFiltered.filter(r => r.Percentage >= PASS_MARK).length, prevTot);
              
              let prevAgentsEvalPct = 0;
              if (userList.length > 0) {
                  prevAgentsEvalPct = safePercentage(prevAgentsInPeriod, userList.length);
              } else {
                  const allAgentsInQA = new Set(rawQA.map(r => r.AgentName).filter(Boolean)).size;
                  if (allAgentsInQA > 0) {
                      prevAgentsEvalPct = safePercentage(prevAgentsInPeriod, allAgentsInQA);
                  } else {
                      prevAgentsEvalPct = prevAgentsInPeriod > 0 ? 100 : 0;
                  }
              }
              
              const prevEvalsCompletedPct = prevAgentsInPeriod > 0 ? 
                  Math.min(Math.round(prevTot / prevAgentsInPeriod * 10), 100) : 0;

              // Safe change calculation
              const change = (cur, prev) => {
                  if (prev === 0) {
                      return cur === 0 ? 0 : (cur > 0 ? 100 : -100);
                  }
                  const result = Math.round((cur - prev) * 100) / 100;
                  return Math.max(-100, Math.min(100, result));
              };

              // Update KPIs
              [
                  { id: 'kpiAvgScore', trendId: 'kpiAvgScoreTrend', value: Math.min(avgPct, 100), change: change(avgPct, prevAvgPct) },
                  { id: 'kpiPassRate', trendId: 'kpiPassRateTrend', value: passPct, change: change(passPct, prevPassPct) },
                  { id: 'kpiAgentsEval', trendId: 'kpiAgentsEvalTrend', value: agentsEvalPct, change: change(agentsEvalPct, prevAgentsEvalPct) },
                  { id: 'kpiEvalsDone', trendId: 'kpiEvalsDoneTrend', value: evalsCompletedPct, change: change(evalsCompletedPct, prevEvalsCompletedPct) },
              ].forEach(({ id, trendId, value, change }) => {
                  const el = document.getElementById(id), tr = document.getElementById(trendId);
                  if (el && tr) {
                      el.style.transform = 'scale(1.1)'; 
                      el.textContent = Math.min(value, 100) + '%';
                      setTimeout(() => el.style.transform = 'scale(1)', 200);
                      
                      const pos = change >= 0; 
                      const txt = change === 0 ? 'No change' : `${Math.abs(change).toFixed(1)}% vs last period`;
                      tr.className = `kpi-trend ${pos ? 'positive' : 'negative'}`;
                      tr.innerHTML = `<i class="fas ${pos ? 'fa-arrow-up' : 'fa-arrow-down'}"></i><span>${txt}</span>`;
                  }
              });

              // Update charts and tables
              const catMetrics = computeCategoryMetrics(filtered);
              const prevCatMetrics = computeCategoryMetrics(prevFiltered);
              const trendSeries = buildTrendSeries(currentGran, currentPeriod, scored, 5);
              renderCategoryKpis(catMetrics);
              renderCategoryChart(catMetrics);
              renderCategoryTable(catMetrics);
              renderDailyChart(filtered);
              renderAgentChart(filtered);
              renderAgentTable(filtered);

              const currentKpis = {
                  avg: Math.min(avgPct, 100),
                  pass: passPct,
                  coverage: agentsEvalPct,
                  completion: evalsCompletedPct
              };

              updateAIIntelligencePanel({
                  filtered,
                  prevFiltered,
                  catMetrics,
                  prevCatMetrics,
                  kpis: currentKpis
              });

              updateAITrendPanel({
                  series: trendSeries,
                  granularity: currentGran || 'Period'
              });

              const serverContext = {
                  granularity: currentGran || 'Week',
                  period: currentPeriod,
                  agent: currentAgent || '',
                  campaignId: typeof campaignId !== 'undefined' ? campaignId : '',
                  agentUniverse: Array.isArray(userList) ? userList.length : 0,
                  depth: 6,
                  timezone: (function() {
                      try {
                          if (typeof Intl !== 'undefined' && typeof Intl.DateTimeFormat === 'function') {
                              const opts = Intl.DateTimeFormat().resolvedOptions();
                              return opts?.timeZone;
                          }
                      } catch (tzError) {
                          console.warn('Timezone detection failed:', tzError);
                      }
                      return undefined;
                  })(),
                  passMark: PASS_MARK
              };

              if (!serverContext.timezone) {
                  delete serverContext.timezone;
              }

              qaIntelligenceRequestToken += 1;
              const requestToken = qaIntelligenceRequestToken;

              fetchServerQAIntelligence(serverContext, requestToken)
                  .then(payload => {
                      if (!payload || payload.token !== qaIntelligenceRequestToken) {
                          return;
                      }

                      const serverResult = payload.result;
                      if (!serverResult) {
                          return;
                      }

                      if (serverResult.intelligence) {
                          updateAIIntelligencePanel(null, serverResult.intelligence);
                      }

                      if (serverResult.trend) {
                          const serverSeries = Array.isArray(serverResult.trend.series) && serverResult.trend.series.length
                              ? serverResult.trend.series
                              : trendSeries;
                          updateAITrendPanel({
                              series: serverSeries,
                              granularity: serverResult.trend.granularity || currentGran || 'Period'
                          }, serverResult.trend.analysis || null);
                      }
                  })
                  .catch(error => {
                      console.warn('Server QA intelligence unavailable:', error);
                  });

              window.LuminaLoader?.update({ detail: 'Dashboard refreshed!', progress: 100, tip: 'Latest QA metrics are ready.' });
              hideLoader();
          }, 100);
      }

      function convertToCSV(arr){
        if(!arr.length) return '';
        const keys=Object.keys(arr[0]);
        const header=keys.join(',');
        const rows=arr.map(o=> keys.map(k=>{ let c=o[k]!=null?o[k].toString():''; c=c.replace(/"/g,'""'); return `"${c}"`; }).join(',') );
        return [header].concat(rows).join('\r\n');
      }

      function prepareWeeklyMatrix(data){
        const dates=Array.from(new Set(data.map(r=>r.CallDate.slice(0,10)))).sort();
        const agents=Array.from(new Set(data.map(r=>r.AgentName))).sort();
        const rows=agents.map(agent=>{
          const row={AgentName:agent};
          const dayValues=dates.map(d=>{
            const recs=data.filter(r=> r.AgentName===agent && r.CallDate.slice(0,10)===d);
            if(!recs.length) return '';
            const sum=recs.reduce((s,r)=>{ let p=Number(r.Percentage); if(p<=1) p*=100; return s+p; },0);
            return (sum/recs.length).toFixed(2);
          });
          dates.forEach((d,i)=>row[d]=dayValues[i]);
          const nums=dayValues.filter(v=>v!=='').map(Number);
          const weekly=nums.length? (nums.reduce((a,b)=>a+b,0)/nums.length):0;
          row['Weekly Percentage']=weekly.toFixed(2);
          return row;
        });
        return { header:['AgentName',...dates,'Weekly Percentage'], rows };
      }

      function downloadCSV(csv,filename){
        const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
        const link=document.createElement('a'); link.href=URL.createObjectURL(blob); link.setAttribute('download',filename);
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
      }

      function exportWeeklyCsv(){
        if(!lastFilteredData.length) return alert('No data to export for the selected filters.');
        const {header,rows}=prepareWeeklyMatrix(lastFilteredData);
        let csv=header.join(',')+'\r\n'; rows.forEach(r=>{ csv+=header.map(c=>r[c]||'').join(',')+'\r\n'; });
        const filename=`quality_weekly_${currentPeriod||'all'}.csv`; downloadCSV(csv,filename);
      }

      const esc = s => String(s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));

      // Rebuilds the <select id="agentSelect">
      function populateAgentSelect(list){
        const sel = document.getElementById('agentSelect');
        if (!sel) return;
        sel.innerHTML = ['<option value="">All Agents</option>']
          .concat((list||[]).map(n => `<option value="${esc(n)}"${n===currentAgent?' selected':''}>${esc(n)}</option>`))
          .join('');
      }

        // Pull names via Code.gs (no edits needed there)
        function hydrateAgentList(){
          if (!(window.google && google.script && google.script.run)) {
              console.warn('google.script.run not available, using fallback agent list');
              // Fallback: extract unique agents from QA data
              const fallbackAgents = Array.from(new Set(rawQA.map(r => r.AgentName).filter(Boolean))).sort();
              userList = fallbackAgents;
              populateAgentSelect(fallbackAgents);
              console.log('Fallback userList:', userList);
              applyFilters();
              return;
          }

        const cid = (typeof campaignId !== 'undefined' && campaignId) ? campaignId : '';

          google.script.run
              .withSuccessHandler(names => {
                  console.log('Received agent names:', names);
                  if (!Array.isArray(names) || names.length === 0) { 
                      console.warn('Empty or invalid names payload, falling back');
                      fallbackToGetUsers(); 
                      return; 
                  }
                  userList = names;
                  populateAgentSelect(names);
                  console.log('Updated userList:', userList);
                  applyFilters();
              })
              .withFailureHandler(err => {
                  console.warn('clientGetAssignedAgentNames failed:', err);
                  fallbackToGetUsers();
              })
              .clientGetAssignedAgentNames(cid);

          function fallbackToGetUsers(){
              google.script.run
                  .withSuccessHandler(users => {
                      console.log('Received users:', users);
                      const names = (users||[])
                          .map(u => u.FullName || u.UserName || u.Email)
                          .filter(Boolean)
                          .sort((a,b)=>a.localeCompare(b));
                      
                      if (names.length === 0) {
                          console.warn('No users found, using QA data as fallback');
                          const qaAgents = Array.from(new Set(rawQA.map(r => r.AgentName).filter(Boolean))).sort();
                          userList = qaAgents;
                          populateAgentSelect(qaAgents);
                      } else {
                          userList = names;
                          populateAgentSelect(names);
                      }
                      
                      console.log('Final userList:', userList);
                      applyFilters();
                  })
                  .withFailureHandler(err => {
                      console.error('getUsers failed:', err);
                      // Ultimate fallback: use agents from QA data
                      const qaAgents = Array.from(new Set(rawQA.map(r => r.AgentName).filter(Boolean))).sort();
                      userList = qaAgents;
                      populateAgentSelect(qaAgents);
                      console.log('Ultimate fallback userList:', userList);
                      applyFilters();
                  })
                  .getUsers();
          }
      }

      document.addEventListener('DOMContentLoaded', function() {
        console.log('Dashboard initialization starting...');

        // Initialize animations
        try {
          const observer = new IntersectionObserver((entries) => { 
            entries.forEach(e => { 
              if(e.isIntersecting) { 
                e.target.style.opacity = '1'; 
                e.target.style.transform = 'translateY(0)'; 
              } 
            }); 
          });
          document.querySelectorAll('.fade-in, .stagger-animation > *').forEach(el => observer.observe(el));
        } catch(e) {
          console.warn('Animation observer failed:', e);
        }

        // Initialize live datetime updates
        try {
          updateLiveDatetime();
          setInterval(updateLiveDatetime, 1000);
        } catch(e) {
          console.warn('Live datetime failed:', e);
        }

        // Initialize data status
        try {
          updateDataRefreshStatus('success', 'System Ready');
        } catch(e) {
          console.warn('Data status failed:', e);
        }

        // Live status click handler
        try {
          const liveStatus = document.querySelector('.live-status');
          if (liveStatus) {
            liveStatus.addEventListener('click', () => {
              const indicator = document.querySelector('.live-indicator');
              if (indicator) {
                indicator.style.animation = 'none';
                setTimeout(() => {
                  indicator.style.animation = 'pulse-live 2s infinite';
                }, 100);
              }
            });
          }
        } catch(e) {
          console.warn('Live status click failed:', e);
        }

        // Data status click handler
        try {
          const dataStatus = document.getElementById('dataRefreshStatus');
          if (dataStatus) {
            dataStatus.addEventListener('click', () => {
              updateDataRefreshStatus('updating', 'Refreshing...');
              setTimeout(() => {
                updateDataRefreshStatus('success', `Data Current • ${new Date().toLocaleTimeString()}`);
              }, 1500);
            });
            dataStatus.style.cursor = 'pointer';
            dataStatus.title = 'Click to simulate refresh';
          }
        } catch(e) {
          console.warn('Data status click failed:', e);
        }

        // Report Type Select
        try {
          const reportTypeSelect = document.getElementById('reportTypeSelect');
          if (reportTypeSelect) {
            reportTypeSelect.addEventListener('change', function(e) {
              const baseUrl = '<?= baseUrl ?>';
              const nextPage = e.target.value;
              window.location.href = `${baseUrl}?page=${nextPage}`;
            });
          } else {
            console.warn('reportTypeSelect not found');
          }
        } catch(e) {
          console.error('Report type select failed:', e);
        }

        // Granularity Select
        try {
          const granularitySelect = document.getElementById('granularitySelect');
          if (granularitySelect) {
            granularitySelect.value = currentGran;
            granularitySelect.addEventListener('change', function() {
              currentGran = granularitySelect.value;
              showPicker();
              setPeriod();
              applyFilters();
            });
          } else {
            console.warn('granularitySelect not found');
          }
        } catch(e) {
          console.error('Granularity select failed:', e);
        }

        // Agent Select
        try {
          const agentSelect = document.getElementById('agentSelect');
          if (agentSelect) {
            agentSelect.addEventListener('change', function(e) {
              currentAgent = e.target.value;
              applyFilters();
            });
          } else {
            console.warn('agentSelect not found');
          }
        } catch(e) {
          console.error('Agent select failed:', e);
        }

        // Period input handlers
        try {
          ['weekInput', 'monthInput', 'yearInput'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
              el.addEventListener('change', function(e) {
                currentPeriod = e.target.value;
                applyFilters();
              });
            }
          });

          ['quarterSelect', 'quarterYearInput'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
              el.addEventListener('change', function() {
                setQuarter();
                applyFilters();
              });
            }
          });
        } catch(e) {
          console.error('Period inputs failed:', e);
        }

        // Export CSV Button
        try {
          const exportBtn = document.getElementById('exportCsvBtn');
          if (exportBtn) {
            exportBtn.addEventListener('click', function() {
              exportWeeklyCsv();
            });
          } else {
            console.warn('exportCsvBtn not found');
          }
        } catch(e) {
          console.error('Export button failed:', e);
        }

        // Helper functions
        function showPicker() {
          try {
            ['weekPicker', 'monthPicker', 'quarterPicker', 'yearPicker'].forEach(id => {
              const el = document.getElementById(id);
              if (el) el.style.display = 'none';
            });
            
            const map = {
              'Week': 'weekPicker',
              'Month': 'monthPicker',
              'Quarter': 'quarterPicker',
              'Year': 'yearPicker'
            };
            
            const target = document.getElementById(map[currentGran]);
            if (target) {
              target.style.display = (currentGran === 'Quarter') ? 'flex' : 'block';
            }
          } catch(e) {
            console.error('showPicker failed:', e);
          }
        }

        function setPeriod() {
          try {
            const map = {
              'Week': 'weekInput',
              'Month': 'monthInput',
              'Year': 'yearInput'
            };
            const input = document.getElementById(map[currentGran]);
            if (input && input.value) {
              currentPeriod = input.value;
            }
          } catch(e) {
            console.error('setPeriod failed:', e);
          }
        }

        function setQuarter() {
          try {
            const q = document.getElementById('quarterSelect')?.value;
            const y = document.getElementById('quarterYearInput')?.value;
            currentPeriod = (q && y) ? `${q}-${y}` : '';
          } catch(e) {
            console.error('setQuarter failed:', e);
          }
        }

        // Initialize UI
        try {
          showPicker();
          const weekInput = document.getElementById('weekInput');
          if (weekInput) {
            weekInput.value = currentPeriod;
          }
        } catch(e) {
          console.error('UI initialization failed:', e);
        }

        // Load data
        try {
          setTimeout(() => {
            console.log('Starting data load...');
            applyFilters();
          }, 300);
          
          debugInvalidDates();
          hydrateAgentList();
        } catch(e) {
          console.error('Data load failed:', e);
        }

        console.log('Quality Dashboard initialization completed');
      });
</script>
</body>


</html>
