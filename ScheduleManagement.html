    <?!= includeOnce('ResponsiveStyles') ?>
<?!= include("layout", {
  baseUrl: baseUrl,
  scriptUrl: scriptUrl,
  user: user,
  currentPage: currentPage || 'schedulemanagement'
}) ?>
<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<!-- Font Awesome -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
    :root {
        --primary: #0052cc;
        --primary-dark: #003d99;
        --primary-light: rgba(0, 82, 204, 0.1);
        --success: #00875a;
        --warning: #ffab00;
        --danger: #de350b;
        --info: #0747a6;
        --light: #f8fafc;
        --dark: #1e293b;
        --jamaica-green: #009639;
        --jamaica-gold: #ffda44;
        --border-radius: 12px;
        --border-radius-sm: 8px;
        --border-radius-lg: 16px;
        --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.05);
        --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
        --spacing-xs: 0.5rem;
        --spacing-sm: 1rem;
        --spacing-md: 1.5rem;
        --spacing-lg: 2rem;
        --spacing-xl: 3rem;
    }

    * {
        box-sizing: border-box;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
        min-height: 100vh;
        line-height: 1.6;
        color: var(--dark);
    }

    /* Header Styles */
    .app-header {
        background: linear-gradient(135deg, var(--jamaica-green) 0%, var(--primary) 100%);
        color: white;
        padding: var(--spacing-lg) 0;
        margin-bottom: var(--spacing-lg);
        position: relative;
        overflow: hidden;
    }

    .app-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
        opacity: 0.3;
    }

    .app-header .container-fluid {
        position: relative;
        z-index: 1;
    }

    .app-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: var(--spacing-xs);
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .app-subtitle {
        font-size: 1.1rem;
        opacity: 0.9;
        margin-bottom: 0;
    }

    /* Modern Card System */
    .modern-card {
        background: white;
        border-radius: var(--border-radius);
        border: 1px solid #e2e8f0;
        box-shadow: var(--shadow);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
    }

    .modern-card:hover {
        box-shadow: var(--shadow-lg);
        transform: translateY(-2px);
    }

    .modern-card-header {
        background: linear-gradient(135deg, white 0%, #f8fafc 100%);
        padding: var(--spacing-md);
        border-bottom: 1px solid #e2e8f0;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .modern-card-title {
        font-size: 1.125rem;
        font-weight: 600;
        color: var(--dark);
        margin: 0;
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
    }

    .modern-card-body {
        padding: var(--spacing-md);
    }

    /* Attendance Calendar */
    .attendance-calendar {
        background: linear-gradient(135deg, #ffffff 0%, #f3f7ff 100%);
        border-radius: var(--border-radius);
        border: 1px solid #dbe3f4;
        box-shadow: var(--shadow);
        overflow: hidden;
    }

    .attendance-calendar__header {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        padding: var(--spacing-md);
        background: linear-gradient(135deg, rgba(0, 82, 204, 0.08) 0%, rgba(0, 150, 57, 0.08) 100%);
        border-bottom: 1px solid rgba(13, 86, 176, 0.15);
    }

    .attendance-calendar__header-top {
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-sm);
        justify-content: space-between;
        align-items: center;
    }

    .attendance-calendar__period {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .attendance-calendar__period-label {
        font-size: 1.5rem;
        font-weight: 700;
        letter-spacing: 0.08em;
        color: var(--primary-dark);
    }

    .attendance-calendar__period-subtitle {
        font-size: 0.875rem;
        text-transform: uppercase;
        color: rgba(14, 53, 102, 0.75);
        letter-spacing: 0.12em;
    }

    .attendance-calendar__legend {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.5rem;
    }

    .attendance-calendar__legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 0.75rem;
        background: rgba(255, 255, 255, 0.75);
        border: 1px solid rgba(13, 86, 176, 0.1);
        border-radius: var(--border-radius-sm);
        font-size: 0.85rem;
        color: #0f2a56;
        box-shadow: 0 2px 4px rgba(15, 42, 86, 0.05);
    }

    .attendance-calendar__status {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 2.25rem;
        height: 2rem;
        border-radius: 0.5rem;
        font-weight: 700;
        font-size: 0.9rem;
        letter-spacing: 0.05em;
        box-shadow: inset 0 -2px 0 rgba(0, 0, 0, 0.15);
        color: #fff;
        text-transform: uppercase;
    }

    .attendance-calendar__status--present { background: #2f9d63; }
    .attendance-calendar__status--absent { background: #d64545; }
    .attendance-calendar__status--late { background: #f29f3f; color: #3f2a00; }
    .attendance-calendar__status--sick { background: #2a8bdc; }
    .attendance-calendar__status--vacation { background: #4b6cb7; }
    .attendance-calendar__status--bereavement { background: #4a5568; }
    .attendance-calendar__status--loa { background: #6b46c1; }
    .attendance-calendar__status--personal { background: #0f172a; }
    .attendance-calendar__status--training { background: #1f9d8f; }
    .attendance-calendar__status--ncns { background: #8b1a1a; }
    .attendance-calendar__status--other {
        background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%);
    }

    .attendance-calendar__status--empty {
        background: #e2e8f0;
        color: #475569;
        box-shadow: none;
    }

    .attendance-calendar__status--inactive {
        background: rgba(148, 163, 184, 0.5);
        color: #0f172a;
        box-shadow: none;
    }

    .attendance-calendar__table-wrapper {
        overflow-x: auto;
        padding: var(--spacing-md);
        background: rgba(255, 255, 255, 0.9);
    }

    .attendance-calendar__table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        min-width: 960px;
        font-size: 0.875rem;
        box-shadow: 0 1px 3px rgba(15, 42, 86, 0.1);
    }

    .attendance-calendar__table thead th {
        background: linear-gradient(135deg, rgba(0, 82, 204, 0.12) 0%, rgba(0, 150, 57, 0.12) 100%);
        color: #0f2a56;
        text-align: center;
        padding: 0.75rem 0.5rem;
        font-weight: 600;
        border-bottom: 2px solid rgba(13, 86, 176, 0.35);
        border-right: 1px solid rgba(13, 86, 176, 0.1);
        position: sticky;
        top: 0;
        z-index: 2;
    }

    .attendance-calendar__table thead th:first-child {
        text-align: left;
        padding-left: 1rem;
        border-right: 2px solid rgba(13, 86, 176, 0.25);
    }

    .attendance-calendar__participant-header {
        width: 220px;
        min-width: 200px;
    }

    .attendance-calendar__day {
        min-width: 48px;
    }

    .attendance-calendar__day-number {
        display: block;
        font-size: 1rem;
        font-weight: 700;
    }

    .attendance-calendar__day-name {
        display: block;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(15, 42, 86, 0.7);
    }

    .attendance-calendar__table tbody th {
        position: sticky;
        left: 0;
        background: #f8fafc;
        border-right: 2px solid rgba(13, 86, 176, 0.1);
        padding: 0.75rem 1rem;
        font-weight: 600;
        color: #0f2a56;
        vertical-align: middle;
        z-index: 1;
    }

    .attendance-calendar__participant-name {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.95rem;
        white-space: nowrap;
    }

    .attendance-calendar__table td {
        text-align: center;
        padding: 0.4rem 0.35rem;
        border-right: 1px solid rgba(13, 86, 176, 0.08);
        border-bottom: 1px solid rgba(13, 86, 176, 0.08);
        background: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .attendance-calendar__cell {
        position: relative;
    }

    .attendance-calendar__table td:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(15, 42, 86, 0.15);
    }

    .attendance-calendar__cell--weekend {
        background: rgba(229, 231, 235, 0.6);
    }

    .attendance-calendar__cell--inactive {
        background: rgba(226, 232, 240, 0.4);
        cursor: not-allowed;
        opacity: 0.65;
    }

    .attendance-calendar__cell--inactive:hover {
        transform: none;
        box-shadow: none;
        background: rgba(226, 232, 240, 0.4);
    }

    .attendance-calendar__table tbody tr:hover td.attendance-calendar__cell--inactive {
        background: rgba(226, 232, 240, 0.4);
    }

    .attendance-calendar__table tbody tr:nth-child(odd) td {
        background: rgba(248, 250, 252, 0.85);
    }

    .attendance-calendar__table tbody tr:nth-child(even) td {
        background: rgba(255, 255, 255, 0.95);
    }

    .attendance-calendar__table tbody tr:nth-child(odd) td.attendance-calendar__cell--weekend,
    .attendance-calendar__table tbody tr:nth-child(even) td.attendance-calendar__cell--weekend {
        background: rgba(229, 231, 235, 0.6);
    }

    .attendance-calendar__table tbody tr:hover td {
        background: rgba(214, 230, 255, 0.4);
    }

    .attendance-context-menu {
        position: fixed;
        z-index: 9999;
        display: none;
        min-width: 140px;
        background: #ffffff;
        border: 1px solid rgba(15, 23, 42, 0.15);
        border-radius: 6px;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.18);
        padding: 0.25rem 0;
        color: #0f172a;
        user-select: none;
    }

    .attendance-context-menu.visible {
        display: block;
    }

    .attendance-context-menu__list {
        list-style: none;
        margin: 0;
        padding: 0;
    }

    .attendance-context-menu__item {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.35rem 0.75rem;
        background: transparent;
        border: none;
        color: inherit;
        font-size: 0.85rem;
        text-align: left;
        cursor: pointer;
        transition: background 0.15s ease;
    }

    .attendance-context-menu__item:hover,
    .attendance-context-menu__item:focus {
        background: rgba(59, 130, 246, 0.12);
        outline: none;
    }

    .attendance-context-menu__code {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.75rem;
        height: 1.75rem;
        border-radius: 0.375rem;
        font-weight: 600;
        font-size: 0.85rem;
        text-transform: uppercase;
        color: #ffffff;
    }

    .attendance-context-menu__text {
        flex: 1;
        line-height: 1.2;
        white-space: nowrap;
    }

    @media (max-width: 992px) {
        .attendance-calendar__legend {
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }

        .attendance-calendar__table {
            min-width: 720px;
        }
    }

    @media (max-width: 576px) {
        .attendance-calendar__header {
            padding: var(--spacing-sm);
        }

        .attendance-calendar__period-label {
            font-size: 1.25rem;
        }

        .attendance-calendar__table-wrapper {
            padding: var(--spacing-sm);
        }
    }

    /* Navigation Tabs */
    .modern-nav {
        background: white;
        border-radius: var(--border-radius);
        padding: var(--spacing-xs);
        box-shadow: var(--shadow);
        margin-bottom: var(--spacing-lg);
        border: 1px solid #e2e8f0;
    }

    .modern-nav .nav-link {
        border: none;
        background: transparent;
        color: var(--dark);
        font-weight: 500;
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--border-radius-sm);
        transition: all 0.2s ease;
        margin: 2px;
        white-space: nowrap;
    }

    .modern-nav .nav-link:hover {
        color: var(--primary);
        background: var(--primary-light);
    }

    .modern-nav .nav-link.active {
        color: white;
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        box-shadow: var(--shadow);
    }

    /* Button System */
    .btn-modern {
        border-radius: var(--border-radius-sm);
        font-weight: 500;
        padding: 0.75rem 1.5rem;
        border: none;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: var(--spacing-xs);
        text-decoration: none;
        position: relative;
        overflow: hidden;
    }

    .btn-modern:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow);
    }

    .btn-modern:active {
        transform: translateY(0);
    }

    .btn-primary-modern {
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        color: white;
    }

    .btn-success-modern {
        background: linear-gradient(135deg, var(--success) 0%, var(--jamaica-green) 100%);
        color: white;
    }

    .btn-warning-modern {
        background: linear-gradient(135deg, var(--warning) 0%, #e6930e 100%);
        color: white;
    }

    .btn-danger-modern {
        background: linear-gradient(135deg, var(--danger) 0%, #c4320a 100%);
        color: white;
    }

    .btn-outline-modern {
        background: white;
        border: 2px solid var(--primary);
        color: var(--primary);
    }

    .btn-outline-modern:hover {
        background: var(--primary);
        color: white;
    }

    /* Metric Cards */
    .metric-card {
        background: white;
        border-radius: var(--border-radius);
        padding: var(--spacing-md);
        text-align: center;
        border: 1px solid #e2e8f0;
        box-shadow: var(--shadow-sm);
        transition: all 0.3s ease;
        height: 100%;
    }

    .metric-card:hover {
        transform: translateY(-4px);
        box-shadow: var(--shadow);
    }

    .metric-number {
        font-size: 2.5rem;
        font-weight: 700;
        line-height: 1;
        margin-bottom: var(--spacing-xs);
    }

    .metric-label {
        font-size: 0.875rem;
        color: #64748b;
        text-transform: uppercase;
        font-weight: 600;
        letter-spacing: 0.5px;
    }

    /* Status Badges */
    .status-badge {
        padding: 0.375rem 0.875rem;
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border: 2px solid;
    }

    .status-pending {
        background: rgba(255, 171, 0, 0.1);
        color: var(--warning);
        border-color: var(--warning);
    }

    .status-approved {
        background: rgba(0, 135, 90, 0.1);
        color: var(--success);
        border-color: var(--success);
    }

    .status-rejected {
        background: rgba(222, 53, 11, 0.1);
        color: var(--danger);
        border-color: var(--danger);
    }

    /* Form Controls */
    .form-control-modern {
        border: 2px solid #e2e8f0;
        border-radius: var(--border-radius-sm);
        padding: 0.75rem 1rem;
        transition: all 0.2s ease;
        font-size: 0.95rem;
    }

    .form-control-modern:focus {
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(0, 82, 204, 0.1);
        outline: none;
    }

    .form-label-modern {
        font-weight: 600;
        color: var(--dark);
        margin-bottom: var(--spacing-xs);
        display: block;
    }

    /* Table Styles */
    .table-modern {
        background: white;
        border-radius: var(--border-radius);
        overflow: hidden;
        box-shadow: var(--shadow-sm);
        border: 1px solid #e2e8f0;
    }

    .table-modern thead th {
        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        border: none;
        font-weight: 600;
        color: var(--dark);
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.5px;
        padding: var(--spacing-sm) var(--spacing-md);
    }

    .table-modern tbody td {
        padding: var(--spacing-sm) var(--spacing-md);
        border-bottom: 1px solid #f1f5f9;
        vertical-align: middle;
    }

    .table-modern tbody tr:hover {
        background: linear-gradient(135deg, rgba(0, 82, 204, 0.02) 0%, rgba(0, 150, 57, 0.02) 100%);
    }

    /* Days Selector */
    .days-selector {
        display: flex;
        gap: var(--spacing-xs);
        flex-wrap: wrap;
    }

    .day-checkbox {
        position: relative;
    }

    .day-checkbox input[type="checkbox"] {
        display: none;
    }

    .day-checkbox label {
        display: block;
        padding: 0.625rem 1rem;
        background: white;
        border: 2px solid #e2e8f0;
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
        font-size: 0.875rem;
        min-width: 3rem;
        text-align: center;
    }

    .day-checkbox input[type="checkbox"]:checked + label {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
        transform: translateY(-1px);
        box-shadow: var(--shadow);
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .app-title {
            font-size: 2rem;
        }

        .modern-nav .nav-link {
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 0.875rem;
        }

        .metric-number {
            font-size: 2rem;
        }

        .modern-card-body {
            padding: var(--spacing-sm);
        }
    }

    /* Priority Classes */
    .priority-low { color: #64748b; }
    .priority-normal { color: var(--primary); }
    .priority-high { color: var(--warning); }
    .priority-critical { color: var(--danger); }

    /* Status Indicators */
    .status-indicator {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 0.7rem;
        color: white;
    }

    .status-present { background: var(--success); }
    .status-absent { background: var(--danger); }
    .status-late { background: var(--warning); color: #333; }
    .status-sick { background: var(--info); }
    .status-vacation { background: #6366f1; }

    /* Insight Cards */
    .insight-card {
        background: white;
        border-radius: var(--border-radius-sm);
        padding: var(--spacing-md);
        margin-bottom: var(--spacing-sm);
        border-left: 4px solid;
        box-shadow: var(--shadow-sm);
        border: 1px solid #e2e8f0;
    }

    .insight-positive { border-left-color: var(--success); }
    .insight-warning { border-left-color: var(--warning); }
    .insight-critical { border-left-color: var(--danger); }
    .insight-neutral { border-left-color: var(--info); }

    /* Container Spacing */
    .container-fluid {
        padding-left: var(--spacing-md);
        padding-right: var(--spacing-md);
    }

    /* Gap Utilities */
    .gap-xs { gap: var(--spacing-xs) !important; }
    .gap-sm { gap: var(--spacing-sm) !important; }
    .gap-md { gap: var(--spacing-md) !important; }
    .gap-lg { gap: var(--spacing-lg) !important; }

    /* Attendance Dashboard */
    .attendance-dashboard {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
    }

    .attendance-panel {
        background: white;
        border-radius: var(--border-radius-sm);
        padding: var(--spacing-sm);
        border: 1px solid #e2e8f0;
        box-shadow: var(--shadow-sm);
        height: 100%;
    }

    .attendance-panel-dark {
        background: linear-gradient(135deg, #002b63 0%, #0b3b91 100%);
        color: white;
        border-color: transparent;
        box-shadow: var(--shadow);
    }

    .attendance-panel-title {
        font-size: 0.95rem;
        font-weight: 600;
        margin-bottom: var(--spacing-xs);
        color: inherit;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .attendance-panel-subtitle {
        font-size: 0.8rem;
        opacity: 0.85;
    }

    .attendance-chart {
        position: relative;
        height: 200px;
    }

    .attendance-chart.tall {
        height: 260px;
    }

    .attendance-chart.small {
        height: 140px;
    }

    .attendance-percentage-value {
        font-size: 1.75rem;
        font-weight: 700;
        text-align: center;
        margin-top: var(--spacing-xs);
    }

    .attendance-panel-dark .attendance-percentage-value {
        color: var(--jamaica-gold);
    }

    .attendance-recognition-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
        margin-bottom: 0.75rem;
    }

    .attendance-recognition-filters {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0.4rem;
    }

    .attendance-recognition-filter {
        border: 1px solid rgba(0, 82, 204, 0.35);
        background: rgba(0, 82, 204, 0.08);
        color: var(--primary-dark);
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        padding: 0.35rem 0.75rem;
        border-radius: var(--border-radius-sm);
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .attendance-recognition-filter:hover,
    .attendance-recognition-filter:focus {
        background: rgba(0, 82, 204, 0.15);
        color: var(--primary);
        outline: none;
        box-shadow: 0 0 0 2px rgba(0, 82, 204, 0.1);
    }

    .attendance-recognition-filter.active {
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        color: white;
        border-color: transparent;
        box-shadow: var(--shadow-sm);
    }

    .attendance-recognition-period {
        font-size: 0.75rem;
        font-weight: 600;
        color: rgba(15, 42, 86, 0.65);
        text-transform: uppercase;
        letter-spacing: 0.08em;
    }

    .attendance-recognition {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .attendance-panel.attendance-panel--auto-height {
        height: auto;
    }

    .attendance-recognition-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border-radius: var(--border-radius-sm);
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: linear-gradient(135deg, rgba(0, 150, 57, 0.08) 0%, rgba(15, 42, 86, 0.04) 100%);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.45);
    }

    .attendance-recognition-item--second {
        background: linear-gradient(135deg, rgba(15, 42, 86, 0.06) 0%, rgba(96, 125, 139, 0.08) 100%);
    }

    .attendance-recognition-item--third {
        background: linear-gradient(135deg, rgba(249, 115, 22, 0.08) 0%, rgba(15, 42, 86, 0.04) 100%);
    }

    .attendance-recognition-rank {
        font-weight: 700;
        font-size: 1.25rem;
        min-width: 48px;
        text-align: center;
        color: var(--primary);
    }

    .attendance-recognition-rank sup {
        font-size: 0.55em;
    }

    .attendance-recognition-item--first .attendance-recognition-rank {
        color: var(--jamaica-gold);
    }

    .attendance-recognition-item--second .attendance-recognition-rank {
        color: #94a3b8;
    }

    .attendance-recognition-item--third .attendance-recognition-rank {
        color: #f97316;
    }

    .attendance-recognition-icon {
        font-size: 1.5rem;
        color: var(--primary);
    }

    .attendance-recognition-item--first .attendance-recognition-icon {
        color: var(--jamaica-gold);
    }

    .attendance-recognition-item--second .attendance-recognition-icon {
        color: #94a3b8;
    }

    .attendance-recognition-item--third .attendance-recognition-icon {
        color: #f97316;
    }

    .attendance-recognition-details {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .attendance-recognition-name {
        font-weight: 600;
        color: var(--dark);
    }

    .attendance-recognition-meta {
        font-size: 0.8rem;
        color: #64748b;
    }

    .attendance-recognition-empty {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
        border-radius: var(--border-radius-sm);
        border: 1px dashed rgba(148, 163, 184, 0.6);
        background: #f8fafc;
        color: #475569;
        font-size: 0.85rem;
    }

    .attendance-panel-dark .attendance-recognition-item {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.12);
        box-shadow: none;
    }

    .attendance-panel-dark .attendance-recognition-name {
        color: #fff;
    }

    .attendance-panel-dark .attendance-recognition-meta {
        color: rgba(255, 255, 255, 0.75);
    }

    .attendance-panel-actions {
        display: flex;
        gap: var(--spacing-xs);
        align-items: center;
    }

    .attendance-panel-actions select {
        background: rgba(255, 255, 255, 0.15);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .attendance-panel-actions select option {
        color: #0f172a;
    }

    .attendance-dashboard-controls {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: var(--spacing-xs);
        flex-wrap: wrap;
    }

    .attendance-dashboard-controls span {
        font-size: 0.85rem;
        color: #64748b;
    }

    .attendance-dashboard-controls select {
        min-width: 180px;
    }

    @media (max-width: 991px) {
        .attendance-panel-actions {
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .attendance-chart.tall,
        .attendance-chart {
            height: 220px;
        }
    }

    /* Chart Container */
    .chart-container {
        position: relative;
        height: 300px;
        padding: var(--spacing-sm);
    }

    /* Enhanced hover effects */
    .interactive-item {
        transition: all 0.2s ease;
    }

    .interactive-item:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow);
    }

    /* Header Action Buttons */
    .header-actions {
        display: flex;
        gap: var(--spacing-sm);
        flex-wrap: wrap;
    }

    .header-actions .btn {
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        backdrop-filter: blur(10px);
    }

    .header-actions .btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-1px);
    }

    /* Tab Content Spacing */
    .tab-pane {
        animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    /* Manual Shift Assignment Tab */
    .manual-shift-tab {
        padding: var(--spacing-md);
    }

    .manual-shift-header {
        max-width: 820px;
        margin: 0 auto var(--spacing-lg);
    }

    .manual-shift-title {
        font-size: 2.25rem;
        font-weight: 800;
        margin-bottom: 0.75rem;
        background: linear-gradient(135deg, var(--primary) 0%, var(--jamaica-green) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .manual-shift-subtitle {
        font-size: 1rem;
        color: var(--gray-600);
        line-height: 1.6;
    }

    .manual-shift-tab .user-selection-card {
        display: flex;
        flex-direction: column;
        min-height: 100%;
    }

    .manual-shift-tab .user-search-box {
        position: relative;
        margin-bottom: var(--spacing-sm);
    }

    .manual-shift-tab .user-search-box i {
        position: absolute;
        top: 50%;
        left: 0.85rem;
        transform: translateY(-50%);
        color: var(--gray-500);
    }

    .manual-shift-tab .user-search-input {
        padding-left: 2.5rem;
    }

    .manual-shift-tab .user-selection-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
    }

    .manual-shift-tab .user-count-label {
        font-weight: 600;
        color: var(--gray-600);
    }

    .manual-shift-tab .user-list {
        flex: 1;
        border: 1px solid var(--outline);
        border-radius: var(--border-radius);
        background: rgba(255, 255, 255, 0.9);
        max-height: 360px;
        overflow-y: auto;
        padding: 0.75rem;
    }

    .manual-shift-tab .user-loading-state {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 2.25rem 1rem;
        color: var(--gray-600);
    }

    .manual-shift-tab .user-list-empty {
        padding: 2.5rem 1rem;
        text-align: center;
        color: var(--gray-500);
        font-size: 0.95rem;
    }

    .manual-shift-tab .user-list-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        border-radius: var(--border-radius-sm);
        padding: 0.5rem 0.65rem;
        transition: background-color 0.2s ease;
    }

    .manual-shift-tab .user-list-item:hover {
        background: rgba(14, 165, 233, 0.08);
    }

    .manual-shift-tab .user-list-item + .user-list-item {
        margin-top: 0.35rem;
    }

    .manual-shift-tab .user-name {
        font-weight: 600;
        color: var(--dark);
    }

    .manual-shift-tab .user-meta {
        font-size: 0.8rem;
        color: var(--gray-500);
    }

    .manual-shift-tab .form-footer-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
        justify-content: space-between;
    }

    .manual-shift-tab .form-footer-actions .btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
        border-radius: var(--border-radius);
        padding: 0.6rem 1.1rem;
    }

    .manual-shift-tab .manual-help-list {
        margin-bottom: 0;
        padding-left: 1.2rem;
    }

    .manual-shift-tab .activity-entry {
        border-left: 4px solid var(--primary);
        padding-left: 1rem;
        background: rgba(14, 165, 233, 0.06);
        border-radius: 0 var(--border-radius) var(--border-radius) 0;
        padding: 1rem 1.25rem;
    }

    .manual-shift-tab .activity-entry strong {
        display: block;
        font-weight: 700;
        color: var(--dark);
    }

    .manual-shift-tab .activity-meta {
        font-size: 0.85rem;
        color: var(--gray-600);
        margin-top: 0.35rem;
    }

    .manual-shift-tab .activity-log {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }

    .manual-shift-tab .manual-activity-empty {
        padding: 1.5rem;
        border-radius: var(--border-radius);
        background: rgba(148, 163, 184, 0.15);
        color: var(--gray-600);
        text-align: center;
    }

    .manual-shift-tab .alert-modern {
        border-radius: var(--border-radius);
        padding: 1rem 1.25rem;
        margin-bottom: 1.25rem;
        border: 1px solid transparent;
        display: flex;
        gap: 0.85rem;
        align-items: flex-start;
        position: relative;
    }

    .manual-shift-tab .alert-modern i {
        font-size: 1.15rem;
    }

    .manual-shift-tab .alert-modern p {
        margin: 0;
    }

    .manual-shift-tab .alert-success-modern {
        background: rgba(16, 185, 129, 0.12);
        border-color: rgba(16, 185, 129, 0.35);
        color: #047857;
    }

    .manual-shift-tab .alert-danger-modern {
        background: rgba(239, 68, 68, 0.12);
        border-color: rgba(239, 68, 68, 0.35);
        color: #b91c1c;
    }

    .manual-shift-tab .alert-warning-modern {
        background: rgba(234, 179, 8, 0.15);
        border-color: rgba(234, 179, 8, 0.35);
        color: #92400e;
    }

    .manual-shift-tab .alert-info-modern {
        background: rgba(59, 130, 246, 0.12);
        border-color: rgba(59, 130, 246, 0.35);
        color: #1d4ed8;
    }

    .manual-shift-tab .alert-close {
        position: absolute;
        top: 0.5rem;
        right: 0.75rem;
        background: none;
        border: none;
        font-size: 1.25rem;
        color: inherit;
        cursor: pointer;
    }

    @media (max-width: 768px) {
        .manual-shift-tab {
            padding: var(--spacing-sm);
        }

        .manual-shift-title {
            font-size: 1.85rem;
        }

        .manual-shift-tab .form-footer-actions {
            flex-direction: column;
            align-items: stretch;
        }

        .manual-shift-tab .form-footer-actions .btn {
            justify-content: center;
            width: 100%;
        }
    }
</style>

<!-- Header -->
<header class="app-header">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col-lg-4 text-lg-end mt-3 mt-lg-0">
                <div class="header-actions">
                    <button class="btn btn-modern" onclick="runSystemDiagnostics()">
                        <i class="fas fa-heartbeat"></i>
                        System Health
                    </button>
                    <button class="btn btn-modern" onclick="refreshAllData()">
                        <i class="fas fa-sync"></i>
                        Refresh All
                    </button>
                </div>
            </div>
        </div>
    </div>
</header>

<div class="container-fluid">
    <!-- System Status Alert -->
    <div id="systemStatus" class="d-none"></div>

    <!-- Main Navigation -->
    <nav class="modern-nav">
        <ul class="nav nav-pills justify-content-center" id="mainTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="dashboard-tab" data-bs-toggle="pill" data-bs-target="#dashboard" type="button" role="tab">
                    <i class="fas fa-tachometer-alt"></i>
                    <span class="d-none d-sm-inline ms-2">AI Dashboard</span>
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="attendance-dashboard-tab" data-bs-toggle="pill" data-bs-target="#attendance-dashboard" type="button" role="tab">
                    <i class="fas fa-chart-pie"></i>
                    <span class="d-none d-sm-inline ms-2">Attendance Dashboard</span>
                </button>
            </li>            
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="attendance-tab" data-bs-toggle="pill" data-bs-target="#attendance" type="button" role="tab">
                    <i class="fas fa-calendar-check"></i>
                    <span class="d-none d-sm-inline ms-2">Attendance Calendar</span>
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="generation-tab" data-bs-toggle="pill" data-bs-target="#generation" type="button" role="tab">
                    <i class="fas fa-calendar-plus"></i>
                    <span class="d-none d-sm-inline ms-2">Generate</span>
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="management-tab" data-bs-toggle="pill" data-bs-target="#management" type="button" role="tab">
                    <i class="fas fa-tasks"></i>
                    <span class="d-none d-sm-inline ms-2">Manage</span>
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="import-tab" data-bs-toggle="pill" data-bs-target="#import" type="button" role="tab">
                    <i class="fas fa-user-clock"></i>
                    <span class="d-none d-sm-inline ms-2">Manual Shift</span>
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="shifts-tab" data-bs-toggle="pill" data-bs-target="#shifts" type="button" role="tab">
                    <i class="fas fa-clock"></i>
                    <span class="d-none d-sm-inline ms-2">Shifts</span>
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="holidays-tab" data-bs-toggle="pill" data-bs-target="#holidays" type="button" role="tab">
                    <i class="fas fa-globe"></i>
                    <span class="d-none d-sm-inline ms-2">Holidays</span>
                </button>
            </li>
        </ul>
    </nav>

    <!-- Tab Content -->
    <div class="tab-content" id="mainTabContent">

        <!-- AI Dashboard Tab -->
        <div class="tab-pane fade show active" id="dashboard" role="tabpanel">
            <!-- Schedule Health Metrics -->
            <div class="row g-4 mb-4">
                <div class="col-xl-3 col-sm-6">
                    <div class="metric-card">
                        <div class="metric-number text-primary" id="scheduleHealthScore">0</div>
                        <div class="metric-label">Schedule Health</div>
                    </div>
                </div>
                <div class="col-xl-3 col-sm-6">
                    <div class="metric-card">
                        <div class="metric-number text-success" id="scheduleServiceLevel">0%</div>
                        <div class="metric-label">Service Level</div>
                    </div>
                </div>
                <div class="col-xl-3 col-sm-6">
                    <div class="metric-card">
                        <div class="metric-number text-warning" id="scheduleFairnessIndex">0</div>
                        <div class="metric-label">Fairness Index</div>
                    </div>
                </div>
                <div class="col-xl-3 col-sm-6">
                    <div class="metric-card">
                        <div class="metric-number text-info" id="scheduleComplianceScore">0</div>
                        <div class="metric-label">Compliance Score</div>
                    </div>
                </div>
            </div>

            <div class="row g-4 mb-4">
                <div class="col-lg-3 col-sm-6">
                    <div class="metric-card">
                        <div class="metric-number text-primary" id="totalUsers">0</div>
                        <div class="metric-label">Managed Agents</div>
                    </div>
                </div>
                <div class="col-lg-3 col-sm-6">
                    <div class="metric-card">
                        <div class="metric-number text-info" id="scheduleRosterHours">0h</div>
                        <div class="metric-label">Scheduled Hours</div>
                    </div>
                </div>
                <div class="col-lg-3 col-sm-6">
                    <div class="metric-card">
                        <div class="metric-number text-primary" id="scheduleRequiredFte">0</div>
                        <div class="metric-label">Required FTE</div>
                    </div>
                </div>
                <div class="col-lg-3 col-sm-6">
                    <div class="metric-card">
                        <div class="metric-number text-primary" id="scheduleStaffedFte">0</div>
                        <div class="metric-label">Staffed FTE</div>
                    </div>
                </div>
            </div>

            <!-- Charts and Insights Row -->
            <div class="row g-4 mb-4">
                <div class="col-lg-8">
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-chart-line text-primary"></i>
                                Coverage vs Requirement
                            </h5>
                            <button class="btn btn-outline-modern btn-sm" onclick="refreshDashboard()">
                                <i class="fas fa-sync"></i>
                                Refresh
                            </button>
                        </div>
                        <div class="modern-card-body p-0">
                            <div class="chart-container">
                                <canvas id="scheduleCoverageChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-4">
                    <div class="modern-card h-100">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-lightbulb text-info"></i>
                                Optimizer Insights
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div id="scheduleInsights">
                                <div class="text-center text-muted">
                                    <div class="loading-spinner mx-auto mb-3"></div>
                                    <p>Analyzing schedule health...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Additional Dashboard Cards -->
            <div class="row g-4">
                <div class="col-lg-6">
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-balance-scale text-warning"></i>
                                Fairness Watchlist
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div id="fairnessWatchlist">
                                <div class="text-center text-muted">
                                    <p>Evaluating rotation balance...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-6">
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-shield-alt text-danger"></i>
                                Compliance Alerts
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div id="complianceAlerts">
                                <div class="text-center text-success">
                                    <i class="fas fa-check-circle fa-2x mb-2"></i>
                                    <p>No compliance issues detected</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Attendance Dashboard Tab -->
        <div class="tab-pane fade" id="attendance-dashboard" role="tabpanel">
            <div class="modern-card mb-4">
                <div class="modern-card-header">
                    <div>
                        <h5 class="modern-card-title">
                            <i class="fas fa-chart-pie text-primary"></i>
                            Attendance Dashboard
                        </h5>
                        <div class="text-muted small">Real-time attendance intelligence for managers</div>
                    </div>
                    <div class="attendance-dashboard-controls">
                        <span class="text-muted small">Filter by user:</span>
                        <select id="attendanceDashboardUser" class="form-select form-select-sm" aria-label="Filter attendance dashboard by user">
                            <option value="">All Users</option>
                        </select>
                    </div>
                </div>
                <div class="modern-card-body">
                    <div class="attendance-dashboard">
                        <div class="row g-4">
                            <div class="col-lg-8">
                                <div class="attendance-panel attendance-panel-dark h-100">
                                    <div class="d-flex justify-content-between align-items-start mb-2">
                                        <div>
                                            <div class="attendance-panel-title">Yearly Trends</div>
                                            <div class="attendance-panel-subtitle">Track punctual, late, absent and sick shifts across the year.</div>
                                        </div>
                                    </div>
                                    <div class="attendance-chart tall">
                                        <canvas id="attendanceYearlyTrendChart"></canvas>
                                    </div>
                                </div>
                            </div>
                            <div class="col-lg-4">
                                <div class="attendance-panel attendance-panel-dark h-100">
                                    <div class="d-flex justify-content-between align-items-center mb-2 attendance-panel-actions">
                                        <div class="attendance-panel-title mb-0">Monthly (%)</div>
                                        <select id="attendanceDashboardMonth" class="form-select form-select-sm">
                                            <option value="0">January</option>
                                            <option value="1">February</option>
                                            <option value="2">March</option>
                                            <option value="3">April</option>
                                            <option value="4">May</option>
                                            <option value="5">June</option>
                                            <option value="6">July</option>
                                            <option value="7">August</option>
                                            <option value="8">September</option>
                                            <option value="9">October</option>
                                            <option value="10">November</option>
                                            <option value="11">December</option>
                                        </select>
                                    </div>
                                    <div class="attendance-chart">
                                        <canvas id="attendanceMonthlyPercentChart"></canvas>
                                    </div>
                                    <div class="attendance-percentage-value" id="attendanceMonthlyPercentValue">0%</div>
                                </div>
                            </div>
                        </div>
                        <div class="row g-4">
                            <div class="col-lg-8">
                                <div class="attendance-panel h-100">
                                    <div class="attendance-panel-title">Monthly Attendance Breakdown</div>
                                    <div class="attendance-panel-subtitle mb-3">Understand presence, absences and leave trends month-by-month.</div>
                                    <div class="attendance-chart small">
                                        <canvas id="attendanceMonthlyPresentChart"></canvas>
                                    </div>
                                    <div class="attendance-chart small">
                                        <canvas id="attendanceMonthlyAbsentChart"></canvas>
                                    </div>
                                    <div class="attendance-chart small">
                                        <canvas id="attendanceMonthlyLeavesChart"></canvas>
                                    </div>
                                </div>
                            </div>
                            <div class="col-lg-4">
                                <div class="d-flex flex-column gap-3 h-100">
                                    <div class="attendance-panel attendance-panel--auto-height">
                                        <div class="attendance-panel-title">Punctuality Recognition</div>
                                        <div class="attendance-panel-subtitle mb-3">Celebrate our most punctual teammates across flexible timeframes.</div>
                                        <div class="attendance-recognition-controls">
                                            <div class="attendance-recognition-period" id="attendanceRecognitionPeriodLabel">Year-to-date leaders  Loading</div>
                                            <div class="attendance-recognition-filters" role="group" aria-label="Filter recognition period">
                                                <button type="button" class="attendance-recognition-filter" data-recognition-period="weekly" aria-pressed="false">Weekly</button>
                                                <button type="button" class="attendance-recognition-filter" data-recognition-period="biWeekly" aria-pressed="false">Bi-Weekly</button>
                                                <button type="button" class="attendance-recognition-filter" data-recognition-period="monthly" aria-pressed="false">Monthly</button>
                                                <button type="button" class="attendance-recognition-filter" data-recognition-period="quarterly" aria-pressed="false">Quarterly</button>
                                                <button type="button" class="attendance-recognition-filter active" data-recognition-period="yearly" aria-pressed="true">Yearly</button>
                                            </div>
                                        </div>
                                        <div id="attendancePunctualRecognition" class="attendance-recognition">
                                            <div class="attendance-recognition-empty">
                                                <i class="fas fa-medal"></i>
                                                Recognition updates as attendance is recorded.
                                            </div>
                                        </div>
                                    </div>
                                    <div class="attendance-panel flex-grow-1 d-flex flex-column">
                                        <div class="attendance-panel-title">Bi-Weekly Attendance</div>
                                        <div class="attendance-panel-subtitle mb-3">Quickly spot cycle dips in punctuality.</div>
                                        <div class="attendance-chart flex-grow-1">
                                            <canvas id="attendanceBiWeeklyChart"></canvas>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row g-4">
                            <div class="col-xl-8">
                                <div class="attendance-panel h-100">
                                    <div class="attendance-panel-title">Monthly Analysis</div>
                                    <div class="attendance-panel-subtitle mb-3">Stacked distribution of all attendance categories across the year.</div>
                                    <div class="attendance-chart tall">
                                        <canvas id="attendanceMonthlyAnalysisChart"></canvas>
                                    </div>
                                </div>
                            </div>
                            <div class="col-xl-4">
                                <div class="attendance-panel h-100">
                                    <div class="attendance-panel-title">Yearly Analysis</div>
                                    <div class="attendance-panel-subtitle mb-3">Overall category contribution for the current year.</div>
                                    <div class="attendance-chart">
                                        <canvas id="attendanceYearlyAnalysisChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Schedule Generation Tab -->
        <div class="tab-pane fade" id="generation" role="tabpanel">
            <div class="row g-4">
                <div class="col-lg-8">
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-calendar-plus text-primary"></i>
                                Generate New Schedules
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <form id="scheduleGenerationForm">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <label class="form-label-modern">Start Date</label>
                                        <input type="date" class="form-control form-control-modern" id="scheduleStartDate" required>
                                    </div>
                                    <div class="col-md-6">
                                        <label class="form-label-modern">End Date</label>
                                        <input type="date" class="form-control form-control-modern" id="scheduleEndDate" required>
                                    </div>
                                    <!-- /partials/schedule-form.html -->
                                    <div class="row g-3">
                                        <div class="col-12 col-md-6">
                                            <label class="form-label-modern">Select Team Members</label>
                                            <select class="form-select form-control-modern w-100" id="scheduleUsers" multiple size="6">
                                                <option disabled>Loading users...</option>
                                            </select>
                                            <small class="text-muted">Hold Ctrl/Cmd to select multiple. Leave empty for all users.</small>
                                        </div>

                                        <div class="col-12 col-md-6">
                                            <label class="form-label-modern">Select Shift Slots</label>
                                            <select class="form-select form-control-modern w-100" id="scheduleShiftSlots" multiple size="6">
                                                <option disabled>Loading shift slots...</option>
                                            </select>
                                            <small class="text-muted">Hold Ctrl/Cmd to select multiple. Leave empty to use all available slots.</small>
                                        </div>
                                    </div>

                                    <div class="col-md-6">
                                        <label class="form-label-modern">Campaign Filter</label>
                                        <select class="form-select form-control-modern" id="campaignFilter">
                                            <option value="">All Campaigns</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6">
                                        <label class="form-label-modern">Priority Level</label>
                                        <select class="form-select form-control-modern" id="schedulePriority">
                                            <option value="1">Low</option>
                                            <option value="2" selected>Normal</option>
                                            <option value="3">High</option>
                                            <option value="4">Critical</option>
                                        </select>
                                    </div>
                                    
                                    <div class="col-md-6">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="detectConflicts" checked>
                                            <label class="form-check-label form-label-modern">Auto-detect conflicts</label>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="includeHolidays">
                                            <label class="form-check-label form-label-modern">Include holidays</label>
                                        </div>
                                    </div>
                                </div>

                                <div class="modern-divider my-3"></div>

                                <div class="row g-3">
                                    <div class="col-md-4">
                                        <label class="form-label-modern" for="generationMaxCapacity">Max capacity per slot</label>
                                        <input type="number" class="form-control form-control-modern" id="generationMaxCapacity" min="1" max="100" value="10">
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label-modern" for="generationMinCoverage">Minimum coverage</label>
                                        <input type="number" class="form-control form-control-modern" id="generationMinCoverage" min="1" value="3">
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label-modern" for="generationMinCoveragePct">Minimum coverage %</label>
                                        <input type="number" class="form-control form-control-modern" id="generationMinCoveragePct" min="0" max="100" value="70">
                                    </div>
                                </div>

                                <div class="modern-divider my-3"></div>

                                <div class="row g-3 align-items-end">
                                    <div class="col-md-3">
                                        <label class="form-label-modern" for="generationBreak1Duration">Break 1 (minutes)</label>
                                        <input type="number" class="form-control form-control-modern" id="generationBreak1Duration" min="5" max="30" value="15">
                                    </div>
                                    <div class="col-md-3">
                                        <label class="form-label-modern" for="generationBreak2Duration">Break 2 (minutes)</label>
                                        <input type="number" class="form-control form-control-modern" id="generationBreak2Duration" min="0" max="30" value="15">
                                    </div>
                                    <div class="col-md-3">
                                        <label class="form-label-modern" for="generationLunchDuration">Lunch (minutes)</label>
                                        <input type="number" class="form-control form-control-modern" id="generationLunchDuration" min="15" max="60" value="30">
                                    </div>
                                    <div class="col-md-3">
                                        <label class="form-label-modern" for="generationBreakDuration">Unproductive total (minutes)</label>
                                        <input type="number" class="form-control form-control-modern" id="generationBreakDuration" value="60" readonly>
                                        <small class="text-muted">Calculated from break and lunch durations</small>
                                    </div>
                                </div>

                                <div class="form-check form-switch mt-3">
                                    <input class="form-check-input" type="checkbox" id="generationEnableStaggeredBreaks" checked>
                                    <label class="form-check-label form-label-modern" for="generationEnableStaggeredBreaks">Enable staggered breaks</label>
                                </div>

                                <div id="generationStaggeredConfig" class="mt-2">
                                    <div class="row g-3">
                                        <div class="col-md-6">
                                            <label class="form-label-modern" for="generationBreakGroups">Break groups</label>
                                            <input type="number" class="form-control form-control-modern" id="generationBreakGroups" min="2" max="10" value="3">
                                        </div>
                                        <div class="col-md-6">
                                            <label class="form-label-modern" for="generationStaggerInterval">Stagger interval (minutes)</label>
                                            <input type="number" class="form-control form-control-modern" id="generationStaggerInterval" min="5" max="60" value="15">
                                        </div>
                                    </div>
                                </div>

                                <div class="modern-divider my-3"></div>

                                <div class="d-flex justify-content-between align-items-center">
                                    <h6 class="text-primary mb-0">Overtime configuration</h6>
                                    <div class="form-check form-switch mb-0">
                                        <input class="form-check-input" type="checkbox" id="generationEnableOvertime">
                                        <label class="form-check-label form-label-modern" for="generationEnableOvertime">Enable overtime</label>
                                    </div>
                                </div>

                                <div id="generationOvertimeConfig" class="row g-3 mt-1">
                                    <div class="col-md-3">
                                        <label class="form-label-modern" for="generationMaxDailyOT">Max daily OT (hours)</label>
                                        <input type="number" step="0.5" class="form-control form-control-modern" id="generationMaxDailyOT" min="0" value="2">
                                    </div>
                                    <div class="col-md-3">
                                        <label class="form-label-modern" for="generationMaxWeeklyOT">Max weekly OT (hours)</label>
                                        <input type="number" step="0.5" class="form-control form-control-modern" id="generationMaxWeeklyOT" min="0" value="10">
                                    </div>
                                    <div class="col-md-3">
                                        <label class="form-label-modern" for="generationOTApproval">OT approval</label>
                                        <select class="form-select form-control-modern" id="generationOTApproval">
                                            <option value="supervisor">Supervisor</option>
                                            <option value="manager">Manager</option>
                                            <option value="wfm">WFM</option>
                                        </select>
                                    </div>
                                    <div class="col-md-3">
                                        <label class="form-label-modern" for="generationOTRate">OT rate multiplier</label>
                                        <input type="number" step="0.1" class="form-control form-control-modern" id="generationOTRate" min="1" value="1.5">
                                    </div>
                                    <div class="col-12">
                                        <label class="form-label-modern" for="generationOTPolicy">Overtime policy</label>
                                        <input type="text" class="form-control form-control-modern" id="generationOTPolicy" placeholder="e.g., Approved overtime only">
                                    </div>
                                </div>

                                <div class="modern-divider my-3"></div>

                                <div class="row g-3">
                                    <div class="col-md-3">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="generationAllowSwaps" checked>
                                            <label class="form-check-label form-label-modern" for="generationAllowSwaps">Allow shift swaps</label>
                                        </div>
                                    </div>
                                    <div class="col-md-3">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="generationWeekendPremium">
                                            <label class="form-check-label form-label-modern" for="generationWeekendPremium">Apply weekend premium</label>
                                        </div>
                                    </div>
                                    <div class="col-md-3">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="generationHolidayPremium" checked>
                                            <label class="form-check-label form-label-modern" for="generationHolidayPremium">Apply holiday premium</label>
                                        </div>
                                    </div>
                                    <div class="col-md-3">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="generationAutoAssignment">
                                            <label class="form-check-label form-label-modern" for="generationAutoAssignment">Enable auto assignment</label>
                                        </div>
                                    </div>
                                </div>

                                <div class="row g-3 mt-1">
                                    <div class="col-md-4">
                                        <label class="form-label-modern" for="generationRestPeriod">Rest period (hours)</label>
                                        <input type="number" class="form-control form-control-modern" id="generationRestPeriod" min="0" value="8">
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label-modern" for="generationNotificationLead">Notification lead (hours)</label>
                                        <input type="number" class="form-control form-control-modern" id="generationNotificationLead" min="0" value="24">
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label-modern" for="generationHandoverTime">Handover time (minutes)</label>
                                        <input type="number" class="form-control form-control-modern" id="generationHandoverTime" min="0" value="15">
                                    </div>
                                </div>

                                <div class="form-check form-switch mt-3">
                                    <input class="form-check-input" type="checkbox" id="generationIsActive" checked>
                                    <label class="form-check-label form-label-modern" for="generationIsActive">Mark assignments as active</label>
                                </div>

                                <div class="mt-4 d-flex gap-3">
                                    <button type="submit" class="btn btn-primary-modern btn-modern flex-fill">
                                        <i class="fas fa-magic"></i>
                                        Generate Schedules
                                    </button>
                                    <button type="button" class="btn btn-outline-modern btn-modern" onclick="previewSchedules()">
                                        <i class="fas fa-eye"></i>
                                        Preview
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>

                <div class="col-lg-4">
                    <div class="modern-card mb-4">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-bolt text-warning"></i>
                                Quick Actions
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div class="d-grid gap-3">
                                <button class="btn btn-primary-modern btn-modern" onclick="generateThisWeek()">
                                    <i class="fas fa-calendar-week"></i>
                                    This Week
                                </button>
                                <button class="btn btn-success-modern btn-modern" onclick="generateNextWeek()">
                                    <i class="fas fa-calendar-alt"></i>
                                    Next Week
                                </button>
                                <button class="btn btn-warning-modern btn-modern" onclick="bulkApproveSchedules()">
                                    <i class="fas fa-check-double"></i>
                                    Bulk Approve
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-info-circle text-info"></i>
                                Status
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div id="generationStatus">
                                <p class="text-muted mb-0">Ready to generate schedules. Select your parameters and click Generate.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="generationResults" class="mt-4 d-none"></div>
        </div>

        <!-- Schedule Management Tab -->
        <div class="tab-pane fade" id="management" role="tabpanel">
            <div class="modern-card">
                <div class="modern-card-header">
                    <h5 class="modern-card-title">
                        <i class="fas fa-tasks text-primary"></i>
                        Schedule Management
                    </h5>
                    <button class="btn btn-outline-modern btn-sm" onclick="refreshSchedules()">
                        <i class="fas fa-sync"></i>
                        Refresh
                    </button>
                </div>
                <div class="modern-card-body">
                    <!-- Filters -->
                    <div class="row g-3 mb-4">
                        <div class="col-md-2">
                            <label class="form-label-modern">Start Date</label>
                            <input type="date" class="form-control form-control-modern" id="filterStartDate">
                        </div>
                        <div class="col-md-2">
                            <label class="form-label-modern">End Date</label>
                            <input type="date" class="form-control form-control-modern" id="filterEndDate">
                        </div>
                        <div class="col-md-2">
                            <label class="form-label-modern">User</label>
                            <select class="form-select form-control-modern" id="filterUser">
                                <option value="">All Users</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label-modern">Status</label>
                            <select class="form-select form-control-modern" id="filterStatus">
                                <option value="">All Status</option>
                                <option value="PENDING">Pending</option>
                                <option value="APPROVED">Approved</option>
                                <option value="REJECTED">Rejected</option>
                            </select>
                        </div>
                        <div class="col-md-2 d-flex align-items-end">
                            <button class="btn btn-primary-modern btn-modern w-100" onclick="applyScheduleFilters()">
                                <i class="fas fa-filter"></i>
                                Apply
                            </button>
                        </div>
                    </div>

                    <!-- Schedules Table -->
                    <div class="table-responsive">
                        <table class="table table-modern">
                            <thead>
                            <tr>
                                <th width="50">
                                    <input type="checkbox" id="selectAllSchedules" class="form-check-input">
                                </th>
                                <th>User</th>
                                <th>Period</th>
                                <th>Shift</th>
                                <th>Times</th>
                                <th>Status</th>
                                <th>Priority</th>
                                <th>Actions</th>
                            </tr>
                            </thead>
                            <tbody id="schedulesTableBody">
                            <tr>
                                <td colspan="8" class="text-center text-muted py-4">
                                    <div class="loading-spinner mx-auto mb-2"></div>
                                    <p>Loading schedules...</p>
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Manual Shift Assignment Tab -->
        <div class="tab-pane fade" id="import" role="tabpanel">
            <div class="manual-shift-tab">
                <div class="manual-shift-header text-center">
                    <h2 class="manual-shift-title">Manual Shift Slot Assignment</h2>
                    <p class="manual-shift-subtitle">
                        Choose a shift slot, define the coverage window, and assign one or more agents to that slot. Optional notes help
                        document the reason or context for the assignment.
                    </p>
                </div>

                <div id="feedbackArea"></div>

                <form id="manualShiftForm" novalidate>
                    <div class="row g-4">
                        <div class="col-lg-6">
                            <div class="modern-card h-100">
                                <div class="modern-card-header">
                                    <h5 class="modern-card-title mb-0 d-flex align-items-center gap-2">
                                        <i class="fas fa-calendar-plus text-primary"></i>
                                        Shift Details
                                    </h5>
                                </div>
                                <div class="modern-card-body">
                                    <div class="mb-3">
                                        <label class="form-label-modern" for="manualShiftSlot">Shift Slot</label>
                                        <select class="form-select form-select-modern" id="manualShiftSlot" required>
                                            <option value="" disabled selected>Select a shift slot</option>
                                        </select>
                                        <small class="text-muted">Shift slots are sourced from the Shifts tab.</small>
                                    </div>
                                    <div class="row g-3">
                                        <div class="col-md-6">
                                            <label class="form-label-modern" for="startDate">Start Date</label>
                                            <input type="date" class="form-control-modern w-100" id="startDate" min="2023-01-01" required>
                                            <small class="text-muted">Assignments can begin as early as January 2023.</small>
                                        </div>
                                        <div class="col-md-6">
                                            <label class="form-label-modern" for="endDate">End Date</label>
                                            <input type="date" class="form-control-modern w-100" id="endDate" min="2023-01-01" required>
                                            <small class="text-muted">End date must be on or after the start date.</small>
                                        </div>
                                    </div>
                                    <div class="mt-3">
                                        <label class="form-label-modern" for="additionalNotes">Additional Notes</label>
                                        <textarea class="form-textarea-modern w-100" id="additionalNotes" rows="4" placeholder="Add context for this assignment"></textarea>
                                    </div>
                                    <div class="form-check mt-3">
                                        <input class="form-check-input" type="checkbox" id="replaceExisting">
                                        <label class="form-check-label" for="replaceExisting">
                                            Replace existing shift assignments within the selected range for chosen users
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-lg-6">
                            <div class="modern-card user-selection-card h-100">
                                <div class="modern-card-header">
                                    <h5 class="modern-card-title mb-0 d-flex align-items-center gap-2">
                                        <i class="fas fa-user-clock text-success"></i>
                                        Select Users
                                    </h5>
                                </div>
                                <div class="modern-card-body d-flex flex-column">
                                    <div class="user-search-box">
                                        <i class="fas fa-search"></i>
                                        <input type="search" class="form-control-modern user-search-input" id="userSearch" placeholder="Search by name or email" autocomplete="off">
                                    </div>
                                    <div class="user-selection-controls">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="selectAllUsers">
                                            <label class="form-check-label" for="selectAllUsers">Select all filtered users</label>
                                        </div>
                                        <div class="user-count-label">
                                            <span id="selectedUserCount">0</span> / <span id="totalUserCount">0</span> selected
                                        </div>
                                    </div>
                                    <div class="user-list" id="userList">
                                        <div class="user-loading-state" id="userLoadingState">
                                            <span class="loading-spinner"></span>
                                            <span>Loading available users...</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="modern-card mt-4">
                        <div class="modern-card-body form-footer-actions">
                            <div class="d-flex flex-column gap-2">
                                <div class="fw-semibold text-dark">Assignment Summary</div>
                                <ul class="manual-help-list text-muted small">
                                    <li>Select a shift slot and date range to define the assignment window.</li>
                                    <li>Choose one or more agents to assign to the selected shift slot.</li>
                                    <li>Enable replace to archive overlapping assignments for the chosen users during the range.</li>
                                </ul>
                            </div>
                            <div class="d-flex flex-wrap gap-2">
                                <button type="button" class="btn btn-outline-modern" id="clearSelection">
                                    <i class="fas fa-user-slash"></i>
                                    Clear Selection
                                </button>
                                <button type="submit" class="btn btn-success-modern btn-modern" id="submitManualShift">
                                    <i class="fas fa-user-plus"></i>
                                    Assign Shift Slot
                                </button>
                            </div>
                        </div>
                    </div>
                </form>

                <div class="modern-card mt-4">
                    <div class="modern-card-header">
                        <h5 class="modern-card-title mb-0 d-flex align-items-center gap-2">
                            <i class="fas fa-info-circle text-info"></i>
                            Helpful Tips
                        </h5>
                    </div>
                    <div class="modern-card-body">
                        <ul class="manual-help-list text-muted">
                            <li>Shift slot availability is shared with the Generate tab. Create slots there first if none appear.</li>
                            <li>Replace existing archives conflicting assignments for the selected users in the chosen range.</li>
                            <li>Recent manual activity is tracked below for quick confirmation and auditing.</li>
                        </ul>
                    </div>
                </div>

                <div class="modern-card mt-4">
                    <div class="modern-card-header">
                        <h5 class="modern-card-title mb-0 d-flex align-items-center gap-2">
                            <i class="fas fa-history text-primary"></i>
                            Recent Manual Assignments
                        </h5>
                    </div>
                    <div class="modern-card-body">
                        <div id="activityLog" class="activity-log">
                            <div id="activityEmptyState" class="manual-activity-empty">
                                <i class="far fa-calendar-check me-2"></i>No manual assignments recorded yet.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Attendance Calendar Tab -->
        <div class="tab-pane fade" id="attendance" role="tabpanel">
            <div class="modern-card mb-4">
                <div class="modern-card-header">
                    <h5 class="modern-card-title">
                        <i class="fas fa-calendar-check text-success"></i>
                        Attendance Calendar
                    </h5>
                    <div class="d-flex gap-2 align-items-center">
                        <select class="form-select form-select-sm" id="attendanceMonth" style="width: auto;">
                            <option value="1">January</option>
                            <option value="2">February</option>
                            <option value="3">March</option>
                            <option value="4">April</option>
                            <option value="5">May</option>
                            <option value="6">June</option>
                            <option value="7">July</option>
                            <option value="8">August</option>
                            <option value="9">September</option>
                            <option value="10">October</option>
                            <option value="11">November</option>
                            <option value="12">December</option>
                        </select>
                        <select class="form-select form-select-sm" id="attendanceYear" style="width: auto;">
                            <option value="2024">2024</option>
                            <option value="2025" selected>2025</option>
                            <option value="2026">2026</option>
                        </select>
                        <button class="btn btn-outline-modern btn-sm" onclick="loadAttendanceCalendar()">
                            <i class="fas fa-sync"></i>
                            Load
                        </button>
                        <button class="btn btn-success-modern btn-sm" onclick="markBulkAttendance()">
                            <i class="fas fa-users"></i>
                            Bulk Mark
                        </button>
                    </div>
                </div>
                <div class="modern-card-body p-0">
                    <div id="attendanceCalendarContainer">
                        <div class="text-center py-5">
                            <div class="loading-spinner mx-auto mb-3"></div>
                            <p class="text-muted">Loading attendance calendar...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status Legend -->
            <div class="modern-card">
                <div class="modern-card-header">
                    <h5 class="modern-card-title">
                        <i class="fas fa-info-circle text-info"></i>
                        Status Legend & Actions
                    </h5>
                </div>
                <div class="modern-card-body">
                    <div class="row align-items-start g-3">
                        <div class="col-lg-8">
                            <div id="attendanceStatusLegendCard" class="attendance-calendar__legend">
                                <div class="text-muted small">Attendance status legend will appear here.</div>
                            </div>
                        </div>
                        <div class="col-lg-4">
                            <div class="d-grid gap-2">
                                <button class="btn btn-primary-modern btn-modern" onclick="quickMarkAttendance()">
                                    <i class="fas fa-plus"></i>
                                    Quick Mark
                                </button>
                                <button class="btn btn-outline-modern btn-modern" onclick="exportAttendanceReport()">
                                    <i class="fas fa-download"></i>
                                    Export Report
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Shift Slots Tab -->
        <div class="tab-pane fade" id="shifts" role="tabpanel">
            <div class="row g-4">
                <div class="col-lg-8">
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-plus text-success"></i>
                                Create Enhanced Shift Slot
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <form id="shiftSlotForm">
                                <!-- Basic Information -->
                                <div class="mb-4">
                                    <h6 class="text-primary mb-3">
                                        <i class="fas fa-info-circle me-2"></i>Basic Information
                                    </h6>
                                    <div class="row g-3">
                                        <div class="col-12">
                                            <label class="form-label-modern">Slot Name</label>
                                            <input type="text" class="form-control form-control-modern" id="slotName" required placeholder="e.g., Morning Customer Service Shift">
                                        </div>
                                        <div class="col-md-6">
                                            <label class="form-label-modern">Start Time</label>
                                            <input type="time" class="form-control form-control-modern" id="slotStartTime" required>
                                        </div>
                                        <div class="col-md-6">
                                            <label class="form-label-modern">End Time</label>
                                            <input type="time" class="form-control form-control-modern" id="slotEndTime" required>
                                        </div>
                                        <div class="col-12">
                                            <label class="form-label-modern">Days of Week</label>
                                            <div class="days-selector">
                                                <div class="day-checkbox">
                                                    <input type="checkbox" id="monday" value="1" checked>
                                                    <label for="monday">Mon</label>
                                                </div>
                                                <div class="day-checkbox">
                                                    <input type="checkbox" id="tuesday" value="2" checked>
                                                    <label for="tuesday">Tue</label>
                                                </div>
                                                <div class="day-checkbox">
                                                    <input type="checkbox" id="wednesday" value="3" checked>
                                                    <label for="wednesday">Wed</label>
                                                </div>
                                                <div class="day-checkbox">
                                                    <input type="checkbox" id="thursday" value="4" checked>
                                                    <label for="thursday">Thu</label>
                                                </div>
                                                <div class="day-checkbox">
                                                    <input type="checkbox" id="friday" value="5" checked>
                                                    <label for="friday">Fri</label>
                                                </div>
                                                <div class="day-checkbox">
                                                    <input type="checkbox" id="saturday" value="6">
                                                    <label for="saturday">Sat</label>
                                                </div>
                                                <div class="day-checkbox">
                                                    <input type="checkbox" id="sunday" value="0">
                                                    <label for="sunday">Sun</label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <label class="form-label-modern">Department</label>
                                            <select class="form-select form-control-modern" id="slotDepartment">
                                                <option value="">Select Department (Campaign)</option>
                                                <!-- Campaigns will be loaded here dynamically -->
                                            </select>
                                            <small class="text-muted">Departments are populated from available campaigns</small>
                                        </div>
                                        <div class="col-md-6">
                                            <label class="form-label-modern">Location</label>
                                            <select class="form-select form-control-modern" id="slotLocation">
                                                <option value="">Select Location</option>
                                                <option value="Office">Office</option>
                                                <option value="Remote">Remote</option>
                                                <option value="Hybrid">Hybrid</option>
                                                <option value="Client Site">Client Site</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <!-- Description -->
                                <div class="mb-4">
                                    <label class="form-label-modern" for="slotDescription">Description &amp; Notes</label>
                                    <textarea
                                            class="form-control form-control-modern"
                                            id="slotDescription"
                                            rows="3"
                                            placeholder="Optional description, special instructions, or notes for this shift slot..."
                                    ></textarea>
                                </div>


                                <div class="d-flex gap-3">
                                    <button type="submit" class="btn btn-success-modern btn-modern flex-fill">
                                        <i class="fas fa-save"></i>
                                        Create Enhanced Shift Slot
                                    </button>
                                    <button type="button" class="btn btn-outline-modern btn-modern" onclick="previewShiftSlot()">
                                        <i class="fas fa-eye"></i>
                                        Preview
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>

                <div class="col-lg-4">
                    <div class="modern-card mb-4">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-list text-primary"></i>
                                Existing Shift Slots
                            </h5>
                            <button class="btn btn-outline-modern btn-sm" onclick="refreshShiftSlots()">
                                <i class="fas fa-sync"></i>
                                Refresh
                            </button>
                        </div>
                        <div class="modern-card-body">
                            <div id="shiftSlotsContainer">
                                <div class="text-center py-4">
                                    <div class="loading-spinner mx-auto mb-3"></div>
                                    <p class="text-muted">Loading shift slots...</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quick Actions -->
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-bolt text-warning"></i>
                                Quick Actions
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div class="d-grid gap-2">
                                <button class="btn btn-primary-modern btn-modern" onclick="createDefaultShifts()">
                                    <i class="fas fa-magic"></i>
                                    Create Default Shifts
                                </button>
                                <button class="btn btn-success-modern btn-modern" onclick="bulkEditShifts()">
                                    <i class="fas fa-edit"></i>
                                    Bulk Edit Shifts
                                </button>
                                <button class="btn btn-info btn-modern" onclick="exportShiftSchedule()">
                                    <i class="fas fa-download"></i>
                                    Export Schedule
                                </button>
                                <button class="btn btn-warning-modern btn-modern" onclick="validateShiftCoverage()">
                                    <i class="fas fa-shield-alt"></i>
                                    Validate Coverage
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Holidays Tab -->
        <div class="tab-pane fade" id="holidays" role="tabpanel">
            <div class="row g-4">
                <div class="col-lg-6">
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-globe text-primary"></i>
                                Import Holidays
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div class="alert alert-info-modern mb-4">
                                <i class="fas fa-flag me-2"></i>
                                <strong>Jamaica takes priority</strong> - Holidays from Jamaica will be applied first as the primary country.
                            </div>

                            <form id="holidayImportForm">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <label class="form-label-modern">Country</label>
                                        <select class="form-select form-control-modern" id="holidayCountry" required>
                                            <option value="">Select Country</option>
                                            <option value="JM"> Jamaica (Primary)</option>
                                            <option value="US"> United States</option>
                                            <option value="DO"> Dominican Republic</option>
                                            <option value="PH"> Philippines</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6">
                                        <label class="form-label-modern">Year</label>
                                        <select class="form-select form-control-modern" id="holidayYear" required>
                                            <option value="2024">2024</option>
                                            <option value="2025" selected>2025</option>
                                            <option value="2026">2026</option>
                                        </select>
                                    </div>
                                    <div class="col-12">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="applyPaidStatus" checked>
                                            <label class="form-check-label form-label-modern">Apply paid status for users from this country</label>
                                        </div>
                                    </div>
                                </div>




                                <div class="mt-4 d-flex gap-3">
                                    <button type="button" class="btn btn-outline-modern btn-modern" onclick="previewHolidays()">
                                        <i class="fas fa-eye"></i>
                                        Preview
                                    </button>
                                    <button type="submit" class="btn btn-success-modern btn-modern">
                                        <i class="fas fa-download"></i>
                                        Import Holidays
                                    </button>
                                </div>
                            </form>

                            <div id="holidayPreview" class="mt-4 d-none"></div>
                        </div>
                    </div>
                </div>

                <div class="col-lg-6">
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-calendar-day text-info"></i>
                                Current Holidays
                            </h5>
                            <button class="btn btn-outline-modern btn-sm" onclick="refreshHolidays()">
                                <i class="fas fa-sync"></i>
                                Refresh
                            </button>
                        </div>
                        <div class="modern-card-body">
                            <div id="currentHolidays">
                                <div class="text-center py-4">
                                    <div class="loading-spinner mx-auto mb-3"></div>
                                    <p class="text-muted">Loading current holidays...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>

    <!-- Toast Container -->
    

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        (function initializeCurrentUserContext() {
            try {
                const injectedUser = <?!= currentUserJson || '{}' ?>;
                const existingUser = (typeof window !== 'undefined' && window.CURRENT_USER && Object.keys(window.CURRENT_USER).length)
                    ? window.CURRENT_USER
                    : null;

                const resolvedUser = existingUser && typeof existingUser === 'object' ? existingUser : injectedUser;

                if (typeof window !== 'undefined') {
                    window.CURRENT_USER = resolvedUser || {};
                    window.currentUser = window.currentUser && Object.keys(window.currentUser).length ? window.currentUser : window.CURRENT_USER;
                    window.user = window.user && Object.keys(window.user).length ? window.user : window.CURRENT_USER;
                }
            } catch (error) {
                console.warn('Unable to initialize current user context for schedule management:', error);
                if (typeof window !== 'undefined') {
                    window.CURRENT_USER = window.CURRENT_USER || {};
                }
            }
        })();
    </script>

    <script>
        // LUMINA Schedule Management System v4.0 - Modern UI Edition with Backend Integration
        class LuminaScheduleManager {
            constructor() {
                this.currentUser = window.user || window.currentUser || window.CURRENT_USER || {};
                this.availableUsers = [];
                this.availableCampaigns = [];
                this.coverageChart = null;
                this.pendingImportSchedules = [];
                this.pendingImportSummary = null;
                this.lastImportResult = null;
                this.cachedSchedules = [];
                this.cachedShiftSlots = [];
                this.resolvedManagerId = '';
                this.resolvedCampaignId = '';
                this.managedUserIds = [];
                this.managedUserIdSet = new Set();
                this.managedRosterSource = '';
                this.managedRosterUsers = [];
                this.rosterManagedUserIds = [];
                this.contextManagedUserIds = [];
                this.identityResolved = false;
                this.identitySummary = null;
                this.contextLoadingPromise = null;
                  this.manualShiftManager = null;
                  this.visibleManagedCount = 0;
                  this.latestPreviewState = null;
                  this.previewContextHash = '';
                  this.attendanceCharts = {};
                this.attendanceDashboardInitialized = false;
                this.attendanceDashboardResizeHandler = null;
                this.attendanceDashboardData = null;
                this.attendanceDashboardYear = null;
                this.attendanceDashboardRecords = [];
                this.attendanceDashboardUserFilter = '';
                this.attendanceRecognitionPeriod = 'yearly';
                this.attendanceRecognitionLeaders = {
                    weekly: { label: '', entries: [] },
                    biWeekly: { label: '', entries: [] },
                    monthly: { label: '', entries: [] },
                    quarterly: { label: '', entries: [] },
                    yearly: { label: '', entries: [] }
                };
                this.attendanceCalendarRecords = [];
                this.unifiedState = null;
                this.unifiedStateAppliedAt = null;
                this.attendanceCalendarPrefetch = null;
                this.attendanceDashboardPrefetch = null;
                this.holidayPrefetch = null;
                this.defaultHolidayCountries = ['JM', 'US', 'DO', 'PH'];
                this.managedRosterWarnings = [];
                this.schedulePrefetchRange = null;
                this.additionalUserSources = {};
                this.assignmentUserRecords = [];
                this.attendanceUserRecords = [];
                this.userSourceSummary = null;
                this.attendanceContextMenu = null;
                this.attendanceContextMenuTarget = null;
                this.attendanceContextMenuOutsideHandler = null;
                this.attendanceContextMenuKeyHandler = null;
                this.attendanceContextMenuFocusTimer = null;
                this.employmentStartFieldNames = [
                    'HireDate',
                    'hireDate',
                    'Hire_Date',
                    'hire_date',
                    'Hire Date',
                    'hire date',
                    'DateHired',
                    'dateHired',
                    'Date Hired',
                    'date hired',
                    'OnboardDate',
                    'onboardDate',
                    'Onboard Date',
                    'onboard date',
                    'EmploymentStart',
                    'employmentStart',
                    'Employment Start',
                    'employment start',
                    'EmploymentStartDate',
                    'employmentStartDate',
                    'Employment Start Date',
                    'employment start date',
                    'StartDate',
                    'startDate',
                    'Start Date',
                    'start date',
                    'Start_Date',
                    'start_date',
                    'OriginalHireDate',
                    'originalHireDate',
                    'Original_Hire_Date',
                    'original_hire_date',
                    'Original Hire Date',
                    'original hire date',
                    'RehireDate',
                    'rehireDate',
                    'Rehire_Date',
                    'rehire_date',
                    'Rehire Date',
                    'rehire date'
                ];
                this.employmentEndFieldNames = [
                    'TerminationDate',
                    'terminationDate',
                    'Termination Date',
                    'termination date',
                    'EndDate',
                    'endDate',
                    'End Date',
                    'end date',
                    'End_Date',
                    'end_date',
                    'EmploymentEnd',
                    'employmentEnd',
                    'Employment End',
                    'employment end',
                    'EmploymentEndDate',
                    'employmentEndDate',
                    'Employment End Date',
                    'employment end date',
                    'DateOfTermination',
                    'dateOfTermination',
                    'Date Of Termination',
                    'date of termination',
                    'Termination',
                    'termination',
                    'Termination_Date',
                    'termination_date',
                    'Termination Date',
                    'termination date',
                    'SeparationDate',
                    'separationDate',
                    'Separation Date',
                    'separation date',
                    'Separation_Date',
                    'separation_date',
                    'LastWorkingDate',
                    'lastWorkingDate',
                    'Last Working Date',
                    'last working date'
                ];
                this.attendanceStatusLegend = [
                    { code: 'P', label: 'Punctual', className: 'attendance-calendar__status--present' },
                    { code: 'B', label: 'Bereavement', className: 'attendance-calendar__status--bereavement' },
                    { code: 'A', label: 'Absent', className: 'attendance-calendar__status--absent' },
                    { code: 'L', label: 'Late', className: 'attendance-calendar__status--late' },
                    { code: 'NCNS', label: 'No Call No Show', className: 'attendance-calendar__status--ncns' },
                    { code: 'V', label: 'Vacation', className: 'attendance-calendar__status--vacation' },
                    { code: 'S', label: 'Sick Leave', className: 'attendance-calendar__status--sick' },
                    { code: 'LOA', label: 'Leave of Absence', className: 'attendance-calendar__status--loa' },
                    { code: 'PL', label: 'Personal Leave', className: 'attendance-calendar__status--personal' },
                    { code: 'T', label: 'Training', className: 'attendance-calendar__status--training' }
                ];
                this.attendanceStatusOptions = [
                    { value: 'Present', code: 'P', label: 'Punctual', description: 'On time and present', className: 'attendance-calendar__status--present' },
                    { value: 'Bereavement', code: 'B', label: 'Bereavement', description: 'Approved bereavement leave', className: 'attendance-calendar__status--bereavement' },
                    { value: 'Absent', code: 'A', label: 'Absent', description: 'Not scheduled or missed shift', className: 'attendance-calendar__status--absent' },
                    { value: 'Late', code: 'L', label: 'Late', description: 'Arrived late or tardy', className: 'attendance-calendar__status--late' },
                    { value: 'No Call No Show', code: 'NCNS', label: 'No Call No Show', description: 'No call and no show', className: 'attendance-calendar__status--ncns' },
                    { value: 'Vacation', code: 'V', label: 'Vacation', description: 'Approved vacation/PTO', className: 'attendance-calendar__status--vacation' },
                    { value: 'Sick Leave', code: 'S', label: 'Sick Leave', description: 'Out due to illness', className: 'attendance-calendar__status--sick' },
                    { value: 'Leave Of Absence', code: 'LOA', label: 'Leave Of Absence', description: 'Authorized leave of absence', className: 'attendance-calendar__status--loa' },
                    { value: 'Personal Leave', code: 'PL', label: 'Personal Leave', description: 'Approved personal leave', className: 'attendance-calendar__status--personal' },
                    { value: 'Training', code: 'T', label: 'Training', description: 'In training or workshop', className: 'attendance-calendar__status--training' }
                ];
                this.attendanceStatusBadges = {
                    empty: { code: '-', className: 'attendance-calendar__status--empty', label: 'Unmarked' },
                    present: { code: 'P', className: 'attendance-calendar__status--present', label: 'Punctual' },
                    bereavement: { code: 'B', className: 'attendance-calendar__status--bereavement', label: 'Bereavement' },
                    absent: { code: 'A', className: 'attendance-calendar__status--absent', label: 'Absent' },
                    late: { code: 'L', className: 'attendance-calendar__status--late', label: 'Late' },
                    ncns: { code: 'NCNS', className: 'attendance-calendar__status--ncns', label: 'No Call No Show' },
                    vacation: { code: 'V', className: 'attendance-calendar__status--vacation', label: 'Vacation' },
                    sick: { code: 'S', className: 'attendance-calendar__status--sick', label: 'Sick Leave' },
                    loa: { code: 'LOA', className: 'attendance-calendar__status--loa', label: 'Leave of Absence' },
                    personal: { code: 'PL', className: 'attendance-calendar__status--personal', label: 'Personal Leave' },
                    training: { code: 'T', className: 'attendance-calendar__status--training', label: 'Training' }
                };
                this.attendanceStatusBadgeIndex = new Map();
                const attendanceStatusAliases = {
                    present: ['P', 'Present', 'Punctual', 'On Time', 'On-Time', 'OnTime', 'Present On Time', 'Present On-Time'],
                    bereavement: ['B', 'Bereavement', 'Bereavement Leave', 'Funeral Leave', 'Funeral'],
                    absent: ['A', 'Absent', 'Absence', 'No Show', 'NoShow', 'Not Present'],
                    late: ['L', 'Late', 'Tardy', 'Arrived Late', 'Running Late'],
                    ncns: ['NCNS', 'No Call No Show', 'NoCallNoShow', 'No Call/No Show', 'No Call, No Show', 'No Call & No Show', 'No Call And No Show'],
                    vacation: ['V', 'Vacation', 'Vacation Day', 'VacationDay', 'PTO', 'Paid Time Off', 'PaidTimeOff'],
                    sick: ['S', 'Sick', 'Sick Leave', 'SickLeave', 'Sick Day', 'SickDay', 'Illness', 'Medical Leave', 'MedicalLeave'],
                    loa: ['LOA', 'Leave Of Absence', 'Leave of Absence', 'LeaveOfAbsence', 'Leave Absence'],
                    personal: ['PL', 'Personal Leave', 'PersonalLeave', 'Personal Day', 'PersonalDay', 'Personal Time', 'PersonalTime', 'Personal Time Off', 'PersonalTimeOff'],
                    training: ['T', 'Training', 'Training Day', 'TrainingDay', 'Training Session', 'TrainingSession', 'Workshop', 'Class']
                };
                Object.entries(attendanceStatusAliases).forEach(([key, values]) => {
                    const badge = this.attendanceStatusBadges[key];
                    if (!badge || !Array.isArray(values)) {
                        return;
                    }
                    values.forEach((alias) => {
                        const normalizedAlias = this.normalizeAttendanceStatusKey(alias);
                        if (normalizedAlias && !this.attendanceStatusBadgeIndex.has(normalizedAlias)) {
                            this.attendanceStatusBadgeIndex.set(normalizedAlias, badge);
                        }
                    });
                });

                const fallbackParseDateValue = (input) => {
                    if (!input) {
                        return null;
                    }

                    if (input instanceof Date) {
                        return isNaN(input.getTime()) ? null : new Date(input);
                    }

                    if (typeof input === 'number' && !Number.isNaN(input)) {
                        const fromNumber = new Date(input);
                        return isNaN(fromNumber.getTime()) ? null : fromNumber;
                    }

                    if (typeof input === 'object' && input.iso) {
                        return fallbackParseDateValue(input.iso);
                    }

                    if (typeof input === 'string') {
                        const normalized = input.trim();
                        if (!normalized) {
                            return null;
                        }

                        const fromString = new Date(normalized);
                        return isNaN(fromString.getTime()) ? null : fromString;
                    }

                    return null;
                };

                if (typeof this.parseDateValue === 'function') {
                    this.parseDateValue = this.parseDateValue.bind(this);
                } else {
                    this.parseDateValue = fallbackParseDateValue;
                }

                if (typeof this.resolveIsoDate === 'function') {
                    this.resolveIsoDate = this.resolveIsoDate.bind(this);
                }

                this.updateStatusLegendCard();
                this.init();
            }

            init() {
                console.log(' Initializing LUMINA Schedule Management v4.0 - Modern Edition');
                this.setDefaultDates();
                this.initEventListeners();
                this.loadInitialData();
                this.showWelcomeMessage();
            }

            async ensureScheduleContext(force = false) {
                if (this.contextLoadingPromise) {
                    return this.contextLoadingPromise;
                }

                if (this.identityResolved && !force && this.resolvedManagerId) {
                    return Promise.resolve();
                }

                const managerIdCandidate = this.getCurrentUserId();
                const campaignCandidate = this.getCurrentCampaignId();

                const loadContext = (async () => {
                    try {
                        const context = await this.callServerFunction('clientGetScheduleContext', managerIdCandidate || null, campaignCandidate || null);

                        if (context && context.success) {
                            this.identityResolved = !!(context.authenticated || (context.identity && context.identity.authenticated));
                            this.identitySummary = context.identity || null;

                            const resolvedManagerId = this.normalizeUserIdValue(context.managerId) || this.normalizeUserIdValue(context.providedManagerId);
                            if (resolvedManagerId) {
                                this.resolvedManagerId = resolvedManagerId;
                            }

                            const resolvedCampaignId = this.normalizeCampaignIdValue(context.campaignId);
                            if (resolvedCampaignId) {
                                this.resolvedCampaignId = resolvedCampaignId;
                            }

                            if (Array.isArray(context.managedUserIds)) {
                                this.managedUserIds = context.managedUserIds.slice();
                            } else {
                                this.managedUserIds = [];
                            }

                            this.managedUserIdSet = new Set(
                                this.managedUserIds
                                    .map(id => this.normalizeUserIdValue(id))
                                    .filter(Boolean)
                            );

                            if (this.resolvedManagerId && this.managedUserIdSet.has(this.resolvedManagerId)) {
                                this.managedUserIdSet.delete(this.resolvedManagerId);
                            }

                            if (context.user && typeof context.user === 'object') {
                                this.currentUser = Object.assign({}, this.currentUser || {}, context.user);
                            }
                        } else {
                            this.identityResolved = false;
                            this.managedUserIds = [];
                            this.managedUserIdSet = new Set();
                            this.visibleManagedCount = 0;
                        }
                    } catch (error) {
                        console.warn('Unable to resolve schedule identity context:', error);
                        this.identityResolved = false;
                        this.managedUserIds = [];
                        this.managedUserIdSet = new Set();
                        this.visibleManagedCount = 0;
                    }
                })();

                this.contextLoadingPromise = loadContext.then(() => {
                    this.contextLoadingPromise = null;
                }).catch(error => {
                    this.contextLoadingPromise = null;
                    throw error;
                });

                return this.contextLoadingPromise;
            }

            setDefaultDates() {
                const today = new Date();
                const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
                const monthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);

                document.getElementById('scheduleStartDate').valueAsDate = monthStart;
                document.getElementById('scheduleEndDate').valueAsDate = monthEnd;
                document.getElementById('filterStartDate').valueAsDate = monthStart;
                document.getElementById('filterEndDate').valueAsDate = monthEnd;
                document.getElementById('attendanceMonth').value = today.getMonth() + 1;
                document.getElementById('attendanceYear').value = today.getFullYear();

                const manualStartDateInput = document.getElementById('startDate');
                const manualEndDateInput = document.getElementById('endDate');
                if (manualStartDateInput && !manualStartDateInput.value) {
                    manualStartDateInput.valueAsDate = today;
                }
                if (manualEndDateInput && !manualEndDateInput.value) {
                    manualEndDateInput.valueAsDate = today;
                }
                if (manualStartDateInput && manualEndDateInput) {
                    manualEndDateInput.min = manualStartDateInput.value || manualEndDateInput.min;
                }
            }

            initEventListeners() {
                // Form submissions
                document.getElementById('scheduleGenerationForm')?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.generateSchedules();
                });

                document.getElementById('shiftSlotForm')?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.createShiftSlot();
                });

                document.getElementById('holidayImportForm')?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.importHolidays();
                });

                document.getElementById('attendanceMonth')?.addEventListener('change', async () => {
                    try {
                        await this.loadAttendanceCalendar();
                    } catch (error) {
                        console.error('Failed to refresh attendance data after month change:', error);
                    }
                });

                document.getElementById('attendanceYear')?.addEventListener('change', async () => {
                    try {
                        await this.loadAttendanceCalendar();
                    } catch (error) {
                        console.error('Failed to refresh attendance data after year change:', error);
                    }
                });

                // Tab change listeners
                document.querySelectorAll('[data-bs-toggle="pill"]').forEach(tab => {
                    tab.addEventListener('shown.bs.tab', (event) => {
                        const target = event.target.getAttribute('data-bs-target');
                        this.onTabChange(target);
                    });
                });

                // Enhanced shift slot form handlers
                this.initShiftSlotFormHandlers();
                this.initializeBreakDurationCalculator();

                window.addEventListener('resize', () => this.hideAttendanceContextMenu());
                document.addEventListener('scroll', () => this.hideAttendanceContextMenu(), true);

                console.log(' Event listeners initialized');
            }

            initShiftSlotFormHandlers() {
                const setupClassToggle = (toggleId, targetId, hiddenClass = 'd-none') => {
                    const toggle = document.getElementById(toggleId);
                    const target = document.getElementById(targetId);
                    if (!toggle || !target) {
                        return;
                    }

                    const applyToggle = () => {
                        target.classList.toggle(hiddenClass, !toggle.checked);
                    };

                    toggle.addEventListener('change', applyToggle);
                    applyToggle();
                };

                const setupDisplayToggle = (toggleId, targetId, displayMode = 'block') => {
                    const toggle = document.getElementById(toggleId);
                    const target = document.getElementById(targetId);
                    if (!toggle || !target) {
                        return;
                    }

                    const applyToggle = () => {
                        target.style.display = toggle.checked ? displayMode : 'none';
                    };

                    toggle.addEventListener('change', applyToggle);
                    applyToggle();
                };

                setupClassToggle('enableOvertime', 'overtimeConfig');
                setupClassToggle('generationEnableOvertime', 'generationOvertimeConfig');
                setupDisplayToggle('enableStaggeredBreaks', 'staggeredBreaksConfig');
                setupDisplayToggle('generationEnableStaggeredBreaks', 'generationStaggeredConfig');

                // Auto-calculate lunch timing based on shift duration
                const startTime = document.getElementById('slotStartTime');
                const endTime = document.getElementById('slotEndTime');

                [startTime, endTime].forEach(input => {
                    input?.addEventListener('change', this.calculateOptimalBreakTimes.bind(this));
                });
            }

            initializeBreakDurationCalculator() {
                const updateBreakDuration = () => {
                    const break1 = parseInt(document.getElementById('generationBreak1Duration')?.value, 10) || 0;
                    const break2 = parseInt(document.getElementById('generationBreak2Duration')?.value, 10) || 0;
                    const lunch = parseInt(document.getElementById('generationLunchDuration')?.value, 10) || 0;
                    const total = break1 + break2 + lunch;
                    const totalField = document.getElementById('generationBreakDuration');
                    if (totalField) {
                        totalField.value = total;
                    }
                };

                ['generationBreak1Duration', 'generationBreak2Duration', 'generationLunchDuration'].forEach(id => {
                    const element = document.getElementById(id);
                    if (!element) {
                        return;
                    }
                    element.addEventListener('change', updateBreakDuration);
                    element.addEventListener('input', updateBreakDuration);
                });

                updateBreakDuration();
            }

            async fetchUnifiedState() {
                const managerId = this.getCurrentUserId();
                const campaignId = this.getCurrentCampaignId();

                const scheduleStartCandidate = document.getElementById('filterStartDate')?.value
                    || document.getElementById('scheduleStartDate')?.value
                    || '';
                const scheduleEndCandidate = document.getElementById('filterEndDate')?.value
                    || document.getElementById('scheduleEndDate')?.value
                    || '';

                const monthInput = document.getElementById('attendanceMonth');
                const yearInput = document.getElementById('attendanceYear');
                const monthContext = this.resolveAttendanceMonthContext(
                    monthInput ? monthInput.value : '',
                    yearInput ? yearInput.value : ''
                );

                const holidayCountryInput = document.getElementById('holidayCountry');
                const holidayYearInput = document.getElementById('holidayYear');
                const resolvedHolidayCountry = this.resolveHolidayCountryCode(
                    holidayCountryInput ? holidayCountryInput.value : ''
                );
                const resolvedHolidayYear = this.resolveHolidayYear(
                    holidayYearInput ? holidayYearInput.value : ''
                );

                const payload = {
                    managerId,
                    campaignId,
                    scheduleStart: this.resolveIsoDate(scheduleStartCandidate),
                    scheduleEnd: this.resolveIsoDate(scheduleEndCandidate),
                    attendanceMonth: monthContext.month,
                    attendanceYear: monthContext.year,
                    attendanceStart: monthContext.startDate,
                    attendanceEnd: monthContext.endDate,
                    holidayCountry: resolvedHolidayCountry,
                    holidayYear: resolvedHolidayYear
                };

                return this.callServerFunction('clientGetScheduleUnifiedState', payload);
            }

            applyUnifiedState(state) {
                if (!state || state.success !== true) {
                    throw new Error(state && state.error ? state.error : 'Unified schedule state unavailable');
                }

                this.unifiedState = Object.assign({}, state);
                this.unifiedStateAppliedAt = new Date();

                if (state.context && state.context.success) {
                    this.identityResolved = !!(state.context.authenticated
                        || (state.context.identity && state.context.identity.authenticated));
                    this.identitySummary = state.context.identity || null;

                    const resolvedManagerId = this.normalizeUserIdValue(state.context.managerId)
                        || this.normalizeUserIdValue(state.context.providedManagerId);
                    if (resolvedManagerId) {
                        this.resolvedManagerId = resolvedManagerId;
                    }

                    const resolvedCampaignId = this.normalizeCampaignIdValue(
                        state.context.campaignId || state.context.providedCampaignId
                    );
                    if (resolvedCampaignId) {
                        this.resolvedCampaignId = resolvedCampaignId;
                    }

                    if (state.context.user && typeof state.context.user === 'object') {
                        this.currentUser = Object.assign({}, this.currentUser || {}, state.context.user);
                    }

                    const managedIdsFromContext = Array.isArray(state.context.managedUserIds)
                        ? state.context.managedUserIds
                        : [];
                    this.managedUserIds = managedIdsFromContext.slice();
                    this.managedUserIdSet = new Set(
                        this.managedUserIds.map(id => this.normalizeUserIdValue(id)).filter(Boolean)
                    );
                    if (this.resolvedManagerId && this.managedUserIdSet.has(this.resolvedManagerId)) {
                        this.managedUserIdSet.delete(this.resolvedManagerId);
                    }
                }

                const scheduleUsers = state.users && Array.isArray(state.users.schedule)
                    ? state.users.schedule
                    : (state.users && Array.isArray(state.users.combined) ? state.users.combined : []);
                const rosterUsers = state.users && Array.isArray(state.users.roster)
                    ? state.users.roster
                    : [];

                const sourceUsers = {};
                if (state.users && Array.isArray(state.users.assignments) && state.users.assignments.length) {
                    sourceUsers.assignments = state.users.assignments;
                }
                if (state.users && Array.isArray(state.users.attendance) && state.users.attendance.length) {
                    sourceUsers.attendance = state.users.attendance;
                }

                this.applyUsersFromSources(scheduleUsers, rosterUsers, {
                    combinedUsers: state.users && Array.isArray(state.users.combined) ? state.users.combined : null,
                    rosterSource: state.users?.rosterSource || '',
                    warnings: state.users?.warnings || [],
                    managedUserIds: state.users?.managedUserIds || this.managedUserIds,
                    rosterManagedUserIds: state.users?.rosterManagedUserIds || [],
                    contextManagedUserIds: state.users?.contextManagedUserIds || [],
                    sourceUsers,
                    sourceSummary: state.users?.sources || null
                });

                if (state.schedule) {
                    this.schedulePrefetchRange = state.schedule.range || null;

                    if (Array.isArray(state.schedule.shiftSlots)) {
                        const { slots, metadata } = this.normalizeShiftSlotListResponse(state.schedule.shiftSlots);
                        this.cachedShiftSlots = slots;
                        this.updateShiftSlotSelectors(slots);
                        this.displayShiftSlots(slots);
                        if (this.manualShiftManager && typeof this.manualShiftManager.setShiftSlots === 'function') {
                            this.manualShiftManager.setShiftSlots(slots);
                        }
                        const totalSlotsElement = document.getElementById('totalSlots');
                        if (totalSlotsElement && metadata && typeof metadata.totalCount !== 'undefined') {
                            totalSlotsElement.textContent = metadata.totalCount;
                        }
                    }

                    if (state.schedule.assignments) {
                        const parsedAssignments = this.parseSchedulesResponse(state.schedule.assignments);
                        const schedules = Array.isArray(parsedAssignments.schedules) ? parsedAssignments.schedules : [];
                        this.cachedSchedules = schedules;
                        this.displaySchedules(schedules);
                        const totalElement = document.getElementById('totalSchedules');
                        if (totalElement) {
                            const numericTotal = Number(parsedAssignments.total);
                            totalElement.textContent = Number.isFinite(numericTotal) && numericTotal >= 0
                                ? numericTotal
                                : schedules.length;
                        }
                    }

                    if (state.schedule.dashboard) {
                        this.applyScheduleDashboard(state.schedule.dashboard);
                    }
                }

                if (state.attendance) {
                    this.attendanceCalendarPrefetch = {
                        range: state.attendance.range ? Object.assign({}, state.attendance.range) : null,
                        users: state.attendance.users || [],
                        monthlyRecords: Array.isArray(state.attendance.monthlyRecords)
                            ? state.attendance.monthlyRecords.slice()
                            : [],
                        yearlyRecords: Array.isArray(state.attendance.yearlyRecords)
                            ? state.attendance.yearlyRecords.slice()
                            : []
                    };

                    this.attendanceCalendarRecords = Array.isArray(this.attendanceCalendarPrefetch.monthlyRecords)
                        ? this.attendanceCalendarPrefetch.monthlyRecords.slice()
                        : [];

                    this.attendanceDashboardPrefetch = {
                        year: state.attendance.range ? state.attendance.range.year : null,
                        records: Array.isArray(state.attendance.yearlyRecords)
                            ? state.attendance.yearlyRecords.slice()
                            : [],
                        dashboard: state.attendance.dashboard || null
                    };

                    if (this.attendanceDashboardPrefetch.records.length && this.attendanceDashboardPrefetch.year) {
                        this.mergeAttendanceDashboardRecords(
                            this.attendanceDashboardPrefetch.records,
                            this.attendanceDashboardPrefetch.year
                        );
                    }

                    if (state.attendance.dashboard && state.attendance.dashboard.success) {
                        const year = this.attendanceDashboardPrefetch.year || this.getSelectedAttendanceYear();
                        this.attendanceDashboardYear = year;
                        this.attendanceDashboardRecords = this.attendanceDashboardPrefetch.records.slice();
                        const filteredRecords = this.filterAttendanceDashboardRecords(
                            this.attendanceDashboardRecords,
                            this.attendanceDashboardUserFilter
                        );
                        this.attendanceDashboardData = this.computeAttendanceDashboard(filteredRecords, year);
                        this.destroyAttendanceDashboardCharts();
                    }
                }

                if (state.holidays && state.holidays.success) {
                    this.holidayPrefetch = state.holidays;
                }
            }

            async loadInitialData() {
                let unifiedApplied = false;

                try {
                    this.showToast('Loading system data...', 'info');
                    const unifiedState = await this.fetchUnifiedState();
                    if (unifiedState && unifiedState.success) {
                        this.applyUnifiedState(unifiedState);
                        unifiedApplied = true;
                    } else {
                        throw new Error(unifiedState?.error || 'Unified state unavailable');
                    }
                } catch (error) {
                    console.warn('Unified state bootstrap failed. Falling back to legacy loaders.', error);
                }

                if (unifiedApplied) {
                    const activePane = document.querySelector('#mainTabContent .tab-pane.show.active');
                    if (activePane?.id === 'attendance') {
                        await this.loadAttendanceCalendar();
                    }
                    if (activePane?.id === 'attendance-dashboard') {
                        await this.loadAttendanceDashboard(false);
                    }
                    await this.refreshHolidays();
                    this.showToast('System ready! All data loaded successfully.', 'success');
                    console.log(' Unified system state loaded successfully');
                    return;
                }

                try {
                    await this.ensureScheduleContext();

                    await this.loadUsers();

                    await Promise.allSettled([
                        this.loadCampaigns(),
                        this.loadShiftSlots(),
                        this.loadSchedules(),
                        this.refreshDashboard()
                    ]);

                    const activePane = document.querySelector('#mainTabContent .tab-pane.show.active');
                    if (activePane?.id === 'attendance') {
                        await this.loadAttendanceCalendar();
                    }
                    if (activePane?.id === 'attendance-dashboard') {
                        await this.loadAttendanceDashboard(true);
                    }

                    await this.refreshHolidays();

                    this.showToast('System ready! All data loaded successfully.', 'success');
                    console.log(' Initial data loaded successfully (legacy path)');

                } catch (error) {
                    console.error(' Error loading initial data:', error);
                    this.showToast('Some system components failed to load. Please check system diagnostics.', 'danger');
                }
            }

            showWelcomeMessage() {
                setTimeout(() => {
                    this.showToast('Welcome to LUMINA Schedule Management v4.0! Modern UI Edition', 'success');
                }, 1500);
            }

            showToast(message, type = 'info') {
                if (typeof window.showLuminaToast === 'function') {
                    window.showLuminaToast(message, type);
                    return;
                }

                console.warn('Lumina toast system unavailable, falling back to browser alert.');
                window.alert(`[${String(type).toUpperCase()}] ${message}`);
            }

            showLoading(show, options = {}) {
                const loader = window.LuminaLoader;
                if (!loader) {
                    return;
                }

                if (show) {
                    loader.show(Object.assign({
                        title: 'Processing Schedule Request',
                        detail: 'Coordinating teams and calendars'
                    }, options));
                } else {
                    loader.hide();
                }
            }

            parseManagedRosterResponse(response) {
                const result = {
                    users: [],
                    recognized: false,
                    error: null
                };

                if (Array.isArray(response)) {
                    result.users = response.slice();
                    result.recognized = true;
                    return result;
                }

                if (response && typeof response === 'object') {
                    if (Array.isArray(response.users)) {
                        result.users = response.users.slice();
                        result.recognized = true;
                        if (response.success === false && response.error) {
                            result.error = response.error;
                        }
                        return result;
                    }

                    if (Array.isArray(response.managedUsers)) {
                        result.users = response.managedUsers.slice();
                        result.recognized = true;
                        if (response.success === false && response.error) {
                            result.error = response.error;
                        }
                        return result;
                    }

                    if (response.success === false && response.error) {
                        result.recognized = true;
                        result.error = response.error;
                        return result;
                    }
                }

                return result;
            }

            async fetchManagedRoster(managerId) {
                if (!managerId) {
                    console.warn(' Managed roster request skipped - missing manager identifier');
                    return { users: [], source: null, error: 'Missing manager ID', managedUserIds: [] };
                }

                const attempts = [
                    { functionName: 'clientGetManagedUsersList', label: 'ScheduleService roster endpoint' },
                    { functionName: 'clientGetManagedUsers', label: 'UserService roster endpoint' }
                ];

                for (let index = 0; index < attempts.length; index++) {
                    const attempt = attempts[index];
                    const isLastAttempt = index === attempts.length - 1;

                    try {
                        const response = await this.callServerFunction(attempt.functionName, managerId);
                        const parsed = this.parseManagedRosterResponse(response);

                        if (!parsed.recognized) {
                            continue;
                        }

                        if (parsed.error) {
                            console.warn(` ${attempt.label} responded with: ${parsed.error}`);
                            if (!isLastAttempt && parsed.users.length === 0) {
                                continue;
                            }
                        }

                        return {
                            users: Array.isArray(parsed.users) ? parsed.users : [],
                            source: attempt.functionName,
                            error: parsed.error || null,
                            managedUserIds: Array.isArray(parsed.users)
                                ? parsed.users
                                    .map(user => this.normalizeUserIdValue(user && (user.ID || user.UserID || user.id || user.userId)))
                                    .filter(Boolean)
                                : []
                        };
                    } catch (error) {
                        console.warn(` ${attempt.label} failed:`, error);
                        if (isLastAttempt) {
                            return {
                                users: [],
                                source: attempt.functionName,
                                error: error.message || String(error),
                                managedUserIds: []
                            };
                        }
                    }
                }

                return { users: [], source: null, error: null, managedUserIds: [] };
            }

            applyUsersFromSources(scheduleUsers, rosterUsers, options = {}) {
                const scheduleList = Array.isArray(scheduleUsers) ? scheduleUsers : [];
                const rosterList = Array.isArray(rosterUsers) ? rosterUsers : [];
                const combinedList = Array.isArray(options.combinedUsers) ? options.combinedUsers : [];

                if (Object.prototype.hasOwnProperty.call(options, 'rosterSource')) {
                    this.managedRosterSource = options.rosterSource || '';
                }

                if (options && typeof options.sourceSummary === 'object' && options.sourceSummary !== null && !Array.isArray(options.sourceSummary)) {
                    this.userSourceSummary = Object.assign({}, options.sourceSummary);
                } else {
                    this.userSourceSummary = null;
                }

                this.rosterManagedUserIds = Array.isArray(options.rosterManagedUserIds)
                    ? options.rosterManagedUserIds.map(id => this.normalizeUserIdValue(id)).filter(Boolean)
                    : [];
                this.contextManagedUserIds = Array.isArray(options.contextManagedUserIds)
                    ? options.contextManagedUserIds.map(id => this.normalizeUserIdValue(id)).filter(Boolean)
                    : [];

                this.managedRosterUsers = rosterList.slice();
                this.managedRosterWarnings = Array.isArray(options.warnings) ? options.warnings.slice() : [];

                if (Array.isArray(this.managedRosterWarnings) && this.managedRosterWarnings.length) {
                    this.managedRosterWarnings.forEach(warning => {
                        if (warning) {
                            console.warn(' Managed roster warning:', warning);
                        }
                    });
                }

                this.additionalUserSources = {};
                const extraCollections = [];
                if (options && options.sourceUsers && typeof options.sourceUsers === 'object') {
                    Object.entries(options.sourceUsers).forEach(([key, collection]) => {
                        if (!Array.isArray(collection) || !collection.length) {
                            return;
                        }
                        const sanitized = collection
                            .filter(item => item && typeof item === 'object')
                            .map(item => Object.assign({}, item));
                        if (!sanitized.length) {
                            return;
                        }
                        extraCollections.push(sanitized);
                        this.additionalUserSources[key] = sanitized.slice();
                    });
                }

                this.assignmentUserRecords = Array.isArray(this.additionalUserSources.assignments)
                    ? this.additionalUserSources.assignments.slice()
                    : [];
                this.attendanceUserRecords = Array.isArray(this.additionalUserSources.attendance)
                    ? this.additionalUserSources.attendance.slice()
                    : [];

                const userMap = new Map();
                const pushUserRecord = (user) => {
                    if (!user || typeof user !== 'object') {
                        return;
                    }

                    const normalizedId = this.normalizeUserIdValue(user.ID || user.UserID || user.id || user.userId);
                    const normalizedNameKey = this.normalizePersonKey(
                        user.UserName || user.username || user.FullName || user.fullName || ''
                    );
                    const normalizedEmailKey = this.normalizePersonKey(user.Email || user.email || '');

                    const key = normalizedId
                        ? `id:${normalizedId}`
                        : (normalizedNameKey ? `name:${normalizedNameKey}` : (normalizedEmailKey ? `email:${normalizedEmailKey}` : null));

                    if (!key) {
                        return;
                    }

                    const existing = userMap.get(key) || {};
                    const resolvedId = normalizedId
                        || existing.ID
                        || (normalizedNameKey ? `name:${normalizedNameKey}` : (normalizedEmailKey ? `email:${normalizedEmailKey}` : key));

                    const normalized = {
                        ID: resolvedId,
                        UserName: user.UserName || user.username || existing.UserName || existing.username || resolvedId,
                        FullName: user.FullName || user.fullName || existing.FullName || existing.fullName || user.UserName || existing.UserName || resolvedId,
                        Email: user.Email || user.email || existing.Email || '',
                        CampaignID: user.CampaignID || user.campaignID || user.campaignId || existing.CampaignID || '',
                        campaignName: user.campaignName || user.CampaignName || existing.campaignName || existing.CampaignName || '',
                        EmploymentStatus: user.EmploymentStatus || existing.EmploymentStatus || 'Active',
                        HireDate: user.HireDate || existing.HireDate || '',
                        TerminationDate: user.TerminationDate || user.terminationDate || existing.TerminationDate || '',
                        isActive: typeof user.isActive === 'boolean'
                            ? user.isActive
                            : (typeof existing.isActive === 'boolean' ? existing.isActive : true),
                        roleNames: Array.isArray(user.roleNames)
                            ? user.roleNames.slice()
                            : (Array.isArray(existing.roleNames) ? existing.roleNames.slice() : []),
                        syntheticId: normalizedId ? false : (existing.syntheticId === true || !normalizedId)
                    };

                    userMap.set(key, normalized);
                };

                const collections = [combinedList, scheduleList, rosterList].concat(extraCollections);
                collections
                    .filter(collection => Array.isArray(collection) && collection.length)
                    .forEach(collection => collection.forEach(pushUserRecord));

                this.availableUsers = Array.from(userMap.values())
                    .filter(user => user && user.ID && (user.FullName || user.UserName))
                    .sort((a, b) => {
                        const nameA = (a.FullName || a.UserName || '').toLowerCase();
                        const nameB = (b.FullName || b.UserName || '').toLowerCase();
                        return nameA.localeCompare(nameB);
                    });

                if (this.attendanceDashboardUserFilter) {
                    const normalizedFilterId = this.normalizeUserIdValue(this.attendanceDashboardUserFilter);
                    const normalizedFilterName = this.normalizePersonKey(normalizedFilterId);
                    const hasUser = this.availableUsers.some(user => {
                        const userId = this.normalizeUserIdValue(user.ID || user.UserID || user.id || user.userId || user.username);
                        if (userId && userId === normalizedFilterId) {
                            return true;
                        }
                        const nameKey = this.normalizePersonKey(user.FullName || user.UserName || '');
                        return normalizedFilterName && nameKey === normalizedFilterName;
                    });

                    if (!hasUser) {
                        this.attendanceDashboardUserFilter = '';
                    }
                }

                const manualManager = (this.manualShiftManager && typeof this.manualShiftManager.setUsers === 'function')
                    ? this.manualShiftManager
                    : (window.manualShiftManager && typeof window.manualShiftManager.setUsers === 'function'
                        ? window.manualShiftManager
                        : null);
                if (manualManager) {
                    const operationalUsers = this.availableUsers.filter(user => !user.syntheticId);
                    manualManager.setUsers(operationalUsers);
                }

                const currentUserId = this.normalizeUserIdValue(this.getCurrentUserId());
                const managedCandidateIds = Array.isArray(options.managedUserIds)
                    ? options.managedUserIds
                    : this.managedUserIds || [];

                const managedSet = new Set(
                    managedCandidateIds
                        .map(id => this.normalizeUserIdValue(id))
                        .filter(Boolean)
                );

                this.rosterManagedUserIds.forEach(id => {
                    if (id && id !== currentUserId) {
                        managedSet.add(id);
                    }
                });
                this.contextManagedUserIds.forEach(id => {
                    if (id && id !== currentUserId) {
                        managedSet.add(id);
                    }
                });

                const appendManagedFromUser = (user) => {
                    const managedId = this.normalizeUserIdValue(user && (user.ID || user.UserID || user.id || user.userId));
                    if (managedId && managedId !== currentUserId) {
                        managedSet.add(managedId);
                    }
                };

                rosterList.forEach(appendManagedFromUser);
                extraCollections.forEach(collection => collection.forEach(appendManagedFromUser));

                if (currentUserId && managedSet.has(currentUserId)) {
                    managedSet.delete(currentUserId);
                }

                this.managedUserIdSet = managedSet;
                this.managedUserIds = Array.from(managedSet);

                if (managedSet.size) {
                    const seen = new Set();
                    this.availableUsers.forEach(user => {
                        const userId = this.normalizeUserIdValue(user && (user.ID || user.UserID || user.id || user.userId));
                        if (userId && managedSet.has(userId)) {
                            seen.add(userId);
                        }
                    });
                    this.visibleManagedCount = seen.size;
                } else {
                    this.visibleManagedCount = this.availableUsers.filter(user => {
                        const userId = this.normalizeUserIdValue(user && (user.ID || user.UserID || user.id || user.userId));
                        return userId && userId !== currentUserId;
                    }).length || this.availableUsers.length;
                }

                this.updateUserDropdowns();
                this.updateUsersList();

                const totalUsersElement = document.getElementById('totalUsers');
                if (totalUsersElement) {
                    totalUsersElement.textContent = this.availableUsers.length;
                }

                const rosterSourceLabel = this.managedRosterSource
                    ? ` via ${this.managedRosterSource}`
                    : '';
                console.log(` Loaded ${this.availableUsers.length} users (including ${rosterList.length} managed roster entries${rosterSourceLabel})`);
                if (this.userSourceSummary) {
                    console.log(' User source contribution summary:', this.userSourceSummary);
                }
            }

            async loadUsers() {
                try {
                    console.log(' Loading users...');
                    await this.ensureScheduleContext();

                    const currentUserId = this.getCurrentUserId();
                    const campaignId = this.resolvedCampaignId || this.getCurrentCampaignId();
                    console.log(' Resolved manager context:', { managerId: currentUserId, campaignId: campaignId || '(all)' });

                    const scheduleUsers = await this.callServerFunction('clientGetScheduleUsers', currentUserId, campaignId || null);
                    const rosterResult = await this.fetchManagedRoster(currentUserId);
                    const rosterUsers = Array.isArray(rosterResult.users) ? rosterResult.users : [];

                    if (rosterResult.error && rosterUsers.length === 0) {
                        console.warn(' Managed roster fallback warning:', rosterResult.error);
                    }

                    this.applyUsersFromSources(scheduleUsers, rosterUsers, {
                        rosterSource: rosterResult.source || '',
                        warnings: rosterResult.error ? [rosterResult.error] : [],
                        managedUserIds: Array.isArray(rosterResult.managedUserIds) && rosterResult.managedUserIds.length
                            ? rosterResult.managedUserIds
                            : this.managedUserIds,
                        combinedUsers: null
                    });

                    if (this.attendanceDashboardData && Number.isFinite(this.attendanceDashboardYear)) {
                        const filteredRecords = this.filterAttendanceDashboardRecords(this.attendanceDashboardRecords, this.attendanceDashboardUserFilter);
                        this.attendanceDashboardData = this.computeAttendanceDashboard(filteredRecords, this.attendanceDashboardYear);
                        if (this.attendanceDashboardInitialized) {
                            this.initializeAttendanceDashboard();
                        }
                    }

                } catch (error) {
                    console.error(' Error loading users:', error);
                    this.availableUsers = [];
                    this.showToast('Failed to load users: ' + error.message, 'danger');
                }
            }

            updateUserDropdowns() {
                const dropdowns = ['scheduleUsers', 'filterUser', 'attendanceDashboardUser'];
                const normalizedFilterId = this.normalizeUserIdValue(this.attendanceDashboardUserFilter);

                dropdowns.forEach(dropdownId => {
                    const dropdown = document.getElementById(dropdownId);
                    if (!dropdown) return;

                    if (dropdownId === 'scheduleUsers') {
                        const operationalUsers = this.availableUsers.filter(user => !user.syntheticId);
                        dropdown.innerHTML = operationalUsers.map(user => {
                            const optionValue = user.UserName || user.FullName || user.ID || '';
                            const labelName = this.escapeHtml(user.FullName || user.UserName || 'Unnamed Agent');
                            const campaignLabel = this.escapeHtml(user.campaignName || 'No Campaign');
                            return `<option value="${this.escapeHtml(optionValue)}">${labelName} (${campaignLabel})</option>`;
                        }).join('');
                        return;
                    }

                    if (dropdownId === 'filterUser') {
                        dropdown.innerHTML = '<option value="">All Users</option>' +
                            this.availableUsers.map(user => {
                                const optionValue = user.UserName || user.FullName || user.ID || '';
                                return `<option value="${this.escapeHtml(optionValue)}">${this.escapeHtml(user.FullName || user.UserName || 'Unnamed Agent')}</option>`;
                            }).join('');
                        return;
                    }

                    const options = ['<option value="">All Users</option>'];
                    this.availableUsers.forEach(user => {
                        const resolvedId = this.normalizeUserIdValue(user.ID || user.UserID || user.id || user.userId || user.username);
                        const fallbackKey = this.normalizePersonKey(user.UserName || user.FullName || '');
                        const optionValue = resolvedId || fallbackKey;
                        const label = this.escapeHtml(user.FullName || user.UserName || 'Unnamed Agent');

                        if (!optionValue) {
                            return;
                        }

                        const normalizedOptionValue = this.normalizeUserIdValue(optionValue);
                        const isSelected = normalizedFilterId && normalizedOptionValue === normalizedFilterId;
                        const dataUserName = this.escapeHtml(this.normalizePersonKey(user.UserName || ''));
                        const dataFullName = this.escapeHtml(this.normalizePersonKey(user.FullName || ''));
                        options.push(`
                            <option value="${this.escapeHtml(optionValue)}" data-user-name="${dataUserName}" data-full-name="${dataFullName}"${isSelected ? ' selected' : ''}>${label}</option>
                        `);
                    });

                    dropdown.innerHTML = options.join('');
                });
            }

            updateUsersList() {
                const container = document.getElementById('usersList');
                if (!container) return;

                if (this.availableUsers.length === 0) {
                    const managerName = this.escapeHtml(this.currentUser?.FullName || this.currentUser?.UserName || 'your team');
                    container.innerHTML = `
                        <div class="text-muted text-center py-4">
                            <i class="fas fa-user-slash fa-2x mb-2 opacity-50"></i>
                            <p class="mb-1">No managed agents found for ${managerName}.</p>
                            <p class="mb-0 small">Verify your manager assignments in the MANAGER_USERS sheet.</p>
                        </div>
                    `;
                    this.updateManagerStats();
                    return;
                }

                const managerName = this.escapeHtml(this.currentUser?.FullName || this.currentUser?.UserName || 'your roster');
                const identityBadge = this.identityResolved
                    ? '<span class="badge bg-success">Lumina Identity</span>'
                    : '<span class="badge bg-secondary">Limited Identity</span>';

                const syntheticCount = this.availableUsers.filter(user => user.syntheticId).length;
                const syntheticBadge = syntheticCount
                    ? `<span class="badge bg-warning text-dark ms-2">${syntheticCount} unlinked</span>`
                    : '';
                const summary = `
                    <div class="d-flex flex-wrap justify-content-between align-items-center mb-3 gap-2 small text-muted">
                        <span>Showing <strong>${this.availableUsers.length}</strong> assigned agents ${syntheticBadge} for ${managerName}</span>
                        ${identityBadge}
                    </div>
                `;

                container.innerHTML = summary + this.availableUsers.map(user => {
                    const fullName = this.escapeHtml(user.FullName || user.UserName || 'Unnamed Agent');
                    const email = this.escapeHtml(user.Email || 'No email');
                    const campaign = this.escapeHtml(user.campaignName || 'No campaign');
                    const status = this.escapeHtml(user.EmploymentStatus || 'Active');
                    const badgeClass = user.isActive ? 'bg-success' : 'bg-secondary';
                    const badgeLabel = this.escapeHtml(user.isActive ? 'Active' : 'Inactive');
                    const badges = [`<span class="badge ${badgeClass}">${badgeLabel}</span>`];
                    if (user.syntheticId) {
                        badges.push('<span class="badge bg-warning text-dark ms-2">Unlinked</span>');
                    }
                    const badgesHtml = badges.join('');

                    return `
                        <div class="d-flex justify-content-between align-items-center mb-3 p-3 border rounded interactive-item">
                            <div>
                                <strong class="d-block">${fullName}</strong>
                                <small class="text-muted">
                                    ${email}  ${campaign}  ${status}
                                </small>
                            </div>
                            <span class="d-inline-flex align-items-center gap-2">${badgesHtml}</span>
                        </div>
                    `;
                }).join('');

                this.updateManagerStats();
            }

            updateManagerStats() {
                const container = document.getElementById('managerStats');
                if (!container) return;

                const operationalUsers = this.availableUsers.filter(u => !u.syntheticId);
                const activeUsers = operationalUsers.filter(u => u.isActive).length;
                const managedAgents = this.visibleManagedCount || operationalUsers.length;
                const rosterAssignments = (this.managedUserIdSet instanceof Set && this.managedUserIdSet.size)
                    ? this.managedUserIdSet.size
                    : managedAgents;
                const uniqueCampaigns = new Set(
                    operationalUsers
                        .map(user => (user.campaignName || '').trim())
                        .filter(Boolean)
                ).size;
                const campaignMetric = uniqueCampaigns || this.availableCampaigns.length || 0;

                container.innerHTML = `
                        <div class="row g-3">
                            <div class="col-6">
                                <div class="metric-card">
                                    <div class="metric-number text-primary">${managedAgents}</div>
                                    <div class="metric-label">Managed Agents</div>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="metric-card">
                                    <div class="metric-number text-success">${activeUsers}</div>
                                    <div class="metric-label">Active Agents</div>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="metric-card">
                                    <div class="metric-number text-info">${rosterAssignments}</div>
                                    <div class="metric-label">Roster Assignments</div>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="metric-card">
                                    <div class="metric-number text-warning">${campaignMetric}</div>
                                    <div class="metric-label">Campaigns</div>
                                </div>
                            </div>
                        </div>
                    `;
            }

            async loadCampaigns() {
                try {
                    const campaigns = await this.callServerFunction('csGetAllCampaigns');
                    this.availableCampaigns = Array.isArray(campaigns) ? campaigns : [];

                    // Update campaign filter dropdown
                    const campaignFilter = document.getElementById('campaignFilter');
                    if (campaignFilter) {
                        campaignFilter.innerHTML = '<option value="">All Campaigns</option>' +
                            this.availableCampaigns.map(campaign =>
                                `<option value="${campaign.id}">${campaign.name}</option>`
                            ).join('');
                    }

                    // Update department dropdown in shift slot form (using campaigns as departments)
                    const departmentSelect = document.getElementById('slotDepartment');
                    if (departmentSelect) {
                        departmentSelect.innerHTML = '<option value="">Select Department (Campaign)</option>' +
                            this.availableCampaigns.map(campaign =>
                                `<option value="${campaign.name}">${campaign.name}</option>`
                            ).join('');
                    }

                    console.log(` Loaded ${this.availableCampaigns.length} campaigns and populated department dropdown`);
                } catch (error) {
                    console.error(' Error loading campaigns:', error);
                    this.availableCampaigns = [];

                    // Show error state in department dropdown
                    const departmentSelect = document.getElementById('slotDepartment');
                    if (departmentSelect) {
                        departmentSelect.innerHTML = '<option value="">Error loading campaigns</option>';
                    }
                }
            }

            async loadShiftSlots() {
                try {
                    console.log(' Loading shift slots...');
                    const rawSlots = await this.callServerFunction('clientGetAllShiftSlots');
                    const { slots, metadata } = this.normalizeShiftSlotListResponse(rawSlots);

                    this.cachedShiftSlots = slots;
                    this.updateShiftSlotSelectors(slots);
                    this.displayShiftSlots(slots);

                    if (this.manualShiftManager && typeof this.manualShiftManager.setShiftSlots === 'function') {
                        this.manualShiftManager.setShiftSlots(slots);
                    }

                    const totalSlotsElement = document.getElementById('totalSlots');
                    if (totalSlotsElement) {
                        totalSlotsElement.textContent = metadata.totalCount;
                    }

                    console.log(` Loaded ${metadata.totalCount} shift slots`);
                } catch (error) {
                    console.error(' Error loading shift slots:', error);
                    this.cachedShiftSlots = [];
                    this.updateShiftSlotSelectors([]);
                    this.displayShiftSlots([]);
                    if (this.manualShiftManager && typeof this.manualShiftManager.setShiftSlots === 'function') {
                        this.manualShiftManager.setShiftSlots([]);
                    }
                    this.showToast(error.message || 'Failed to load shift slots. You may need to create some first.', 'warning');
                }
            }

            displayShiftSlots(slots) {
                const container = document.getElementById('shiftSlotsContainer');
                if (!container) return;

                if (slots.length === 0) {
                    container.innerHTML = `
                            <div class="text-center text-muted py-4">
                                <i class="fas fa-clock fa-3x mb-3 opacity-50"></i>
                                <p>No shift slots found.</p>
                                <p>Create your first shift slot using the form on the left.</p>
                            </div>
                        `;
                    return;
                }

                container.innerHTML = slots.map(slot => `
                        <div class="border rounded p-3 mb-3 interactive-item">
                            <div class="d-flex justify-content-between align-items-start">
                                <div>
                                    <h6 class="mb-1">${slot.Name}</h6>
                                    <p class="mb-2 small text-muted">
                                        <strong>Time:</strong> ${this.formatTimeValue(slot.StartTime)} - ${this.formatTimeValue(slot.EndTime)}<br>
                                        <strong>Days:</strong> ${this.formatDaysOfWeek(slot.DaysOfWeekArray || [])}<br>
                                        <strong>Department:</strong> ${slot.Department || 'General'}<br>
                                        <strong>Location:</strong> ${slot.Location || 'Office'}
                                    </p>
                                    ${slot.Description ? `<div class="small text-muted mb-1">${this.escapeHtml(slot.Description)}</div>` : ''}
                                    <small class="text-muted">Created by ${this.escapeHtml(slot.CreatedBy || 'System')} on ${this.formatDateTime(slot.CreatedAt)}</small>
                                </div>
                                <div class="btn-group-vertical btn-group-sm">
                                    <button class="btn btn-outline-primary btn-sm" onclick="editShiftSlot('${slot.ID}')" title="Edit">
                                        <i class="fas fa-edit"></i>
                                    </button>
                                    <button class="btn btn-outline-danger btn-sm" onclick="deleteShiftSlot('${slot.ID}')" title="Delete">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('');
            }

            updateShiftSlotSelectors(slots) {
                if (typeof document === 'undefined') {
                    return;
                }

                const select = document.getElementById('scheduleShiftSlots');
                if (!select) {
                    return;
                }

                const previouslySelected = Array.from(select.selectedOptions || []).map(option => option.value);
                select.innerHTML = '';

                if (!Array.isArray(slots) || slots.length === 0) {
                    const emptyOption = document.createElement('option');
                    emptyOption.disabled = true;
                    emptyOption.selected = true;
                    emptyOption.textContent = 'No shift slots available';
                    select.appendChild(emptyOption);
                    return;
                }

                const fragment = document.createDocumentFragment();
                slots.forEach(slot => {
                    const option = document.createElement('option');
                    const slotId = this.resolveShiftSlotId(slot);
                    option.value = slotId || this.buildShiftSlotFallbackValue(slot);
                    option.textContent = this.buildShiftSlotOptionLabel(slot);

                    if (!option.value) {
                        option.disabled = true;
                    }

                    if (previouslySelected.includes(option.value)) {
                        option.selected = true;
                    }

                    fragment.appendChild(option);
                });

                select.appendChild(fragment);
            }

            normalizeShiftSlotListResponse(rawSlots) {
                const emptyResult = { slots: [], metadata: { totalCount: 0 } };

                const coerceArray = (value) => {
                    if (!value) {
                        return [];
                    }

                    if (Array.isArray(value)) {
                        return value.filter(slot => slot && typeof slot === 'object');
                    }

                    if (typeof value === 'object') {
                        if (Array.isArray(value.values)) {
                            return coerceArray(value.values);
                        }

                        if (Array.isArray(value.items)) {
                            return coerceArray(value.items);
                        }

                        if (Array.isArray(value.records)) {
                            return coerceArray(value.records);
                        }

                        if (Array.isArray(value.data)) {
                            return coerceArray(value.data);
                        }

                        const numericKeys = Object.keys(value).filter(key => /^\d+$/.test(key));
                        if (numericKeys.length) {
                            return numericKeys
                                .sort((a, b) => Number(a) - Number(b))
                                .map(key => value[key])
                                .filter(slot => slot && typeof slot === 'object');
                        }

                        const objectValues = Object.values(value)
                            .filter(entry => entry && typeof entry === 'object');
                        if (objectValues.length && objectValues.every(entry => entry.ID || entry.Name || entry.SlotName || entry.StartTime)) {
                            return objectValues;
                        }

                        if (value.ID || value.Name) {
                            return [value];
                        }
                    }

                    return [];
                };

                const buildMetadata = (slots, source) => {
                    const base = {
                        totalCount: slots.length
                    };

                    if (source && typeof source === 'object') {
                        if (typeof source.total === 'number') {
                            base.total = source.total;
                        }
                        if (typeof source.totalCount === 'number') {
                            base.totalCount = source.totalCount;
                        }
                        if (typeof source.count === 'number') {
                            base.count = source.count;
                        }
                        base.source = source;
                    }

                    return base;
                };

                const handleFailure = (message) => {
                    throw new Error(message || 'Failed to load shift slots from the server.');
                };

                if (Array.isArray(rawSlots)) {
                    const normalized = coerceArray(rawSlots);
                    return {
                        slots: normalized,
                        metadata: buildMetadata(normalized)
                    };
                }

                if (!rawSlots) {
                    return emptyResult;
                }

                if (typeof rawSlots === 'string') {
                    const trimmed = rawSlots.trim();
                    if (!trimmed) {
                        return emptyResult;
                    }

                    const lower = trimmed.toLowerCase();
                    if (lower.includes('no shift slots') || lower.includes('no slots found')) {
                        return emptyResult;
                    }

                    if (['success', 'ok', 'done', 'created', 'completed'].some(token => lower.includes(token))) {
                        return emptyResult;
                    }

                    handleFailure(trimmed);
                }

                if (typeof rawSlots === 'object') {
                    if (rawSlots.success === false) {
                        const message = rawSlots.error || rawSlots.message;
                        if (message && /no (shift\s*)?slots?/i.test(message)) {
                            return emptyResult;
                        }
                        handleFailure(message);
                    }

                    const candidateArrays = [
                        rawSlots.slots,
                        rawSlots.data?.slots,
                        rawSlots.result?.slots,
                        rawSlots.records,
                        rawSlots.items,
                        rawSlots.values
                    ];

                    for (const candidate of candidateArrays) {
                        const normalized = coerceArray(candidate);
                        if (normalized.length) {
                            return {
                                slots: normalized,
                                metadata: buildMetadata(normalized, rawSlots)
                            };
                        }
                    }

                    if (rawSlots.success === true) {
                        const normalizedData = coerceArray(rawSlots.data);
                        if (normalizedData.length) {
                            return {
                                slots: normalizedData,
                                metadata: buildMetadata(normalizedData, rawSlots)
                            };
                        }
                    }

                    const singleSlot = coerceArray(rawSlots);
                    if (singleSlot.length) {
                        return {
                            slots: singleSlot,
                            metadata: buildMetadata(singleSlot, rawSlots)
                        };
                    }
                }

                return emptyResult;
            }

            resolveShiftSlotId(slot = {}) {
                const candidates = [
                    slot.ID, slot.Id, slot.id,
                    slot.SlotID, slot.SlotId, slot.slotId,
                    slot.Guid, slot.UUID, slot.Uuid
                ];

                for (let index = 0; index < candidates.length; index++) {
                    const candidate = candidates[index];
                    if (candidate === null || candidate === undefined) {
                        continue;
                    }

                    const normalized = String(candidate).trim();
                    if (normalized) {
                        return normalized;
                    }
                }

                return '';
            }

            buildShiftSlotFallbackValue(slot = {}) {
                const name = (slot.Name || slot.SlotName || '').toString().trim();
                const timeRange = [
                    this.formatTimeValue(slot.StartTime),
                    this.formatTimeValue(slot.EndTime)
                ].filter(Boolean).join('-');

                const descriptor = [name, timeRange].filter(Boolean).join('|');
                return descriptor;
            }

            buildShiftSlotOptionLabel(slot = {}) {
                const parts = [];
                const name = (slot.Name || slot.SlotName || 'Shift Slot').toString().trim();
                if (name) {
                    parts.push(name);
                }

                const startTime = this.formatTimeValue(slot.StartTime);
                const endTime = this.formatTimeValue(slot.EndTime);
                const timeRange = [startTime, endTime].filter(Boolean).join(' - ');
                if (timeRange) {
                    parts.push(`(${timeRange})`);
                }

                const days = Array.isArray(slot.DaysOfWeekArray)
                    ? this.formatDaysOfWeek(slot.DaysOfWeekArray)
                    : (typeof slot.DaysOfWeek === 'string'
                        ? this.formatDaysOfWeek(slot.DaysOfWeek.split(',').map(value => parseInt(value, 10)).filter(day => !isNaN(day)))
                        : '');
                if (days) {
                    parts.push(` ${days}`);
                }

                const department = (slot.Department || slot.Team || '').toString().trim();
                if (department) {
                    parts.push(` ${department}`);
                }

                return parts.join(' ');
            }

            applyScheduleDashboard(dashboard) {
                if (!dashboard || dashboard.success !== true) {
                    return false;
                }

                this.updateScheduleMetrics(dashboard);
                this.renderCoverageChart(dashboard.coverage);
                this.renderScheduleInsights(dashboard);
                this.renderFairnessWatchlist(dashboard.fairness);
                this.renderComplianceAlerts(dashboard.compliance);
                return true;
            }

            async refreshDashboard() {
                try {
                    console.log(' Refreshing dashboard...');
                    await this.ensureScheduleContext();

                    const endDate = new Date();
                    const startDate = new Date();
                    startDate.setDate(endDate.getDate() - 30);

                    const managerId = this.getCurrentUserId();
                    const campaignId = this.resolvedCampaignId || this.getCurrentCampaignId();
                    const options = {
                        startDate: startDate.toISOString().split('T')[0],
                        endDate: endDate.toISOString().split('T')[0],
                        intervalMinutes: 30,
                        openingHour: 8,
                        closingHour: 21
                    };

                    const dashboard = await this.callServerFunction('clientGetScheduleDashboard', managerId, campaignId || null, options);

                    if (!this.applyScheduleDashboard(dashboard)) {
                        throw new Error(dashboard && dashboard.error ? dashboard.error : 'Unknown dashboard error');
                    }

                } catch (error) {
                    console.error(' Error refreshing dashboard:', error);
                    this.renderScheduleInsights({
                        recommendations: [`Unable to load schedule dashboard: ${error.message || error}`]
                    });
                    this.renderCoverageChart(null);
                    this.renderFairnessWatchlist(null);
                    this.renderComplianceAlerts(null);
                }
            }

            updateScheduleMetrics(dashboard) {
                const summary = dashboard && dashboard.summary ? dashboard.summary : {};
                const totals = dashboard && dashboard.totals ? dashboard.totals : {};
                const fairness = dashboard && dashboard.fairness ? dashboard.fairness : {};
                const compliance = dashboard && dashboard.compliance ? dashboard.compliance : {};

                const setText = (id, value) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = value;
                    }
                };

                setText('scheduleHealthScore', `${Math.round(dashboard.healthScore || 0)}`);
                setText('scheduleServiceLevel', `${Math.round(summary.serviceLevel || 0)}%`);
                setText('scheduleFairnessIndex', `${Math.round(summary.fairnessIndex || fairness.fairnessIndex || 0)}`);
                setText('scheduleComplianceScore', `${Math.round(summary.complianceScore || compliance.complianceScore || 0)}`);
                setText('scheduleRosterHours', `${Number(totals.rosterHours || 0).toFixed(1)}h`);
                setText('scheduleRequiredFte', Number(totals.requiredFTE || 0).toFixed(1));
                setText('scheduleStaffedFte', Number(totals.staffedFTE || 0).toFixed(1));
                setText('totalUsers', String(dashboard.roster?.agentCount || this.availableUsers.length || 0));
            }

            renderCoverageChart(coverage) {
                const canvas = document.getElementById('scheduleCoverageChart');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const container = canvas.parentElement;
                if (this.coverageChart) {
                    this.coverageChart.destroy();
                    this.coverageChart = null;
                }

                const placeholder = container.querySelector('.coverage-no-data');
                if (placeholder) {
                    placeholder.remove();
                }

                if (!coverage || !Array.isArray(coverage.intervalSummaries) || coverage.intervalSummaries.length === 0) {
                    canvas.style.display = 'none';
                    const message = document.createElement('div');
                    message.className = 'coverage-no-data p-4 text-center text-muted';
                    message.innerHTML = '<i class="fas fa-info-circle mb-2"></i><p class="mb-0">No coverage data available for the selected range.</p>';
                    container.appendChild(message);
                    return;
                }

                canvas.style.display = 'block';

                const sortedIntervals = coverage.intervalSummaries.slice().sort((a, b) => a.intervalKey.localeCompare(b.intervalKey));
                const sample = sortedIntervals.slice(0, 24);
                const labels = sample.map(item => item.intervalKey.slice(5));
                const required = sample.map(item => Number(item.requiredFTE || 0));
                const staffed = sample.map(item => Number(item.staffedFTE || 0));

                this.coverageChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: 'Required FTE',
                                data: required,
                                backgroundColor: 'rgba(0, 82, 204, 0.35)'
                            },
                            {
                                label: 'Staffed FTE',
                                data: staffed,
                                backgroundColor: 'rgba(0, 150, 57, 0.6)'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: value => `${value}`
                                }
                            },
                            x: {
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 12
                                }
                            }
                        }
                    }
                });
            }

            renderScheduleInsights(dashboard) {
                const container = document.getElementById('scheduleInsights');
                if (!container) return;

                const recommendations = dashboard && Array.isArray(dashboard.recommendations) ? dashboard.recommendations : [];
                const coverage = dashboard && dashboard.coverage ? dashboard.coverage : null;
                const fairness = dashboard && dashboard.fairness ? dashboard.fairness : null;
                const compliance = dashboard && dashboard.compliance ? dashboard.compliance : null;

                const insights = recommendations.slice(0, 5).map(message => ({ type: 'insight', message }));

                if (coverage && Array.isArray(coverage.backlogRiskIntervals) && coverage.backlogRiskIntervals.length) {
                    const interval = coverage.backlogRiskIntervals[0];
                    insights.unshift({
                        type: 'coverage',
                        message: `Most under-staffed window: ${interval.intervalKey} (${interval.deficit.toFixed(2)} FTE deficit)`
                    });
                }

                if (fairness && fairness.rotationHealth < 75) {
                    insights.push({
                        type: 'fairness',
                        message: `Fairness rotation health at ${Math.round(fairness.rotationHealth)}. Consider rebalancing weekends.`
                    });
                }

                if (compliance && compliance.totalViolations > 0) {
                    insights.push({
                        type: 'compliance',
                        message: `${compliance.totalViolations} potential compliance issues detected. Review the alerts panel.`
                    });
                }

                if (insights.length === 0) {
                    container.innerHTML = `
                        <div class="text-center text-muted py-4">
                            <i class="fas fa-lightbulb fa-2x mb-3 opacity-50"></i>
                            <p>Schedule health looks great! No actions required right now.</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = insights.slice(0, 6).map(insight => `
                    <div class="insight-card insight-${insight.type}">
                        <div class="d-flex align-items-start gap-2">
                            <i class="fas fa-${this.getInsightIcon(insight.type)}"></i>
                            <div class="flex-grow-1 small">${insight.message}</div>
                        </div>
                    </div>
                `).join('');
            }

            renderFairnessWatchlist(fairness) {
                const container = document.getElementById('fairnessWatchlist');
                if (!container) return;

                if (!fairness || !Array.isArray(fairness.agentSummaries) || fairness.agentSummaries.length === 0) {
                    container.innerHTML = '<p class="text-muted py-4">No fairness data available yet.</p>';
                    return;
                }

                const watchlist = fairness.agentSummaries
                    .slice()
                    .sort((a, b) => (a.fairnessScore || 0) - (b.fairnessScore || 0))
                    .slice(0, 5);

                container.innerHTML = watchlist.map(agent => `
                    <div class="d-flex justify-content-between align-items-center mb-2 p-2 border-bottom">
                        <div>
                            <strong>${agent.userName || agent.userId}</strong>
                            <div class="small text-muted">Weekend: ${agent.weekendShifts || 0}  Night: ${agent.nightShifts || 0}</div>
                        </div>
                        <div class="text-end">
                            <span class="badge bg-warning text-dark">${Math.round(agent.fairnessScore || 0)}</span>
                        </div>
                    </div>
                `).join('');
            }

            renderComplianceAlerts(compliance) {
                const container = document.getElementById('complianceAlerts');
                if (!container) return;

                if (!compliance || !Array.isArray(compliance.violationDetails) || compliance.violationDetails.length === 0) {
                    container.innerHTML = `
                        <div class="text-center text-success py-4">
                            <i class="fas fa-check-circle fa-2x mb-2"></i>
                            <p>No compliance issues detected</p>
                        </div>
                    `;
                    return;
                }

                const alerts = compliance.violationDetails.slice(0, 5);
                container.innerHTML = alerts.map(alert => {
                    const severity = alert.type === 'SHIFT_DURATION' || alert.type === 'REST_PERIOD' ? 'danger' : 'warning';
                    const message = (() => {
                        if (alert.message) return alert.message;
                        switch (alert.type) {
                            case 'SHIFT_DURATION':
                                return `Scheduled ${Number(alert.scheduledHours || 0).toFixed(2)}h (limit ${alert.maxHoursPerDay || 12}h)`;
                            case 'REST_PERIOD':
                                return `Rest ${Number(alert.restHours || 0).toFixed(2)}h (required ${alert.requiredRestHours || 10}h)`;
                            case 'CONSECUTIVE_DAYS':
                                return `${alert.consecutiveDays || '?'} consecutive days (max ${alert.maxConsecutiveDays || 6})`;
                            case 'MISSING_BREAK':
                                return `Missing required break on ${alert.date || 'scheduled day'}`;
                            default:
                                return 'Review schedule details for compliance adjustments.';
                        }
                    })();

                    return `
                        <div class="alert alert-${severity}-modern mb-2">
                            <strong>${alert.type.replace('_', ' ')}:</strong> ${alert.userName || alert.userId || 'Agent'} - ${message}
                        </div>
                    `;
                }).join('');
            }

            async generateSchedules(options = {}) {
                try {
                    const formData = this.getScheduleGenerationData();
                    const contextHash = this.buildGenerationContextHash(formData);

                    if (!formData.shiftSlots || formData.shiftSlots.length === 0) {
                        this.showToast('Please select at least one shift slot before generating assignments.', 'warning');
                        this.updateGenerationStatus('Select a shift slot to assign before generating.', 'warning');
                        return;
                    }

                    const hasPreview = this.latestPreviewState
                        && this.latestPreviewState.token
                        && this.latestPreviewState.contextHash === contextHash;

                    if (!hasPreview) {
                        await this.previewSchedules({
                            formData,
                            contextHash,
                            silent: !!options.autoCommit
                        });

                        if (!options.autoCommit) {
                            this.showToast('Preview ready. Review the details and confirm to publish.', 'info');
                            return;
                        }
                    }

                    await this.confirmScheduleGeneration({
                        formData,
                        skipHashCheck: false
                    });

                } catch (error) {
                    console.error(' Schedule generation workflow failed:', error);
                    if (!error || !error.__previewHandled) {
                        this.showToast('Schedule generation failed: ' + error.message, 'danger');
                        this.updateGenerationStatus('Generation failed: ' + error.message, 'danger');
                    }
                }
            }

            getScheduleGenerationData() {
                const startDate = document.getElementById('scheduleStartDate').value;
                const endDate = document.getElementById('scheduleEndDate').value;
                const userSelections = Array.from(document.getElementById('scheduleUsers').selectedOptions);
                const users = userSelections.map(option => option.value);
                const slotSelections = Array.from(document.getElementById('scheduleShiftSlots').selectedOptions);
                const shiftSlots = slotSelections.map(option => option.value).filter(value => value);
                const campaignId = document.getElementById('campaignFilter').value || null;
                const priority = parseInt(document.getElementById('schedulePriority').value);
                const detectConflicts = document.getElementById('detectConflicts').checked;
                const includeHolidays = document.getElementById('includeHolidays').checked;

                const getOptionValue = (id, fallback = '') => {
                    const element = document.getElementById(id);
                    if (!element) {
                        return fallback;
                    }
                    const value = element.value ?? '';
                    return value === '' ? fallback : value;
                };

                const getOptionNumber = (id, fallback, { allowFloat = false, min = null, max = null } = {}) => {
                    const element = document.getElementById(id);
                    if (!element) {
                        return fallback;
                    }

                    const rawValue = element.value;
                    if (rawValue === '' || rawValue === null || rawValue === undefined) {
                        return fallback;
                    }

                    const parsed = allowFloat ? parseFloat(rawValue) : parseInt(rawValue, 10);
                    if (!Number.isFinite(parsed)) {
                        return fallback;
                    }

                    let value = parsed;
                    if (typeof min === 'number' && value < min) {
                        value = min;
                    }
                    if (typeof max === 'number' && value > max) {
                        value = max;
                    }

                    return value;
                };

                const getOptionCheckbox = (id, fallback = false) => {
                    const element = document.getElementById(id);
                    return element ? element.checked : fallback;
                };

                const capacity = {
                    max: getOptionNumber('generationMaxCapacity', 10, { min: 1, max: 100 }),
                    min: getOptionNumber('generationMinCoverage', 3, { min: 1 })
                };

                const breaks = {
                    first: getOptionNumber('generationBreak1Duration', 15, { min: 5, max: 30 }),
                    lunch: getOptionNumber('generationLunchDuration', 30, { min: 15, max: 60 }),
                    second: getOptionNumber('generationBreak2Duration', 0, { min: 0, max: 30 }),
                    enableStaggered: getOptionCheckbox('generationEnableStaggeredBreaks', true),
                    groups: getOptionNumber('generationBreakGroups', 3, { min: 2, max: 5 }),
                    interval: getOptionNumber('generationStaggerInterval', 15, { min: 10, max: 30 }),
                    minCoveragePct: getOptionNumber('generationMinCoveragePct', 70, { min: 50, max: 95 })
                };
                breaks.total = (breaks.first || 0) + (breaks.second || 0) + (breaks.lunch || 0);

                const overtime = {
                    enabled: getOptionCheckbox('generationEnableOvertime', false),
                    maxDaily: getOptionNumber('generationMaxDailyOT', 2, { allowFloat: true, min: 0 }),
                    maxWeekly: getOptionNumber('generationMaxWeeklyOT', 10, { allowFloat: true, min: 0 }),
                    approval: getOptionValue('generationOTApproval', 'supervisor'),
                    rate: getOptionNumber('generationOTRate', 1.5, { allowFloat: true, min: 1 }),
                    policy: getOptionValue('generationOTPolicy', 'MANDATORY')
                };

                const advanced = {
                    allowSwaps: getOptionCheckbox('generationAllowSwaps', true),
                    weekendPremium: getOptionCheckbox('generationWeekendPremium', false),
                    holidayPremium: getOptionCheckbox('generationHolidayPremium', true),
                    autoAssignment: getOptionCheckbox('generationAutoAssignment', false),
                    restPeriod: getOptionNumber('generationRestPeriod', 8, { min: 0 }),
                    notificationLead: getOptionNumber('generationNotificationLead', 24, { min: 0 }),
                    handoverTime: getOptionNumber('generationHandoverTime', 15, { min: 0 })
                };

                const isActive = getOptionCheckbox('generationIsActive', true);

                return {
                    startDate,
                    endDate,
                    users: users.length > 0 ? users : null,
                    shiftSlots,
                    templateId: null,
                    generatedBy: this.getCurrentUserId() || 'System',
                    options: {
                        priority,
                        Priority: priority,
                        detectConflicts,
                        includeHolidays,
                        overrideExisting: false,
                        campaignId,
                        capacity,
                        breaks,
                        overtime,
                        advanced,
                        maxCapacity: capacity.max,
                        MaxCapacity: capacity.max,
                        minCoverage: capacity.min,
                        MinCoverage: capacity.min,
                        breakDuration: breaks.total,
                        BreakDuration: breaks.total,
                        break1Duration: breaks.first,
                        Break1Duration: breaks.first,
                        break2Duration: breaks.second,
                        Break2Duration: breaks.second,
                        lunchDuration: breaks.lunch,
                        LunchDuration: breaks.lunch,
                        enableStaggeredBreaks: breaks.enableStaggered,
                        EnableStaggeredBreaks: breaks.enableStaggered,
                        breakGroups: breaks.groups,
                        BreakGroups: breaks.groups,
                        staggerInterval: breaks.interval,
                        StaggerInterval: breaks.interval,
                        minCoveragePct: breaks.minCoveragePct,
                        MinCoveragePct: breaks.minCoveragePct,
                        enableOvertime: overtime.enabled,
                        EnableOvertime: overtime.enabled,
                        maxDailyOT: overtime.maxDaily,
                        MaxDailyOT: overtime.maxDaily,
                        maxWeeklyOT: overtime.maxWeekly,
                        MaxWeeklyOT: overtime.maxWeekly,
                        OTApproval: overtime.approval,
                        OTRate: overtime.rate,
                        OTPolicy: overtime.policy,
                        overtimePolicy: overtime.policy,
                        OvertimePolicy: overtime.policy,
                        allowSwaps: advanced.allowSwaps,
                        AllowSwaps: advanced.allowSwaps,
                        weekendPremium: advanced.weekendPremium,
                        WeekendPremium: advanced.weekendPremium,
                        holidayPremium: advanced.holidayPremium,
                        HolidayPremium: advanced.holidayPremium,
                        autoAssignment: advanced.autoAssignment,
                        AutoAssignment: advanced.autoAssignment,
                        restPeriod: advanced.restPeriod,
                        RestPeriodHours: advanced.restPeriod,
                        notificationLead: advanced.notificationLead,
                        NotificationLead: advanced.notificationLead,
                        handoverTime: advanced.handoverTime,
                        HandoverTimeMinutes: advanced.handoverTime,
                        notificationLeadHours: advanced.notificationLead,
                        isActive,
                        IsActive: isActive
                    }
                };
            }

            buildGenerationContextHash(formData) {
                if (!formData || typeof formData !== 'object') {
                    return '';
                }

                const normalize = (value) => {
                    if (Array.isArray(value)) {
                        return value.map(normalize).sort();
                    }
                    if (value && typeof value === 'object') {
                        const sortedKeys = Object.keys(value).sort();
                        const normalizedObject = {};
                        sortedKeys.forEach(key => {
                            normalizedObject[key] = normalize(value[key]);
                        });
                        return normalizedObject;
                    }
                    if (value === undefined || value === null) {
                        return '';
                    }
                    return value;
                };

                const payload = {
                    startDate: formData.startDate || '',
                    endDate: formData.endDate || '',
                    users: Array.isArray(formData.users) ? formData.users.slice().sort() : [],
                    shiftSlots: Array.isArray(formData.shiftSlots) ? formData.shiftSlots.slice().sort() : [],
                    options: normalize(formData.options || {})
                };

                return JSON.stringify(payload);
            }

            async previewSchedules(options = {}) {
                const { formData = null, contextHash = null, silent = false } = options;

                try {
                    const payload = formData || this.getScheduleGenerationData();
                    const hash = contextHash || this.buildGenerationContextHash(payload);

                    this.showLoading(true);
                    this.updateGenerationStatus('Building preview...', 'info');

                    const optionsPayload = JSON.parse(JSON.stringify(payload.options || {}));
                    delete optionsPayload.commitToken;

                    const result = await this.callServerFunction('clientGenerateSchedulesEnhanced',
                        payload.startDate,
                        payload.endDate,
                        payload.users,
                        payload.shiftSlots,
                        payload.templateId,
                        payload.generatedBy,
                        optionsPayload
                    );

                    if (!result || !result.success) {
                        throw new Error(result?.error || 'Failed to generate schedule preview.');
                    }

                    if (!result.previewToken) {
                        throw new Error('Preview token missing from response. Please regenerate.');
                    }

                    const previewState = {
                        token: result.previewToken,
                        contextHash: hash,
                        parameters: JSON.parse(JSON.stringify({
                            startDate: payload.startDate,
                            endDate: payload.endDate,
                            users: payload.users,
                            shiftSlots: payload.shiftSlots,
                            templateId: payload.templateId,
                            generatedBy: payload.generatedBy,
                            options: optionsPayload
                        })),
                        preview: result.preview || {},
                        assignments: Array.isArray(result.assignments) ? result.assignments : [],
                        conflicts: Array.isArray(result.conflicts) ? result.conflicts : [],
                        skippedUsers: Array.isArray(result.skippedUsers) ? result.skippedUsers : [],
                        unresolvedUsers: Array.isArray(result.unresolvedUsers) ? result.unresolvedUsers : []
                    };

                    this.latestPreviewState = previewState;
                    this.previewContextHash = hash;

                    this.renderSchedulePreview(previewState);

                    if (!silent) {
                        this.showToast('Preview ready. Review the details and confirm to publish.', 'info');
                    }
                    this.updateGenerationStatus('Preview ready. Review details and confirm to publish.', 'info');

                    return result;
                } catch (error) {
                    console.error(' Schedule preview failed:', error);
                    this.showToast('Schedule preview failed: ' + error.message, 'danger');
                    this.updateGenerationStatus('Preview failed: ' + error.message, 'danger');
                    if (error && typeof error === 'object') {
                        error.__previewHandled = true;
                    }
                    throw error;
                } finally {
                    this.showLoading(false);
                }
            }

            resetPreviewState() {
                this.latestPreviewState = null;
                this.previewContextHash = '';
            }

            clearSchedulePreview(updateStatus = true) {
                this.resetPreviewState();

                const container = document.getElementById('generationResults');
                if (container) {
                    container.innerHTML = '';
                    container.classList.add('d-none');
                    container.style.display = 'none';
                }

                if (updateStatus) {
                    this.updateGenerationStatus('Preview cleared. Adjust parameters and generate again when ready.', 'info');
                }
            }

            renderSchedulePreview(previewState) {
                const container = document.getElementById('generationResults');
                if (!container) {
                    return;
                }

                const preview = previewState.preview || {};
                const assignmentsCount = Number(preview.totalAssignments || (previewState.assignments ? previewState.assignments.length : 0) || 0);
                const coveragePercentRaw = Number(preview.coveragePercent || 0);
                const coveragePercent = Number.isFinite(coveragePercentRaw) ? Math.round(coveragePercentRaw) : 0;
                const shortfallDaysRaw = Number(preview.shortfallDays || 0);
                const shortfallDays = Number.isFinite(shortfallDaysRaw) ? shortfallDaysRaw : 0;
                const periodLabel = this.formatPeriodLabel(preview.periodStart, preview.periodEnd) || '';
                const coverageDetails = Array.isArray(preview.coverageDetails) ? preview.coverageDetails : [];

                const slotTotals = {};
                (previewState.assignments || []).forEach(assignment => {
                    const slotKey = assignment.SlotName || assignment.SlotId || 'Shift';
                    slotTotals[slotKey] = (slotTotals[slotKey] || 0) + 1;
                });
                const slotSummaryChips = Object.keys(slotTotals).sort().map(slotName => {
                    const count = slotTotals[slotName];
                    return `<span class="badge bg-light text-dark border me-1 mb-1">${this.escapeHtml(slotName)}  ${count}</span>`;
                }).join('');
                const slotSummaryHtml = slotSummaryChips
                    ? `<div class="mt-3 small text-muted"><strong>Slot distribution:</strong> ${slotSummaryChips}</div>`
                    : '';

                const conflicts = Array.isArray(previewState.conflicts) ? previewState.conflicts : [];
                const conflictItems = conflicts.map(conflict => {
                    const name = this.escapeHtml(conflict.userName || conflict.user || conflict.userId || 'Agent');
                    const period = this.formatPeriodLabel(conflict.periodStart, conflict.periodEnd) || '';
                    const reason = this.escapeHtml(conflict.error || conflict.reason || conflict.type || 'Conflict detected');
                    const periodLabelHtml = period ? `  ${this.escapeHtml(period)}` : '';
                    return `<li>${name}${periodLabelHtml}  ${reason}</li>`;
                }).join('');
                const conflictsHtml = conflicts.length
                    ? `<div class="alert alert-warning-modern mt-3"><strong>Conflicts detected:</strong><ul class="mb-0 mt-2">${conflictItems}</ul></div>`
                    : `<div class="alert alert-success-modern mt-3 mb-0"><i class="fas fa-check-circle me-2"></i>No conflicts detected.</div>`;

                const skippedUsers = Array.isArray(previewState.skippedUsers) ? previewState.skippedUsers : [];
                const skippedItems = skippedUsers.map(entry => {
                    const name = this.escapeHtml(entry.userName || entry.user || entry.userId || 'Agent');
                    const reason = this.escapeHtml(entry.reason || 'Skipped due to rule constraints');
                    return `<li>${name}  ${reason}</li>`;
                }).join('');
                const skippedHtml = skippedUsers.length
                    ? `<div class="alert alert-info-modern mt-3"><strong>Skipped users:</strong><ul class="mb-0 mt-2">${skippedItems}</ul></div>`
                    : '';

                const unresolvedUsers = Array.isArray(previewState.unresolvedUsers) ? previewState.unresolvedUsers : [];
                const unresolvedItems = unresolvedUsers.map(entry => `<li>${this.escapeHtml(entry)}</li>`).join('');
                const unresolvedHtml = unresolvedUsers.length
                    ? `<div class="alert alert-secondary-modern mt-3"><strong>Unresolved users:</strong><ul class="mb-0 mt-2">${unresolvedItems}</ul></div>`
                    : '';

                container.classList.remove('d-none');
                container.style.display = 'block';
                container.innerHTML = `
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-eye text-info"></i>
                                Schedule Preview
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div class="row g-3">
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-number text-primary">${assignmentsCount}</div>
                                        <div class="metric-label">Assignments</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-number text-success">${coveragePercent}%</div>
                                        <div class="metric-label">% Days Meeting Coverage</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-number text-warning">${shortfallDays}</div>
                                        <div class="metric-label">Days Below Target</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-number text-info">${this.escapeHtml(periodLabel)}</div>
                                        <div class="metric-label">Assignment Period</div>
                                    </div>
                                </div>
                            </div>
                            ${slotSummaryHtml}
                            ${this.renderCoveragePreviewTable(coverageDetails)}
                            ${conflictsHtml}
                            ${skippedHtml}
                            ${unresolvedHtml}
                            <div class="d-flex justify-content-end gap-2 mt-4">
                                <button type="button" class="btn btn-outline-modern btn-modern" onclick="scheduleManager.clearSchedulePreview()">
                                    <i class="fas fa-times"></i>
                                    Cancel Preview
                                </button>
                                <button type="button" class="btn btn-primary-modern btn-modern" onclick="scheduleManager.confirmScheduleGeneration()">
                                    <i class="fas fa-cloud-upload-alt"></i>
                                    Confirm &amp; Save
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderCoveragePreviewTable(coverageDetails = []) {
                if (!Array.isArray(coverageDetails) || coverageDetails.length === 0) {
                    return `<div class="alert alert-info-modern mt-3 mb-0"><i class="fas fa-info-circle me-2"></i>No coverage details available for this preview.</div>`;
                }

                const rows = coverageDetails.map(day => {
                    const total = Number(day.total || 0);
                    const minRequired = Number(day.minRequired || 0);
                    const shortfall = Number(day.shortfall || 0);
                    const excess = Number(day.excess || 0);
                    const dateLabel = this.escapeHtml(this.formatDate(day.date));

                    const status = shortfall > 0
                        ? { icon: 'exclamation-triangle', label: `Shortfall (${shortfall})`, className: 'text-danger fw-semibold' }
                        : excess > 0
                            ? { icon: 'exclamation-triangle', label: `Excess (+${excess})`, className: 'text-warning fw-semibold' }
                            : { icon: 'check-circle', label: 'Met', className: 'text-success fw-semibold' };

                    const varianceLabel = shortfall > 0
                        ? `<span class="text-danger">-${shortfall}</span>`
                        : excess > 0
                            ? `<span class="text-warning">+${excess}</span>`
                            : '<span class="text-success">0</span>';

                    const coverageLabel = minRequired > 0 ? `${total}/${minRequired}` : `${total}`;

                    return `
                        <tr>
                            <td>${dateLabel}</td>
                            <td>${coverageLabel}</td>
                            <td>${varianceLabel}</td>
                            <td><span class="${status.className}"><i class="fas fa-${status.icon} me-1"></i>${status.label}</span></td>
                            <td>${this.renderPremiumBadges(day)}</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <div class="table-responsive mt-3">
                        <table class="table table-modern table-sm align-middle mb-0">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Coverage (Actual / Target)</th>
                                    <th>Variance</th>
                                    <th>Status</th>
                                    <th>Premiums &amp; Flags</th>
                                </tr>
                            </thead>
                            <tbody>${rows}</tbody>
                        </table>
                    </div>
                `;
            }

            renderPremiumBadges(day) {
                if (!day || typeof day !== 'object') {
                    return '<span class="text-muted small"></span>';
                }

                const badges = [];
                if (day.weekend) {
                    badges.push('<span class="badge bg-light text-dark border me-1 mb-1"><i class="fas fa-calendar-week me-1"></i>Weekend</span>');
                }

                const regions = Array.isArray(day.holidayRegions) ? day.holidayRegions : [];
                regions.forEach(region => {
                    const label = this.escapeHtml(region || 'Holiday');
                    const isJamaica = (region || '').toLowerCase() === 'jamaica';
                    const badgeClass = isJamaica ? 'badge bg-success text-white' : 'badge bg-secondary text-white';
                    badges.push(`<span class="${badgeClass} me-1 mb-1"><i class="fas fa-flag me-1"></i>${label}</span>`);
                });

                const premium = day.premium || {};
                if (premium.weekend) {
                    badges.push('<span class="badge bg-warning text-dark me-1 mb-1"><i class="fas fa-star me-1"></i>Weekend Premium</span>');
                }
                if (premium.holiday) {
                    badges.push('<span class="badge bg-success text-white me-1 mb-1"><i class="fas fa-gift me-1"></i>Holiday Premium</span>');
                }

                return badges.length ? badges.join('') : '<span class="text-muted small"></span>';
            }

            async confirmScheduleGeneration(options = {}) {
                const previewState = this.latestPreviewState;
                if (!previewState || !previewState.token) {
                    this.showToast('Generate a preview before confirming assignments.', 'warning');
                    return;
                }

                const formData = options.formData || this.getScheduleGenerationData();
                const contextHash = this.buildGenerationContextHash(formData);

                if (!options.skipHashCheck && previewState.contextHash !== contextHash) {
                    this.showToast('The preview no longer matches the current selections. Please regenerate the preview.', 'warning');
                    this.updateGenerationStatus('Preview mismatch detected. Regenerate before confirming.', 'warning');
                    return;
                }

                try {
                    this.showLoading(true);
                    this.updateGenerationStatus('Saving assignments...', 'info');

                    const commitOptions = Object.assign({}, previewState.parameters.options || {});
                    commitOptions.commitToken = previewState.token;

                    const result = await this.callServerFunction('clientGenerateSchedulesEnhanced',
                        previewState.parameters.startDate,
                        previewState.parameters.endDate,
                        previewState.parameters.users,
                        previewState.parameters.shiftSlots,
                        previewState.parameters.templateId,
                        previewState.parameters.generatedBy,
                        commitOptions
                    );

                    if (!result || !result.success) {
                        throw new Error(result?.error || 'Failed to save assignments.');
                    }

                    if (!result.coverage && previewState.preview) {
                        result.coverage = previewState.preview;
                    }

                    this.resetPreviewState();
                    this.displayGenerationResults(result, { mode: 'commit' });
                    this.showToast(`Successfully scheduled ${result.generated} assignment${result.generated === 1 ? '' : 's'}.`, 'success');
                    this.updateGenerationStatus('Assignments saved. Review them in Manage Schedule.', 'success');
                    await this.loadSchedules();
                } catch (error) {
                    console.error(' Failed to confirm schedule generation:', error);
                    this.showToast('Failed to confirm schedule generation: ' + error.message, 'danger');
                    this.updateGenerationStatus('Failed to confirm: ' + error.message, 'danger');
                } finally {
                    this.showLoading(false);
                }
            }

            displayGenerationResults(result, options = {}) {
                const container = document.getElementById('generationResults');
                if (!container) {
                    return;
                }

                const coverageSummary = (result && (result.coverage || result.preview)) || {};
                const coverageDetails = Array.isArray(coverageSummary.coverageDetails) ? coverageSummary.coverageDetails : [];
                const periodLabel = this.formatPeriodLabel(coverageSummary.periodStart || result?.periodStart, coverageSummary.periodEnd || result?.periodEnd) || '';
                const coveragePercentRaw = Number(coverageSummary.coveragePercent || 0);
                const coveragePercent = Number.isFinite(coveragePercentRaw) ? Math.round(coveragePercentRaw) : 0;
                const shortfallDaysRaw = Number(coverageSummary.shortfallDays || 0);
                const shortfallDays = Number.isFinite(shortfallDaysRaw) ? shortfallDaysRaw : 0;
                const conflicts = Array.isArray(result?.conflicts) ? result.conflicts : [];
                const skipped = Array.isArray(result?.skipped) ? result.skipped : [];

                const conflictItems = conflicts.map(conflict => {
                    const name = this.escapeHtml(conflict.userName || conflict.user || conflict.userId || 'Agent');
                    const period = this.formatPeriodLabel(conflict.periodStart, conflict.periodEnd) || '';
                    const reason = this.escapeHtml(conflict.error || conflict.reason || conflict.type || 'Conflict detected');
                    const periodLabelHtml = period ? `  ${this.escapeHtml(period)}` : '';
                    return `<li>${name}${periodLabelHtml}  ${reason}</li>`;
                }).join('');
                const conflictsHtml = conflicts.length
                    ? `<div class="alert alert-warning-modern mt-3"><strong>Conflicts detected:</strong><ul class="mb-0 mt-2">${conflictItems}</ul></div>`
                    : `<div class="alert alert-success-modern mt-3"><i class="fas fa-check-circle me-2"></i>No conflicts detected.</div>`;

                const skippedItems = skipped.map(entry => {
                    const name = this.escapeHtml(entry.userName || entry.user || entry.userId || 'Agent');
                    const reason = this.escapeHtml(entry.reason || 'Skipped due to rule constraints');
                    return `<li>${name}  ${reason}</li>`;
                }).join('');
                const skippedHtml = skipped.length
                    ? `<div class="alert alert-info-modern mt-3"><strong>Skipped users:</strong><ul class="mb-0 mt-2">${skippedItems}</ul></div>`
                    : '';

                container.classList.remove('d-none');
                container.style.display = 'block';
                container.innerHTML = `
                    <div class="modern-card">
                        <div class="modern-card-header">
                            <h5 class="modern-card-title">
                                <i class="fas fa-check-circle text-success"></i>
                                Shift Assignments Saved
                            </h5>
                        </div>
                        <div class="modern-card-body">
                            <div class="row g-3">
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-number text-success">${result.generated || 0}</div>
                                        <div class="metric-label">Assignments</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-number text-primary">${coveragePercent}%</div>
                                        <div class="metric-label">% Days Meeting Coverage</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-number text-warning">${shortfallDays}</div>
                                        <div class="metric-label">Days Below Target</div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="metric-card">
                                        <div class="metric-number text-info">${this.escapeHtml(periodLabel)}</div>
                                        <div class="metric-label">Assignment Period</div>
                                    </div>
                                </div>
                            </div>
                            ${this.renderCoveragePreviewTable(coverageDetails)}
                            ${conflictsHtml}
                            ${skippedHtml}
                            <div class="mt-3">
                                <p class="text-muted mb-0">
                                    <i class="fas fa-info-circle me-1"></i>
                                    All assignments are pending approval. Review them in the Schedule Management tab.
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }

            updateGenerationStatus(message, type = 'info') {
                const container = document.getElementById('generationStatus');
                if (!container) return;

                const alertClass = {
                    success: 'alert-success-modern',
                    danger: 'alert-danger-modern',
                    warning: 'alert-warning-modern',
                    info: 'alert-info-modern'
                }[type] || 'alert-info-modern';

                container.innerHTML = `
                        <div class="alert ${alertClass}">
                            <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'danger' ? 'exclamation-circle' : 'info-circle'} me-2"></i>
                            ${message}
                        </div>
                    `;
            }

            async createShiftSlot() {
                try {
                    this.showLoading(true);

                    const getElementValue = (id, fallback = '') => {
                        const element = document.getElementById(id);
                        if (!element) {
                            return fallback;
                        }

                        const value = element.value ?? '';
                        if (value === '' || value === null || value === undefined) {
                            return fallback;
                        }

                        return value;
                    };

                    // Get selected days
                    const selectedDays = [];
                    const dayCheckboxes = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                    dayCheckboxes.forEach(day => {
                        const checkbox = document.getElementById(day);
                        if (checkbox && checkbox.checked) {
                            const parsedDay = parseInt(checkbox.value, 10);
                            if (!Number.isNaN(parsedDay)) {
                                selectedDays.push(parsedDay);
                            }
                        }
                    });

                    const slotData = {
                        name: getElementValue('slotName'),
                        startTime: getElementValue('slotStartTime'),
                        endTime: getElementValue('slotEndTime'),
                        daysOfWeek: selectedDays,
                        department: getElementValue('slotDepartment'),
                        location: getElementValue('slotLocation'),
                        description: getElementValue('slotDescription'),
                        createdBy: this.getCurrentUserId() || 'System'
                    };

                    const validation = this.validateEnhancedShiftSlot(slotData);
                    if (!validation.isValid) {
                        throw new Error('Validation failed: ' + validation.errors.join(', '));
                    }

                    console.log('Creating shift slot with data:', slotData);

                    let result;
                    let usedLegacyEndpoint = false;

                    try {
                        result = await this.callServerFunction('clientCreateEnhancedShiftSlot', slotData);
                    } catch (primaryError) {
                        if (this.shouldFallbackToLegacySlotCreation(primaryError)) {
                            console.warn('Enhanced endpoint unavailable, retrying legacy shift slot creation.', primaryError);
                            usedLegacyEndpoint = true;
                            result = await this.callServerFunction('clientCreateShiftSlot', slotData);
                        } else {
                            throw primaryError;
                        }
                    }

                    let normalized = this.normalizeShiftSlotCreationResponse(result);
                    if (!normalized.success && !usedLegacyEndpoint && normalized.needsLegacyFallback) {
                        console.warn('Enhanced endpoint returned an unexpected response. Falling back to legacy shift slot creation.');
                        usedLegacyEndpoint = true;
                        result = await this.callServerFunction('clientCreateShiftSlot', slotData);
                        normalized = this.normalizeShiftSlotCreationResponse(result);
                    }

                    if (normalized.success) {
                        const successMessage = normalized.message || 'Shift slot created successfully!';
                        this.showToast(successMessage, 'success');
                        this.resetShiftSlotForm();
                        await this.loadShiftSlots();
                    } else {
                        if (normalized.needsLegacyFallback) {
                            const confirmed = await this.confirmShiftSlotCreation(slotData, { attempts: 4, delayMs: 450 });
                            if (confirmed) {
                                const fallbackMessage = 'Shift slot created successfully. Server confirmation was delayed, but we verified it and refreshed the schedule.';
                                console.info('Shift slot creation confirmed via post-check despite missing server response.');
                                this.showToast(fallbackMessage, 'success');
                                this.resetShiftSlotForm();
                                await this.loadShiftSlots();
                                return;
                            }

                            const fallbackMessage = 'The server did not confirm the shift slot creation. We refreshed the schedule so you can verify the new slot manually.';
                            console.warn('Shift slot creation could not be confirmed due to missing server response.');
                            this.showToast(fallbackMessage, 'warning');
                            this.resetShiftSlotForm();
                            await this.loadShiftSlots();
                            return;
                        }

                        throw new Error(normalized.error || 'Failed to create shift slot');
                    }

                } catch (error) {
                    console.error(' Error creating shift slot:', error);
                    this.showToast('Failed to create shift slot: ' + error.message, 'danger');
                } finally {
                    this.showLoading(false);
                }
            }

            shouldFallbackToLegacySlotCreation(error) {
                if (!error) {
                    return false;
                }

                const message = typeof error === 'string' ? error : (error.message || '');
                if (!message) {
                    return false;
                }

                const normalized = message.toLowerCase();
                return normalized.includes('not a function') ||
                    normalized.includes('is not defined') ||
                    normalized.includes('unknown function') ||
                    normalized.includes('cannot call');
            }

            normalizeShiftSlotCreationResponse(rawResult) {
                const coerceString = (value) => {
                    if (value === null || value === undefined) {
                        return '';
                    }
                    return String(value).trim();
                };
                const successTokens = ['success', 'ok', 'created', 'done', 'completed', 'saved'];
                const hasSuccessKeyword = (text) => {
                    if (!text) {
                        return false;
                    }
                    const normalized = text.toLowerCase();
                    return successTokens.some(token => normalized.includes(token));
                };

                if (rawResult && typeof rawResult === 'object') {
                    if (rawResult.success === true) {
                        return {
                            success: true,
                            message: coerceString(rawResult.message) || coerceString(rawResult.status),
                            data: rawResult,
                            needsLegacyFallback: false
                        };
                    }

                    if (rawResult.result === true) {
                        return {
                            success: true,
                            message: coerceString(rawResult.message) || 'Shift slot created successfully',
                            data: Object.assign({ success: true }, rawResult),
                            needsLegacyFallback: false
                        };
                    }

                    if (rawResult.success === false) {
                        const errorMessage = coerceString(rawResult.error) || coerceString(rawResult.message) || 'Server reported failure without details';
                        return {
                            success: false,
                            error: errorMessage,
                            data: rawResult,
                            needsLegacyFallback: false
                        };
                    }

                    const nestedResult = rawResult.result;
                    if (nestedResult && typeof nestedResult === 'object') {
                        if (nestedResult.success === true) {
                            return {
                                success: true,
                                message: coerceString(nestedResult.message) || coerceString(rawResult.message) || 'Shift slot created successfully',
                                data: Object.assign({ success: true }, rawResult, nestedResult),
                                needsLegacyFallback: false
                            };
                        }

                        const nestedMessage = coerceString(nestedResult.message || nestedResult.status);
                        if (hasSuccessKeyword(nestedMessage)) {
                            return {
                                success: true,
                                message: nestedMessage,
                                data: Object.assign({ success: true }, rawResult, { message: nestedMessage }),
                                needsLegacyFallback: false
                            };
                        }
                    }

                    const candidateMessages = [
                        rawResult.message,
                        rawResult.status,
                        rawResult.result,
                        rawResult.state,
                        rawResult.outcome,
                        rawResult.statusText
                    ].map(value => coerceString(value)).filter(Boolean);

                    const successMessage = candidateMessages.find(hasSuccessKeyword);
                    if (successMessage) {
                        return {
                            success: true,
                            message: successMessage,
                            data: Object.assign({ success: true }, rawResult, { message: successMessage }),
                            needsLegacyFallback: false
                        };
                    }

                    if (rawResult.slot && typeof rawResult.slot === 'object') {
                        return {
                            success: true,
                            message: coerceString(rawResult.message) || 'Shift slot created successfully',
                            data: Object.assign({ success: true }, rawResult),
                            needsLegacyFallback: false
                        };
                    }

                    if (rawResult.data && typeof rawResult.data === 'object') {
                        if (rawResult.data.success === true) {
                            return {
                                success: true,
                                message: coerceString(rawResult.data.message) || coerceString(rawResult.message) || 'Shift slot created successfully',
                                data: Object.assign({ success: true }, rawResult, rawResult.data),
                                needsLegacyFallback: false
                            };
                        }

                        const dataMessage = coerceString(rawResult.data.message || rawResult.data.status);
                        if (hasSuccessKeyword(dataMessage)) {
                            return {
                                success: true,
                                message: dataMessage,
                                data: Object.assign({ success: true }, rawResult, rawResult.data),
                                needsLegacyFallback: false
                            };
                        }
                    }

                    if (typeof rawResult.statusCode === 'number' && rawResult.statusCode >= 200 && rawResult.statusCode < 300) {
                        return {
                            success: true,
                            message: coerceString(rawResult.message) || `Shift slot created (status ${rawResult.statusCode})`,
                            data: Object.assign({ success: true }, rawResult),
                            needsLegacyFallback: false
                        };
                    }

                    if (Object.keys(rawResult).length === 0) {
                        return {
                            success: false,
                            error: 'Empty response object received from server',
                            data: rawResult,
                            needsLegacyFallback: true
                        };
                    }

                    return {
                        success: false,
                        error: 'Unexpected response structure from server',
                        data: rawResult,
                        needsLegacyFallback: true
                    };
                }

                if (rawResult === true) {
                    return {
                        success: true,
                        message: 'Shift slot created successfully',
                        data: { success: true },
                        needsLegacyFallback: false
                    };
                }

                if (rawResult === false) {
                    return {
                        success: false,
                        error: 'Server indicated shift slot creation failure',
                        data: { success: false },
                        needsLegacyFallback: false
                    };
                }

                if (typeof rawResult === 'string') {
                    const trimmed = rawResult.trim();
                    if (!trimmed) {
                        return {
                            success: false,
                            error: 'Empty response received from server',
                            data: rawResult,
                            needsLegacyFallback: true
                        };
                    }

                    if (['success', 'ok', 'created', 'done', 'completed', 'saved'].some(token => trimmed.toLowerCase().includes(token))) {
                        return {
                            success: true,
                            message: trimmed,
                            data: { success: true, message: trimmed },
                            needsLegacyFallback: false
                        };
                    }

                    return {
                        success: false,
                        error: trimmed,
                        data: rawResult,
                        needsLegacyFallback: false
                    };
                }

                if (rawResult === null || rawResult === undefined) {
                    return {
                        success: false,
                        error: 'No response received from server',
                        data: rawResult,
                        needsLegacyFallback: true
                    };
                }

                return {
                    success: false,
                    error: 'Unexpected response type received from server',
                    data: rawResult,
                    needsLegacyFallback: true
                };
            }

            async confirmShiftSlotCreation(slotData, options = {}) {
                const { attempts = 3, delayMs = 400 } = options || {};
                const attemptLimit = Number.isFinite(attempts) && attempts > 0 ? Math.min(Math.floor(attempts), 10) : 1;
                const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

                const normalizeString = (value) => (value || '').toString().trim().toLowerCase();
                const normalizeTime = (value) => {
                    if (value === null || value === undefined) {
                        return '';
                    }

                    const coerceToTimeTuple = (input) => {
                        if (input instanceof Date) {
                            return [input.getHours(), input.getMinutes()];
                        }

                        const stringValue = input.toString().trim();
                        if (!stringValue) {
                            return null;
                        }

                        const meridiemMatch = stringValue.match(/^(\d{1,2})(?::(\d{2}))?(?::(\d{2}))?\s*(AM|PM)$/i);
                        if (meridiemMatch) {
                            let hours = parseInt(meridiemMatch[1], 10) % 12;
                            if (meridiemMatch[4].toUpperCase() === 'PM') {
                                hours += 12;
                            }
                            const minutes = meridiemMatch[2] !== undefined ? parseInt(meridiemMatch[2], 10) : 0;
                            return [hours, Number.isFinite(minutes) ? minutes : 0];
                        }

                        const directMatch = stringValue.match(/^(\d{1,2})(?::(\d{2}))?(?::(\d{2})(?:\.(\d+))?)?$/);
                        if (directMatch) {
                            const hours = parseInt(directMatch[1], 10);
                            const minutes = directMatch[2] !== undefined ? parseInt(directMatch[2], 10) : 0;
                            return [hours, Number.isFinite(minutes) ? minutes : 0];
                        }

                        const compactMatch = stringValue.match(/^(\d{1,2})(\d{2})$/);
                        if (compactMatch) {
                            return [parseInt(compactMatch[1], 10), parseInt(compactMatch[2], 10)];
                        }

                        const meridiemShortMatch = stringValue.match(/^(\d{1,2})\s*(AM|PM)$/i);
                        if (meridiemShortMatch) {
                            let hours = parseInt(meridiemShortMatch[1], 10) % 12;
                            if (meridiemShortMatch[2].toUpperCase() === 'PM') {
                                hours += 12;
                            }
                            return [hours, 0];
                        }

                        const numericValue = Number(stringValue);
                        if (!Number.isNaN(numericValue)) {
                            if (numericValue >= 0 && numericValue < 1) {
                                const totalMinutes = Math.round(numericValue * 24 * 60);
                                return [Math.floor(totalMinutes / 60), totalMinutes % 60];
                            }

                            const millisDate = new Date(numericValue);
                            if (!Number.isNaN(millisDate.getTime())) {
                                return [millisDate.getUTCHours(), millisDate.getUTCMinutes()];
                            }
                        }

                        const parsedDate = new Date(stringValue);
                        if (!Number.isNaN(parsedDate.getTime())) {
                            return [parsedDate.getHours(), parsedDate.getMinutes()];
                        }

                        return null;
                    };

                    const timeTuple = coerceToTimeTuple(value);
                    if (!timeTuple) {
                        return value.toString().trim();
                    }

                    const [hours, minutes] = timeTuple;
                    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) {
                        return value.toString().trim();
                    }

                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                };
                const normalizeDays = (days) => {
                    if (Array.isArray(days)) {
                        return days.map(day => parseInt(day, 10)).filter(Number.isFinite).sort((a, b) => a - b).join(',');
                    }
                    if (typeof days === 'string') {
                        return days
                            .split(/[^0-9]+/)
                            .map(day => parseInt(day, 10))
                            .filter(Number.isFinite)
                            .sort((a, b) => a - b)
                            .join(',');
                    }
                    return '';
                };

                const expectedName = normalizeString(slotData.name);
                const expectedStart = normalizeTime(slotData.startTime);
                const expectedEnd = normalizeTime(slotData.endTime);
                const expectedDays = normalizeDays(slotData.daysOfWeek);

                const matchesSlot = (slot) => {
                    if (!slot || typeof slot !== 'object') {
                        return false;
                    }

                    const slotName = normalizeString(slot.Name || slot.name);
                    const slotStart = normalizeTime(slot.StartTime || slot.startTime);
                    const slotEnd = normalizeTime(slot.EndTime || slot.endTime);
                    const slotDays = normalizeDays(slot.DaysOfWeekArray || slot.DaysOfWeek || slot.daysOfWeek);

                    return slotName === expectedName &&
                        slotStart === expectedStart &&
                        slotEnd === expectedEnd &&
                        (!!expectedDays ? slotDays === expectedDays : true);
                };

                let lastError = null;

                const performCheck = async () => {
                    const slots = await this.callServerFunction('clientGetAllShiftSlots');
                    if (!Array.isArray(slots)) {
                        return false;
                    }
                    return slots.some(matchesSlot);
                };

                for (let attempt = 0; attempt < attemptLimit; attempt++) {
                    try {
                        const matched = await performCheck();
                        if (matched) {
                            return true;
                        }
                    } catch (error) {
                        lastError = error;
                        break;
                    }

                    if (attempt < attemptLimit - 1 && delayMs > 0) {
                        await delay(delayMs);
                    }
                }

                if (lastError) {
                    console.warn('Unable to verify shift slot creation after missing response:', lastError);
                }

                return false;
            }

            validateEnhancedShiftSlot(slotData) {
                const errors = [];

                if (!slotData || typeof slotData !== 'object') {
                    return { isValid: false, errors: ['Missing shift slot details'] };
                }

                if (!slotData.name || slotData.name.trim().length < 3) {
                    errors.push('Slot name must be at least 3 characters');
                }

                if (!slotData.startTime || !slotData.endTime) {
                    errors.push('Start time and end time are required');
                } else if (slotData.startTime === slotData.endTime) {
                    errors.push('Start and end times cannot be the same');
                }

                if (!Array.isArray(slotData.daysOfWeek) || slotData.daysOfWeek.length === 0) {
                    errors.push('Select at least one day of the week');
                }

                if (!slotData.department) {
                    errors.push('Department is required');
                }

                if (slotData.startTime && slotData.endTime) {
                    const start = new Date(`2000-01-01 ${slotData.startTime}`);
                    const end = new Date(`2000-01-01 ${slotData.endTime}`);
                    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                        errors.push('Enter valid 12-hour start and end times (e.g., 08:00 AM)');
                    }
                }

                return {
                    isValid: errors.length === 0,
                    errors: errors
                };
            }

            resetShiftSlotForm() {
                document.getElementById('shiftSlotForm').reset();

                // Reset checkboxes to weekdays default
                const dayCheckboxes = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                dayCheckboxes.forEach((day, index) => {
                    const checkbox = document.getElementById(day);
                    if (checkbox) {
                        checkbox.checked = [1,2,3,4,5].includes(index === 0 ? 0 : index);
                    }
                });

                // Reset toggles
                const overtimeToggle = document.getElementById('enableOvertime');
                const overtimeConfig = document.getElementById('overtimeConfig');
                const staggeredToggle = document.getElementById('enableStaggeredBreaks');
                const staggeredConfig = document.getElementById('staggeredBreaksConfig');

                if (overtimeToggle) {
                    overtimeToggle.checked = false;
                }
                if (overtimeConfig) {
                    overtimeConfig.classList.add('d-none');
                }
                if (staggeredToggle) {
                    staggeredToggle.checked = true;
                }
                if (staggeredConfig) {
                    staggeredConfig.style.display = 'block';
                }
            }

            calculateOptimalBreakTimes() {
                const startTime = document.getElementById('slotStartTime').value;
                const endTime = document.getElementById('slotEndTime').value;

                if (!startTime || !endTime) return;

                const start = new Date(`2000-01-01 ${startTime}`);
                const end = new Date(`2000-01-01 ${endTime}`);
                const durationHours = (end - start) / (1000 * 60 * 60);

                // Suggest optimal break timing based on shift length
                let break1Duration = 15;
                let lunchDuration = 30;
                let break2Duration = 15;

                if (durationHours >= 8) {
                    lunchDuration = 30; // 30-minute lunch for 8+ hour shifts
                } else if (durationHours >= 6) {
                    lunchDuration = 30; // 30-minute lunch for 6-8 hour shifts  
                } else {
                    lunchDuration = 15; // 15-minute break for shorter shifts
                    break2Duration = 0; // No second break for short shifts
                }

                // Update form fields if they haven't been manually changed
                const break1Field = document.getElementById('slotBreak1Duration');
                const lunchField = document.getElementById('slotLunchDuration');
                const break2Field = document.getElementById('slotBreak2Duration');

                if (break1Field) {
                    break1Field.value = break1Duration;
                }
                if (lunchField) {
                    lunchField.value = lunchDuration;
                }
                if (break2Field) {
                    break2Field.value = break2Duration;
                }

                console.log(`Calculated optimal breaks for ${durationHours}h shift: ${break1Duration}m break, ${lunchDuration}m lunch, ${break2Duration}m break`);
            }

            async loadSchedules() {
                try {
                    const filters = {
                        startDate: document.getElementById('filterStartDate')?.value,
                        endDate: document.getElementById('filterEndDate')?.value,
                        userName: document.getElementById('filterUser')?.value,
                        status: document.getElementById('filterStatus')?.value
                    };

                    const result = await this.callServerFunction('clientGetAllSchedules', filters);

                    const { schedules, total, error, errorSeverity, notice } = this.parseSchedulesResponse(result);

                    const safeSchedules = Array.isArray(schedules) ? schedules : [];
                    this.cachedSchedules = safeSchedules;

                    if (error) {
                        const severity = (errorSeverity || 'warning').toLowerCase();
                        if (severity === 'danger' || severity === 'error') {
                            console.error(' Schedule response issue:', error);
                            this.showToast(`Failed to load schedules: ${error}`, 'danger');
                        } else {
                            console.info(' Schedule response notice:', error);
                        }
                    }

                    if (notice) {
                        console.info(' Schedule response notice:', notice);
                    }

                    this.displaySchedules(safeSchedules);

                    const totalElement = document.getElementById('totalSchedules');
                    if (totalElement) {
                        const numericTotal = Number(total);
                        const safeTotal = Number.isFinite(numericTotal) && numericTotal >= 0 ? numericTotal : safeSchedules.length;
                        totalElement.textContent = safeTotal;
                    }

                } catch (error) {
                    console.error(' Error loading schedules:', error);
                    this.displaySchedules(this.cachedSchedules || []);
                    this.showToast('Failed to load schedules: ' + (error.message || 'Unexpected error'), 'danger');
                    throw error;
                }
            }

            displaySchedules(schedules) {
                const tbody = document.getElementById('schedulesTableBody');
                if (!tbody) return;

                if (schedules.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" class="text-center text-muted py-4">No schedules found</td></tr>';
                    return;
                }

                const normalizedSchedules = schedules.map(schedule => this.normalizeScheduleRecord(schedule));

                tbody.innerHTML = normalizedSchedules.map(schedule => `
                        <tr>
                            <td>
                                <input type="checkbox" class="form-check-input schedule-checkbox"
                                      value="${schedule.ID || ''}"
                                      ${schedule.Status === 'PENDING' ? '' : 'disabled'}>
                            </td>
                            <td>${schedule.UserName || 'N/A'}</td>
                            <td>${this.formatSchedulePeriod(schedule)}</td>
                            <td>${schedule.SlotName || 'N/A'}</td>
                            <td>${schedule.StartTime || ''} - ${schedule.EndTime || ''}</td>
                            <td>
                                <span class="status-badge ${this.getStatusBadgeClass(schedule.Status)}">
                                    ${schedule.Status || 'PENDING'}
                                </span>
                            </td>
                            <td>
                                <span class="badge ${this.getPriorityClass(schedule.Priority)}">
                                    ${this.getPriorityText(schedule.Priority)}
                                </span>
                            </td>
                            <td>
                                <div class="btn-group btn-group-sm" role="group">
                                    ${schedule.Status === 'PENDING' ? `
                                        <button class="btn btn-success-modern btn-sm" 
                                                onclick="scheduleManager.approveSchedule('${schedule.ID}')">
                                            <i class="fas fa-check"></i>
                                        </button>
                                        <button class="btn btn-danger-modern btn-sm" 
                                                onclick="scheduleManager.rejectSchedule('${schedule.ID}')">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    ` : ''}
                                    <button class="btn btn-info btn-sm" 
                                            onclick="scheduleManager.viewScheduleDetails('${schedule.ID}')">
                                        <i class="fas fa-eye"></i>
                                    </button>
                                </div>
                            </td>
                        </tr>
                    `).join('');
            }

            parseSchedulesResponse(result) {
                const baseResponse = {
                    schedules: [],
                    total: 0,
                    error: null,
                    errorSeverity: 'warning',
                    notice: null
                };

                if (result == null) {
                    return {
                        ...baseResponse,
                        notice: 'No schedules were returned by the server. Retaining the current table view.'
                    };
                }

                if (Array.isArray(result)) {
                    return {
                        ...baseResponse,
                        schedules: result,
                        total: result.length
                    };
                }

                if (typeof result === 'string') {
                    try {
                        return this.parseSchedulesResponse(JSON.parse(result));
                    } catch (parseError) {
                        return {
                            ...baseResponse,
                            error: result,
                            errorSeverity: 'danger'
                        };
                    }
                }

                if (typeof result === 'object') {
                    const nestedDataSources = [
                        result.schedules,
                        result.Schedules,
                        result.data?.schedules,
                        result.data?.Schedules,
                        result.data?.items,
                        result.data,
                        result.items,
                        result.records,
                        result.payload,
                        result.results,
                        result.response,
                        result.body
                    ];

                    const candidateSource = nestedDataSources.find(source => this.isScheduleArrayLike(source)) ||
                        Object.values(result).find(value => this.isScheduleArrayLike(value)) ||
                        (this.isScheduleArrayLike(result) ? result : null);

                    const normalizedSchedules = this.normalizeScheduleArray(candidateSource);

                    if (normalizedSchedules.length) {
                        const totalCandidates = [
                            result.total,
                            result.count,
                            result.data?.total,
                            candidateSource && typeof candidateSource.length === 'number' ? candidateSource.length : normalizedSchedules.length
                        ];

                        const resolvedTotal = totalCandidates.find(value => Number.isFinite(Number(value)));

                        const severity = result.success === false ? 'danger' : 'warning';

                        return {
                            ...baseResponse,
                            schedules: normalizedSchedules,
                            total: Number.isFinite(Number(resolvedTotal)) ? Number(resolvedTotal) : normalizedSchedules.length,
                            error: result.success === false ? (result.error || result.message || 'Server returned a failure response.') : null,
                            errorSeverity: severity,
                            notice: result.success === true && !normalizedSchedules.length ? 'No schedules matched the selected filters.' : null
                        };
                    }

                    const textualMessage = [result.notice, result.message, result.error, result.warning]
                        .find(value => typeof value === 'string' && value.trim().length);

                    if (textualMessage) {
                        const normalizedMessage = textualMessage.trim();
                        const severityHint = String(
                            result.errorSeverity ||
                            result.severity ||
                            result.status ||
                            result.level ||
                            result.type ||
                            (result.success === false ? 'danger' : '')
                        ).toLowerCase();

                        const dangerKeywords = ['danger', 'error', 'critical', 'severe', 'fail', 'failure'];
                        const isDanger = dangerKeywords.some(keyword => severityHint.includes(keyword));

                        if (isDanger) {
                            return {
                                ...baseResponse,
                                error: normalizedMessage,
                                errorSeverity: 'danger'
                            };
                        }

                        return {
                            ...baseResponse,
                            notice: normalizedMessage
                        };
                    }

                    if (result.success === false) {
                        return {
                            ...baseResponse,
                            error: result.error || result.message || 'Server returned a failure response.',
                            errorSeverity: 'danger'
                        };
                    }

                    if (result.success === true) {
                        return {
                            ...baseResponse,
                            notice: 'The server reported success but did not include schedule details. Displaying the previous data.'
                        };
                    }
                }

                return {
                    ...baseResponse,
                    error: 'Unexpected response format received while loading schedules.',
                    errorSeverity: 'danger'
                };
            }

            isScheduleArrayLike(value) {
                if (!value) {
                    return false;
                }

                if (Array.isArray(value)) {
                    return value.some(item => item && typeof item === 'object');
                }

                if (typeof value === 'object' && typeof value.length === 'number') {
                    return value.length > 0;
                }

                if (typeof value === 'object') {
                    const numericKeys = Object.keys(value).filter(key => /^\d+$/.test(key));
                    return numericKeys.length > 0;
                }

                return false;
            }

            normalizeScheduleArray(source) {
                if (!this.isScheduleArrayLike(source)) {
                    return [];
                }

                let iterable = [];

                if (Array.isArray(source)) {
                    iterable = source;
                } else if (typeof source.length === 'number') {
                    iterable = Array.from({ length: source.length }, (_, index) => source[index]);
                } else {
                    const numericKeys = Object.keys(source)
                        .filter(key => /^\d+$/.test(key))
                        .sort((a, b) => Number(a) - Number(b));
                    iterable = numericKeys.length ? numericKeys.map(key => source[key]) : Object.values(source);
                }

                return iterable
                    .map(item => this.normalizeScheduleRecord(item))
                    .filter(item => item && typeof item === 'object');
            }

            normalizeScheduleRecord(record) {
                if (!record || typeof record !== 'object') {
                    return {};
                }

                const normalized = { ...record };

                const resolveValue = (keys, fallback = '') => {
                    for (const key of keys) {
                        if (!(key in record)) {
                            continue;
                        }

                        const value = record[key];
                        if (value === undefined || value === null) {
                            continue;
                        }

                        if (typeof value === 'string') {
                            const trimmed = value.trim();
                            if (trimmed.length > 0) {
                                return trimmed;
                            }
                            continue;
                        }

                        return value;
                    }
                    return fallback;
                };

                normalized.ID = resolveValue(['ID', 'Id', 'id', 'ScheduleID', 'ScheduleId', 'scheduleID', 'scheduleId', 'Schedule Id']);
                normalized.UserName = resolveValue(['UserName', 'User', 'User Name', 'Agent', 'AgentName', 'Agent Name', 'Name']);
                normalized.Date = resolveValue(['Date', 'date', 'ScheduleDate', 'Schedule Date', 'Day', 'ShiftDate']);
                normalized.PeriodStart = resolveValue(['PeriodStart', 'StartDate', 'AssignmentStart', 'ScheduleStart'], normalized.Date);
                normalized.PeriodEnd = resolveValue(['PeriodEnd', 'EndDate', 'AssignmentEnd', 'ScheduleEnd'], normalized.PeriodStart || normalized.Date);
                normalized.SlotName = resolveValue(['SlotName', 'slotName', 'Slot', 'Slot Name', 'Shift', 'ShiftName', 'Shift Name']);
                normalized.StartTime = resolveValue(['StartTime', 'startTime', 'Start', 'Start Time', 'ShiftStart', 'Shift Start']);
                normalized.EndTime = resolveValue(['EndTime', 'endTime', 'End', 'End Time', 'ShiftEnd', 'Shift End']);
                const statusValue = resolveValue(['Status', 'status', 'ScheduleStatus', 'Schedule Status'], 'PENDING') || 'PENDING';
                normalized.Status = typeof statusValue === 'string' ? statusValue.trim().toUpperCase() : String(statusValue || 'PENDING').toUpperCase();

                const priorityValue = resolveValue(['Priority', 'priority', 'PriorityLevel', 'Priority Level', 'Rank', 'Importance'], 1);
                const numericPriority = Number(priorityValue);
                const safePriority = Number.isFinite(numericPriority) ? numericPriority : 1;
                normalized.Priority = Math.min(Math.max(parseInt(safePriority, 10) || 1, 0), 4);

                if (normalized.ID !== undefined && normalized.ID !== null) {
                    normalized.ID = String(normalized.ID);
                }

                return normalized;
            }

            async loadAttendanceDashboard(force = false) {
                const year = this.getSelectedAttendanceYear();
                if (!Number.isFinite(year)) {
                    console.warn('Unable to resolve attendance year for dashboard rendering.');
                    return;
                }

                if (force || !this.attendanceDashboardData || this.attendanceDashboardYear !== year) {
                    await this.fetchAttendanceDashboardData(year);
                }

                this.initializeAttendanceDashboard();
            }

            async fetchAttendanceDashboardData(year) {
                try {
                    const prefetch = this.attendanceDashboardPrefetch;
                    if (prefetch && prefetch.year === year && Array.isArray(prefetch.records)) {
                        this.attendanceDashboardYear = year;
                        this.attendanceDashboardRecords = prefetch.records.slice();
                        const filteredPrefetchRecords = this.filterAttendanceDashboardRecords(
                            this.attendanceDashboardRecords,
                            this.attendanceDashboardUserFilter
                        );
                        this.attendanceDashboardData = this.computeAttendanceDashboard(filteredPrefetchRecords, year);
                        this.destroyAttendanceDashboardCharts();
                        return;
                    }

                    const startDate = `${year}-01-01`;
                    const endDate = `${year}-12-31`;
                    const campaignId = this.getCurrentCampaignId ? this.getCurrentCampaignId() || null : null;
                    const response = await this.callServerFunction('clientGetAttendanceDataRange', startDate, endDate, campaignId);

                    if (!response || response.success !== true) {
                        throw new Error(response?.error || 'Unable to retrieve attendance records.');
                    }

                    const records = Array.isArray(response.records) ? response.records : [];
                    this.attendanceDashboardPrefetch = {
                        year,
                        records: records.slice(),
                        dashboard: prefetch && prefetch.dashboard ? prefetch.dashboard : null
                    };
                    this.attendanceDashboardRecords = records;
                    this.attendanceDashboardYear = year;
                    const filteredRecords = this.filterAttendanceDashboardRecords(records, this.attendanceDashboardUserFilter);
                    this.attendanceDashboardData = this.computeAttendanceDashboard(filteredRecords, year);
                    this.destroyAttendanceDashboardCharts();
                } catch (error) {
                    console.error('Error loading attendance dashboard data:', error);
                    this.attendanceDashboardYear = year;
                    this.attendanceDashboardRecords = [];
                    this.attendanceDashboardData = this.computeAttendanceDashboard([], year);
                    this.destroyAttendanceDashboardCharts();
                    this.showToast('Failed to load attendance dashboard: ' + error.message, 'danger');
                }
            }

            destroyAttendanceDashboardCharts() {
                Object.values(this.attendanceCharts).forEach(chart => {
                    if (chart && typeof chart.destroy === 'function') {
                        chart.destroy();
                    }
                });
                this.attendanceCharts = {};
                this.attendanceDashboardInitialized = false;
            }

            getSelectedAttendanceYear() {
                const yearSelect = document.getElementById('attendanceYear');
                const parsed = yearSelect ? parseInt(yearSelect.value, 10) : NaN;
                if (Number.isFinite(parsed)) {
                    return parsed;
                }
                return new Date().getFullYear();
            }

            computeAttendanceDashboard(records, year) {
                const months = [
                    'January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'
                ];

                const monthStats = months.map(() => ({
                    present: 0,
                    late: 0,
                    absent: 0,
                    sick: 0,
                    vacation: 0,
                    other: 0,
                    total: 0
                }));
                const yearlyTotals = { present: 0, late: 0, absent: 0, sick: 0, vacation: 0, other: 0 };
                const biWeeklyBuckets = new Map();
                const recognitionCategories = new Set(['present', 'late', 'absent', 'sick']);
                const userStatsMap = new Map();
                const recognitionPeriodMaps = {
                    weekly: new Map(),
                    biWeekly: new Map(),
                    monthly: new Map(),
                    quarterly: new Map(),
                    yearly: new Map()
                };

                const getWeekBucketKey = (date) => {
                    const start = new Date(date.getTime());
                    const day = start.getDay();
                    const diff = (day + 6) % 7; // convert Sunday(0) -> 6, Monday(1) -> 0
                    start.setDate(start.getDate() - diff);
                    start.setHours(0, 0, 0, 0);
                    const label = `Week of ${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;
                    const key = `week:${start.getFullYear()}-${String(start.getMonth() + 1).padStart(2, '0')}-${String(start.getDate()).padStart(2, '0')}`;
                    return { key, label, order: start.getTime() };
                };

                const getMonthlyBucketKey = (date) => {
                    const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                    const key = `month:${monthStart.getFullYear()}-${String(monthStart.getMonth() + 1).padStart(2, '0')}`;
                    const label = `${months[monthStart.getMonth()]} ${monthStart.getFullYear()}`;
                    return { key, label, order: monthStart.getTime() };
                };

                const getQuarterlyBucketKey = (date) => {
                    const quarterIndex = Math.floor(date.getMonth() / 3);
                    const quarterStart = new Date(date.getFullYear(), quarterIndex * 3, 1);
                    const label = `Q${quarterIndex + 1} ${quarterStart.getFullYear()}`;
                    const key = `quarter:${quarterStart.getFullYear()}-${quarterIndex + 1}`;
                    return { key, label, order: quarterStart.getTime() };
                };

                const getYearBucketKey = (date) => {
                    const yearStart = new Date(date.getFullYear(), 0, 1);
                    const label = `${yearStart.getFullYear()}`;
                    const key = `year:${yearStart.getFullYear()}`;
                    return { key, label, order: yearStart.getTime() };
                };

                const updateRecognitionBucket = (bucketMap, bucketInfo, identityKey, displayName, category) => {
                    if (!bucketInfo || !bucketInfo.key || !identityKey) {
                        return;
                    }

                    if (!bucketMap.has(bucketInfo.key)) {
                        bucketMap.set(bucketInfo.key, {
                            label: bucketInfo.label || '',
                            order: Number.isFinite(bucketInfo.order) ? bucketInfo.order : 0,
                            users: new Map()
                        });
                    }

                    const bucket = bucketMap.get(bucketInfo.key);
                    bucket.label = bucketInfo.label || bucket.label;
                    bucket.order = Number.isFinite(bucketInfo.order) ? bucketInfo.order : bucket.order;

                    if (!bucket.users.has(identityKey)) {
                        bucket.users.set(identityKey, {
                            displayName: '',
                            present: 0,
                            total: 0,
                            late: 0,
                            absent: 0,
                            sick: 0
                        });
                    }

                    const userBucketStat = bucket.users.get(identityKey);
                    userBucketStat.displayName = chooseDisplayName(userBucketStat.displayName, displayName);

                    if (category === 'present') {
                        userBucketStat.present += 1;
                    } else if (category === 'late') {
                        userBucketStat.late += 1;
                    } else if (category === 'absent') {
                        userBucketStat.absent += 1;
                    } else if (category === 'sick') {
                        userBucketStat.sick += 1;
                    }

                    userBucketStat.total += 1;
                };

                const scoreDisplayName = (value) => {
                    const text = (value || '').toString().trim();
                    if (!text) {
                        return -Infinity;
                    }
                    let score = text.length;
                    if (/\s/.test(text)) {
                        score += 10;
                    }
                    if (text.includes('@')) {
                        score -= 5;
                    }
                    return score;
                };

                const chooseDisplayName = (current, candidate) => {
                    const trimmedCandidate = (candidate || '').toString().trim();
                    if (!trimmedCandidate) {
                        return current || '';
                    }
                    const trimmedCurrent = (current || '').toString().trim();
                    if (!trimmedCurrent) {
                        return trimmedCandidate;
                    }
                    const currentScore = scoreDisplayName(trimmedCurrent);
                    const candidateScore = scoreDisplayName(trimmedCandidate);
                    return candidateScore > currentScore ? trimmedCandidate : trimmedCurrent;
                };

                const resolveRecordDisplayName = (record) => {
                    const candidates = [
                        record?.fullName,
                        record?.FullName,
                        record?.userName,
                        record?.UserName,
                        record?.user,
                        record?.User,
                        record?.email,
                        record?.Email
                    ];

                    for (const candidate of candidates) {
                        if (typeof candidate === 'string') {
                            const trimmed = candidate.trim();
                            if (trimmed) {
                                return trimmed;
                            }
                        }
                    }

                    return '';
                };

                const resolveRecordIdentityKey = (record) => {
                    const idCandidates = [
                        record?.userId,
                        record?.UserId,
                        record?.userID,
                        record?.UserID,
                        record?.id,
                        record?.ID,
                        record?.username,
                        record?.userName,
                        record?.UserName
                    ];

                    for (const candidate of idCandidates) {
                        const normalized = this.normalizeUserIdValue(candidate);
                        if (normalized) {
                            return `id:${normalized}`;
                        }
                    }

                    const emailCandidates = [record?.email, record?.Email];
                    for (const candidate of emailCandidates) {
                        const normalizedEmail = this.normalizePersonKey(candidate);
                        if (normalizedEmail) {
                            return `email:${normalizedEmail}`;
                        }
                    }

                    const nameCandidates = [
                        record?.fullName,
                        record?.FullName,
                        record?.userName,
                        record?.UserName,
                        record?.user,
                        record?.User
                    ];

                    for (const candidate of nameCandidates) {
                        const normalizedName = this.normalizePersonKey(candidate);
                        if (normalizedName) {
                            return `name:${normalizedName}`;
                        }
                    }

                    return '';
                };

                const parseDate = (value) => {
                    if (value instanceof Date) {
                        return new Date(value.getTime());
                    }
                    if (typeof value === 'number') {
                        const parsed = new Date(value);
                        return Number.isNaN(parsed.getTime()) ? null : parsed;
                    }
                    if (typeof value === 'string' && value.trim().length > 0) {
                        const parsed = new Date(value);
                        return Number.isNaN(parsed.getTime()) ? null : parsed;
                    }
                    return null;
                };

                const normalizeStatus = (status) => (typeof status === 'string' ? status.trim() : '');

                records.forEach(record => {
                    const date = parseDate(record?.date || record?.Date);
                    if (!(date instanceof Date) || Number.isNaN(date.getTime()) || date.getFullYear() !== year) {
                        return;
                    }

                    const status = normalizeStatus(record?.status || record?.Status || record?.state);
                    if (!status) {
                        return;
                    }

                    const monthIndex = date.getMonth();
                    if (monthIndex < 0 || monthIndex >= months.length) {
                        return;
                    }

                    const category = this.categorizeAttendanceStatus(status);
                    const month = monthStats[monthIndex];
                    if (!month) {
                        return;
                    }

                    if (!Object.prototype.hasOwnProperty.call(month, category)) {
                        month[category] = 0;
                    }
                    month[category] += 1;
                    month.total += 1;

                    if (!Object.prototype.hasOwnProperty.call(yearlyTotals, category)) {
                        yearlyTotals[category] = 0;
                    }
                    yearlyTotals[category] += 1;

                    if (recognitionCategories.has(category)) {
                        const identityKey = resolveRecordIdentityKey(record);
                        if (identityKey) {
                            let userStat = userStatsMap.get(identityKey);
                            if (!userStat) {
                                userStat = {
                                    displayName: '',
                                    present: 0,
                                    total: 0,
                                    late: 0,
                                    absent: 0,
                                    sick: 0
                                };
                                userStatsMap.set(identityKey, userStat);
                            }

                            const displayName = resolveRecordDisplayName(record);
                            userStat.displayName = chooseDisplayName(userStat.displayName, displayName);

                            if (category === 'present') {
                                userStat.present += 1;
                            } else if (category === 'late') {
                                userStat.late += 1;
                            } else if (category === 'absent') {
                                userStat.absent += 1;
                            } else if (category === 'sick') {
                                userStat.sick += 1;
                            }

                            userStat.total += 1;

                            const weekBucketInfo = getWeekBucketKey(date);
                            updateRecognitionBucket(recognitionPeriodMaps.weekly, weekBucketInfo, identityKey, displayName, category);

                            const biWeeklyBucketInfo = this.getBiWeeklyBucketKey(date);
                            updateRecognitionBucket(recognitionPeriodMaps.biWeekly, biWeeklyBucketInfo, identityKey, displayName, category);

                            const monthBucketInfo = getMonthlyBucketKey(date);
                            updateRecognitionBucket(recognitionPeriodMaps.monthly, monthBucketInfo, identityKey, displayName, category);

                            const quarterBucketInfo = getQuarterlyBucketKey(date);
                            updateRecognitionBucket(recognitionPeriodMaps.quarterly, quarterBucketInfo, identityKey, displayName, category);

                            const yearBucketInfo = getYearBucketKey(date);
                            updateRecognitionBucket(recognitionPeriodMaps.yearly, yearBucketInfo, identityKey, displayName, category);
                        }
                    }

                    const bucketInfo = this.getBiWeeklyBucketKey(date);
                    if (!biWeeklyBuckets.has(bucketInfo.key)) {
                        biWeeklyBuckets.set(bucketInfo.key, {
                            label: bucketInfo.label,
                            order: bucketInfo.order,
                            present: 0,
                            total: 0
                        });
                    }
                    const bucket = biWeeklyBuckets.get(bucketInfo.key);
                    if (category === 'present') {
                        bucket.present += 1;
                    }
                    bucket.total += 1;
                });

                const safePercent = (numerator, denominator) => {
                    if (!denominator) {
                        return 0;
                    }
                    return Number(((numerator / denominator) * 100).toFixed(2));
                };

                const monthlyPercent = monthStats.map(stat => safePercent(stat.present, stat.total));
                const monthlyPresent = monthStats.map(stat => stat.present);
                const monthlyAbsent = monthStats.map(stat => stat.absent);
                const monthlyLate = monthStats.map(stat => stat.late);
                const monthlyLeaves = monthStats.map(stat => stat.sick + stat.vacation + stat.other);

                const computeTrend = (values) => values.map((_, index) => {
                    const window = values.slice(Math.max(0, index - 2), index + 1);
                    if (!window.length) {
                        return 0;
                    }
                    const average = window.reduce((sum, value) => sum + value, 0) / window.length;
                    return Number(average.toFixed(2));
                });

                const monthlyPresentTrend = computeTrend(monthlyPresent);
                const monthlyAbsentTrend = computeTrend(monthlyAbsent);

                const yearlyTrends = {
                    punctual: monthStats.map(stat => safePercent(stat.present, stat.total)),
                    late: monthStats.map(stat => safePercent(stat.late, stat.total)),
                    absent: monthStats.map(stat => safePercent(stat.absent, stat.total)),
                    sick: monthStats.map(stat => safePercent(stat.sick, stat.total))
                };

                const monthlyAnalysis = months.map((monthName, index) => {
                    const stat = monthStats[index];
                    const total = stat.total || 0;
                    return {
                        month: monthName,
                        punctual: safePercent(stat.present, total),
                        absent: safePercent(stat.absent, total),
                        late: safePercent(stat.late, total),
                        sick: safePercent(stat.sick, total),
                        vacation: safePercent(stat.vacation + stat.other, total)
                    };
                });

                const yearlyTotalsChart = {
                    punctual: yearlyTotals.present || 0,
                    absent: yearlyTotals.absent || 0,
                    late: yearlyTotals.late || 0,
                    sick: yearlyTotals.sick || 0,
                    vacation: (yearlyTotals.vacation || 0) + (yearlyTotals.other || 0)
                };

                const sortedBiWeekly = Array.from(biWeeklyBuckets.values()).sort((a, b) => a.order - b.order);
                const biWeekly = {
                    labels: sortedBiWeekly.map(bucket => bucket.label),
                    punctual: sortedBiWeekly.map(bucket => safePercent(bucket.present, bucket.total))
                };

                const buildRecognitionLeaders = (bucketMap, fallbackLabel = '') => {
                    if (!bucketMap || typeof bucketMap !== 'object' || bucketMap.size === 0) {
                        return { label: fallbackLabel, entries: [] };
                    }

                    const buckets = Array.from(bucketMap.values()).sort((a, b) => {
                        const orderA = Number.isFinite(a.order) ? a.order : 0;
                        const orderB = Number.isFinite(b.order) ? b.order : 0;
                        return orderB - orderA;
                    });

                    const latestBucket = buckets[0];
                    const entries = Array.from(latestBucket.users.values()).map(stat => {
                        const totalTracked = stat.total || 0;
                        const punctualRate = totalTracked > 0
                            ? Number(((stat.present / totalTracked) * 100).toFixed(2))
                            : 0;
                        const displayName = (stat.displayName || '').toString().trim() || 'Team Member';

                        return {
                            displayName,
                            present: stat.present,
                            total: totalTracked,
                            punctualRate
                        };
                    })
                        .filter(stat => stat.total > 0)
                        .sort((a, b) => {
                            if (b.punctualRate !== a.punctualRate) {
                                return b.punctualRate - a.punctualRate;
                            }
                            if (b.present !== a.present) {
                                return b.present - a.present;
                            }
                            return a.displayName.localeCompare(b.displayName, undefined, { sensitivity: 'base' });
                        })
                        .slice(0, 3);

                    return {
                        label: latestBucket.label || fallbackLabel,
                        entries
                    };
                };

                const topPunctual = Array.from(userStatsMap.values())
                    .map(stat => {
                        const totalTracked = stat.total || 0;
                        const punctualRate = totalTracked > 0
                            ? Number(((stat.present / totalTracked) * 100).toFixed(2))
                            : 0;
                        const displayName = (stat.displayName || '').toString().trim() || 'Team Member';

                        return {
                            displayName,
                            present: stat.present,
                            total: totalTracked,
                            punctualRate
                        };
                    })
                    .filter(stat => stat.total > 0)
                    .sort((a, b) => {
                        if (b.punctualRate !== a.punctualRate) {
                            return b.punctualRate - a.punctualRate;
                        }
                        if (b.present !== a.present) {
                            return b.present - a.present;
                        }
                        return a.displayName.localeCompare(b.displayName, undefined, { sensitivity: 'base' });
                    })
                    .slice(0, 3);

                const recognition = {
                    weekly: buildRecognitionLeaders(recognitionPeriodMaps.weekly, 'Most recent week'),
                    biWeekly: buildRecognitionLeaders(recognitionPeriodMaps.biWeekly, 'Most recent bi-weekly period'),
                    monthly: buildRecognitionLeaders(recognitionPeriodMaps.monthly, 'Most recent month'),
                    quarterly: buildRecognitionLeaders(recognitionPeriodMaps.quarterly, 'Most recent quarter'),
                    yearly: buildRecognitionLeaders(recognitionPeriodMaps.yearly, `${year}`)
                };

                recognition.yearly.entries = topPunctual;
                if (!recognition.yearly.label) {
                    recognition.yearly.label = `${year}`;
                }

                return {
                    year,
                    months,
                    yearlyTrends,
                    monthlyPercent,
                    monthlyPresent,
                    monthlyPresentTrend,
                    monthlyAbsent,
                    monthlyAbsentTrend,
                    monthlyLeaves: {
                        leaves: monthlyLeaves,
                        late: monthlyLate
                    },
                    biWeekly,
                    topPunctual,
                    recognition,
                    monthlyAnalysis,
                    yearlyTotals: yearlyTotalsChart
                };
            }

            filterAttendanceDashboardRecords(records, filterValue = this.attendanceDashboardUserFilter) {
                if (!Array.isArray(records)) {
                    return [];
                }

                const normalizedFilterValue = this.normalizeUserIdValue(filterValue);
                if (!normalizedFilterValue) {
                    return records.slice();
                }

                const matchedUser = this.resolveAttendanceDashboardUser(normalizedFilterValue);
                const keySet = new Set();

                if (matchedUser) {
                    [
                        this.normalizePersonKey(matchedUser.UserName || matchedUser.username || ''),
                        this.normalizePersonKey(matchedUser.FullName || matchedUser.fullName || ''),
                        this.normalizePersonKey(matchedUser.Email || matchedUser.email || '')
                    ]
                        .filter(Boolean)
                        .forEach(key => keySet.add(key));
                } else {
                    const fallbackKey = this.normalizePersonKey(normalizedFilterValue);
                    if (fallbackKey) {
                        keySet.add(fallbackKey);
                    }
                }

                if (!keySet.size) {
                    return [];
                }

                return records.filter(record => {
                    const recordKeys = [
                        record?.userName,
                        record?.UserName,
                        record?.user,
                        record?.User,
                        record?.fullName,
                        record?.FullName
                    ]
                        .map(value => this.normalizePersonKey(value))
                        .filter(Boolean);

                    if (!recordKeys.length) {
                        return false;
                    }

                    return recordKeys.some(key => keySet.has(key));
                });
            }

            resolveAttendanceDashboardUser(filterValue) {
                const normalizedValue = this.normalizeUserIdValue(filterValue);
                if (!normalizedValue || !Array.isArray(this.availableUsers)) {
                    return null;
                }

                const matchById = this.availableUsers.find(user => {
                    const userId = this.normalizeUserIdValue(user.ID || user.UserID || user.id || user.userId || user.username);
                    return userId && userId === normalizedValue;
                });

                if (matchById) {
                    return matchById;
                }

                const normalizedName = this.normalizePersonKey(normalizedValue);
                if (!normalizedName) {
                    return null;
                }

                return this.availableUsers.find(user => {
                    const candidates = [
                        this.normalizePersonKey(user.UserName || user.username || ''),
                        this.normalizePersonKey(user.FullName || user.fullName || '')
                    ];
                    return candidates.some(key => key && key === normalizedName);
                }) || null;
            }

            mergeAttendanceDashboardRecords(records, year) {
                const resolvedYear = Number.parseInt(year, 10);
                if (!Array.isArray(records) || records.length === 0 || !Number.isFinite(resolvedYear)) {
                    return false;
                }

                const parseDate = (value) => {
                    if (value instanceof Date) {
                        return new Date(value.getTime());
                    }
                    if (typeof value === 'number') {
                        const parsed = new Date(value);
                        return Number.isNaN(parsed.getTime()) ? null : parsed;
                    }
                    if (typeof value === 'string' && value.trim().length > 0) {
                        const parsed = new Date(value);
                        return Number.isNaN(parsed.getTime()) ? null : parsed;
                    }
                    return null;
                };

                const buildKey = (record) => {
                    const nameKey = this.normalizePersonKey(record?.userName);
                    if (!nameKey || !record?.date) {
                        return null;
                    }
                    return `${nameKey}::${record.date}`;
                };

                const normalizedRecords = records
                    .map(record => {
                        const parsedDate = parseDate(record?.date || record?.Date || record?.timestamp);
                        if (!(parsedDate instanceof Date) || Number.isNaN(parsedDate.getTime())) {
                            return null;
                        }
                        if (parsedDate.getFullYear() !== resolvedYear) {
                            return null;
                        }

                        const userName = record?.userName || record?.UserName || record?.user || record?.User || '';
                        const status = record?.status || record?.Status || record?.state || record?.State || '';
                        if (!userName || !status) {
                            return null;
                        }

                        return {
                            userName,
                            status,
                            date: this.toIsoDateString(parsedDate),
                            notes: record?.notes || record?.Notes || ''
                        };
                    })
                    .filter(Boolean);

                if (!normalizedRecords.length) {
                    return false;
                }

                const existingMap = new Map();
                const existingRecords = Array.isArray(this.attendanceDashboardRecords)
                    ? this.attendanceDashboardRecords
                    : [];

                existingRecords.forEach(record => {
                    const normalized = {
                        userName: record?.userName || record?.UserName || record?.user || record?.User || '',
                        status: record?.status || record?.Status || record?.state || record?.State || '',
                        date: record?.date || record?.Date || '',
                        notes: record?.notes || record?.Notes || ''
                    };
                    const key = buildKey(normalized);
                    if (key) {
                        existingMap.set(key, normalized);
                    }
                });

                let changed = false;
                normalizedRecords.forEach(record => {
                    const key = buildKey(record);
                    if (!key) {
                        return;
                    }

                    const existing = existingMap.get(key);
                    if (!existing || existing.status !== record.status || existing.notes !== record.notes) {
                        existingMap.set(key, record);
                        changed = true;
                    }
                });

                if (!changed) {
                    return false;
                }

                this.attendanceDashboardRecords = Array.from(existingMap.values());

                if (!Number.isFinite(this.attendanceDashboardYear)) {
                    this.attendanceDashboardYear = resolvedYear;
                }

                if (this.attendanceDashboardYear === resolvedYear) {
                    const filteredRecords = this.filterAttendanceDashboardRecords(this.attendanceDashboardRecords, this.attendanceDashboardUserFilter);
                    this.attendanceDashboardData = this.computeAttendanceDashboard(filteredRecords, resolvedYear);
                    this.initializeAttendanceDashboard();
                }

                return true;
            }

            categorizeAttendanceStatus(status) {
                const normalized = (status || '').toString().trim().toLowerCase();
                if (!normalized) {
                    return 'other';
                }
                if (normalized === 'present' || normalized === 'on time' || normalized === 'punctual') {
                    return 'present';
                }
                if (normalized === 'late' || normalized.includes('tardy')) {
                    return 'late';
                }
                if (normalized === 'absent' || normalized.includes('no call no show') || normalized.includes('no-call no-show') || normalized.includes('no show')) {
                    return 'absent';
                }
                if (normalized.includes('sick')) {
                    return 'sick';
                }
                if (normalized.includes('vacation') || normalized.includes('pto') || normalized.includes('holiday')) {
                    return 'vacation';
                }
                if (normalized.includes('bereavement') || normalized.includes('leave') || normalized.includes('loa') || normalized.includes('personal')) {
                    return 'other';
                }
                return 'other';
            }

            getBiWeeklyBucketKey(date) {
                const startDay = Math.floor((date.getDate() - 1) / 14) * 14 + 1;
                const endDay = Math.min(startDay + 13, new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate());
                const monthLabel = date.toLocaleString('en-US', { month: 'short' });
                const label = `${monthLabel} ${startDay}-${endDay}`;
                const order = new Date(date.getFullYear(), date.getMonth(), startDay).getTime();
                const key = `${date.getFullYear()}-${date.getMonth()}-${startDay}`;
                return { key, label, order };
            }

            initializeAttendanceDashboard() {
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js is not available. Attendance dashboard cannot be initialized.');
                    return;
                }

                const yearlyTrendCanvas = document.getElementById('attendanceYearlyTrendChart');
                if (!yearlyTrendCanvas) {
                    return;
                }

                const palette = {
                    punctual: '#009639',
                    late: '#ffab00',
                    absent: '#de350b',
                    sick: '#0747a6',
                    vacation: '#6366f1'
                };

                const withAlpha = (hex, alpha) => {
                    if (!hex) {
                        return `rgba(0, 0, 0, ${alpha})`;
                    }

                    const sanitized = hex.replace('#', '');
                    const normalized = sanitized.length === 3
                        ? sanitized.split('').map(char => char + char).join('')
                        : sanitized.padEnd(6, '0');

                    const r = parseInt(normalized.substring(0, 2), 16);
                    const g = parseInt(normalized.substring(2, 4), 16);
                    const b = parseInt(normalized.substring(4, 6), 16);

                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                };

                const createGradient = (ctx, color) => {
                    const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height || 300);
                    gradient.addColorStop(0, withAlpha(color, 0.85));
                    gradient.addColorStop(1, withAlpha(color, 0.05));
                    return gradient;
                };

                let data = this.attendanceDashboardData;

                const monthSelect = document.getElementById('attendanceDashboardMonth');
                const userSelect = document.getElementById('attendanceDashboardUser');
                let normalizedFilterValue = this.normalizeUserIdValue(this.attendanceDashboardUserFilter);
                let shouldRecomputeDashboard = false;

                if (userSelect) {
                    const options = Array.from(userSelect.options || []);
                    const hasOption = options.some(option => option.value === (normalizedFilterValue || ''));
                    if (hasOption) {
                        userSelect.value = normalizedFilterValue || '';
                    } else {
                        if (normalizedFilterValue) {
                            this.attendanceDashboardUserFilter = '';
                            normalizedFilterValue = '';
                            shouldRecomputeDashboard = true;
                        }
                        userSelect.value = '';
                    }
                }

                if (shouldRecomputeDashboard) {
                    const yearForRecompute = this.attendanceDashboardYear || this.getSelectedAttendanceYear();
                    if (Number.isFinite(yearForRecompute)) {
                        const filteredRecords = this.filterAttendanceDashboardRecords(this.attendanceDashboardRecords, this.attendanceDashboardUserFilter);
                        data = this.computeAttendanceDashboard(filteredRecords, yearForRecompute);
                        this.attendanceDashboardData = data;
                    } else {
                        data = this.attendanceDashboardData;
                    }
                }

                if (!data || !Array.isArray(data.months)) {
                    console.warn('Attendance dashboard has no data to render.');
                    return;
                }

                this.attendanceRecognitionLeaders = this.resolveAttendanceRecognitionData(data);
                this.attachAttendanceRecognitionFilterListeners();
                this.updateAttendanceRecognitionPanel();

                if (!this.attendanceDashboardInitialized) {
                    const yearlyTrendCtx = yearlyTrendCanvas.getContext('2d');
                    this.attendanceCharts.yearlyTrend = new Chart(yearlyTrendCtx, {
                        type: 'line',
                        data: {
                            labels: data.months,
                            datasets: [
                                {
                                    label: 'Punctual',
                                    data: data.yearlyTrends.punctual,
                                    borderColor: palette.punctual,
                                    backgroundColor: createGradient(yearlyTrendCtx, palette.punctual),
                                    tension: 0.4,
                                    fill: true,
                                    borderWidth: 3
                                },
                                {
                                    label: 'Late',
                                    data: data.yearlyTrends.late,
                                    borderColor: palette.late,
                                    tension: 0.4,
                                    fill: false,
                                    borderWidth: 2,
                                    borderDash: [6, 6]
                                },
                                {
                                    label: 'Absent',
                                    data: data.yearlyTrends.absent,
                                    borderColor: palette.absent,
                                    tension: 0.4,
                                    fill: false,
                                    borderWidth: 2
                                },
                                {
                                    label: 'Sick',
                                    data: data.yearlyTrends.sick,
                                    borderColor: palette.sick,
                                    tension: 0.4,
                                    fill: false,
                                    borderWidth: 2
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    labels: {
                                        color: '#ffffff',
                                        usePointStyle: true
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => `${context.dataset.label}: ${context.parsed.y}%`
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    ticks: { color: '#e2e8f0' },
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                },
                                y: {
                                    ticks: {
                                        color: '#e2e8f0',
                                        callback: (value) => `${value}%`
                                    },
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                }
                            }
                        }
                    });

                    const monthlyPercentCtx = document.getElementById('attendanceMonthlyPercentChart').getContext('2d');
                    this.attendanceCharts.monthlyPercent = new Chart(monthlyPercentCtx, {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Attendance Rate (%)',
                                    data: [],
                                    backgroundColor: palette.punctual,
                                    borderRadius: 6,
                                    maxBarThickness: 60
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => `${context.parsed.y.toFixed(2)}%`
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    ticks: { color: '#e2e8f0' },
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                },
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#e2e8f0',
                                        callback: (value) => `${value}%`
                                    },
                                    grid: { color: 'rgba(255,255,255,0.1)' }
                                }
                            }
                        }
                    });

                    const presentCtx = document.getElementById('attendanceMonthlyPresentChart').getContext('2d');
                    this.attendanceCharts.monthlyPresent = new Chart(presentCtx, {
                        type: 'bar',
                        data: {
                            labels: data.months,
                            datasets: [
                                {
                                    type: 'bar',
                                    label: 'Present',
                                    data: data.monthlyPresent,
                                    backgroundColor: palette.punctual,
                                    borderRadius: 6,
                                    maxBarThickness: 26
                                },
                                {
                                    type: 'line',
                                    label: 'Trend',
                                    data: data.monthlyPresentTrend,
                                    borderColor: '#2563eb',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: true, position: 'bottom' }
                            },
                            scales: {
                                x: { grid: { display: false } },
                                y: { beginAtZero: true }
                            }
                        }
                    });

                    const absentCtx = document.getElementById('attendanceMonthlyAbsentChart').getContext('2d');
                    this.attendanceCharts.monthlyAbsent = new Chart(absentCtx, {
                        type: 'bar',
                        data: {
                            labels: data.months,
                            datasets: [
                                {
                                    type: 'bar',
                                    label: 'Absent',
                                    data: data.monthlyAbsent,
                                    backgroundColor: palette.absent,
                                    borderRadius: 6,
                                    maxBarThickness: 26
                                },
                                {
                                    type: 'line',
                                    label: 'Trend',
                                    data: data.monthlyAbsentTrend,
                                    borderColor: '#f97316',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: true, position: 'bottom' }
                            },
                            scales: {
                                x: { grid: { display: false } },
                                y: { beginAtZero: true }
                            }
                        }
                    });

                    const leavesCtx = document.getElementById('attendanceMonthlyLeavesChart').getContext('2d');
                    this.attendanceCharts.monthlyLeaves = new Chart(leavesCtx, {
                        type: 'bar',
                        data: {
                            labels: data.months,
                            datasets: [
                                {
                                    type: 'bar',
                                    label: 'Leaves',
                                    data: data.monthlyLeaves.leaves,
                                    backgroundColor: palette.vacation,
                                    borderRadius: 6,
                                    maxBarThickness: 26
                                },
                                {
                                    type: 'line',
                                    label: 'Late',
                                    data: data.monthlyLeaves.late,
                                    borderColor: palette.late,
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: true, position: 'bottom' }
                            },
                            scales: {
                                x: { grid: { display: false } },
                                y: { beginAtZero: true }
                            }
                        }
                    });

                    const biWeeklyCtx = document.getElementById('attendanceBiWeeklyChart').getContext('2d');
                    this.attendanceCharts.biWeekly = new Chart(biWeeklyCtx, {
                        type: 'bar',
                        data: {
                            labels: data.biWeekly.labels,
                            datasets: [
                                {
                                    label: 'Punctual',
                                    data: data.biWeekly.punctual,
                                    backgroundColor: palette.punctual,
                                    borderRadius: 6
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                x: { ticks: { maxRotation: 0, minRotation: 0 } },
                                y: { beginAtZero: true }
                            }
                        }
                    });

                    const monthlyAnalysisCtx = document.getElementById('attendanceMonthlyAnalysisChart').getContext('2d');
                    this.attendanceCharts.monthlyAnalysis = new Chart(monthlyAnalysisCtx, {
                        type: 'bar',
                        data: {
                            labels: data.monthlyAnalysis.map(item => item.month),
                            datasets: [
                                {
                                    label: 'Punctual',
                                    data: data.monthlyAnalysis.map(item => item.punctual),
                                    backgroundColor: palette.punctual,
                                    stack: 'analysis'
                                },
                                {
                                    label: 'Absent',
                                    data: data.monthlyAnalysis.map(item => item.absent),
                                    backgroundColor: palette.absent,
                                    stack: 'analysis'
                                },
                                {
                                    label: 'Late',
                                    data: data.monthlyAnalysis.map(item => item.late),
                                    backgroundColor: palette.late,
                                    stack: 'analysis'
                                },
                                {
                                    label: 'Sick',
                                    data: data.monthlyAnalysis.map(item => item.sick),
                                    backgroundColor: palette.sick,
                                    stack: 'analysis'
                                },
                                {
                                    label: 'Vacation & Other',
                                    data: data.monthlyAnalysis.map(item => item.vacation),
                                    backgroundColor: palette.vacation,
                                    stack: 'analysis'
                                }
                            ]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { position: 'bottom' }
                            },
                            scales: {
                                x: {
                                    stacked: true,
                                    ticks: {
                                        callback: (value) => `${value}%`
                                    }
                                },
                                y: { stacked: true }
                            }
                        }
                    });

                    const yearlyAnalysisCtx = document.getElementById('attendanceYearlyAnalysisChart').getContext('2d');
                    this.attendanceCharts.yearlyAnalysis = new Chart(yearlyAnalysisCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Punctual', 'Absent', 'Late', 'Sick', 'Vacation'],
                            datasets: [
                                {
                                    data: [
                                        data.yearlyTotals.punctual,
                                        data.yearlyTotals.absent,
                                        data.yearlyTotals.late,
                                        data.yearlyTotals.sick,
                                        data.yearlyTotals.vacation
                                    ],
                                    backgroundColor: [
                                        palette.punctual,
                                        palette.absent,
                                        palette.late,
                                        palette.sick,
                                        palette.vacation
                                    ],
                                    borderWidth: 2,
                                    hoverOffset: 8
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            cutout: '65%',
                            plugins: {
                                legend: { position: 'bottom' }
                            }
                        }
                    });

                    if (monthSelect) {
                        if (!monthSelect.dataset.luminaAttendanceMonthListener) {
                            monthSelect.addEventListener('change', (event) => {
                                const value = parseInt(event.target.value, 10);
                                this.updateAttendanceMonthlyPercentChart(Number.isNaN(value) ? 0 : value);
                            });
                            monthSelect.dataset.luminaAttendanceMonthListener = 'true';
                        }

                        let resolvedMonth;
                        if (!monthSelect.dataset.luminaAttendanceMonthDefaultApplied) {
                            const defaultMonth = new Date().getMonth();
                            resolvedMonth = (defaultMonth >= 0 && defaultMonth < data.months.length) ? defaultMonth : 0;
                            monthSelect.dataset.luminaAttendanceMonthDefaultApplied = 'true';
                        } else {
                            const parsed = parseInt(monthSelect.value, 10);
                            resolvedMonth = Number.isNaN(parsed) ? 0 : parsed;
                        }

                        resolvedMonth = Math.min(Math.max(resolvedMonth, 0), data.months.length - 1);
                        monthSelect.value = String(resolvedMonth);
                        this.updateAttendanceMonthlyPercentChart(resolvedMonth);
                    } else {
                        this.updateAttendanceMonthlyPercentChart(0);
                    }

                    if (userSelect && !userSelect.dataset.luminaAttendanceUserListener) {
                        userSelect.addEventListener('change', (event) => {
                            this.handleAttendanceDashboardUserFilterChange(event.target.value);
                        });
                        userSelect.dataset.luminaAttendanceUserListener = 'true';
                    }

                    if (!this.attendanceDashboardResizeHandler) {
                        this.attendanceDashboardResizeHandler = () => this.refreshAttendanceDashboard();
                        window.addEventListener('resize', this.attendanceDashboardResizeHandler);
                    }

                    this.attendanceDashboardInitialized = true;
                } else {
                    this.attendanceCharts.yearlyTrend.data.labels = data.months;
                    this.attendanceCharts.yearlyTrend.data.datasets[0].data = data.yearlyTrends.punctual;
                    this.attendanceCharts.yearlyTrend.data.datasets[1].data = data.yearlyTrends.late;
                    this.attendanceCharts.yearlyTrend.data.datasets[2].data = data.yearlyTrends.absent;
                    this.attendanceCharts.yearlyTrend.data.datasets[3].data = data.yearlyTrends.sick;

                    this.attendanceCharts.monthlyPresent.data.labels = data.months;
                    this.attendanceCharts.monthlyPresent.data.datasets[0].data = data.monthlyPresent;
                    this.attendanceCharts.monthlyPresent.data.datasets[1].data = data.monthlyPresentTrend;

                    this.attendanceCharts.monthlyAbsent.data.labels = data.months;
                    this.attendanceCharts.monthlyAbsent.data.datasets[0].data = data.monthlyAbsent;
                    this.attendanceCharts.monthlyAbsent.data.datasets[1].data = data.monthlyAbsentTrend;

                    this.attendanceCharts.monthlyLeaves.data.labels = data.months;
                    this.attendanceCharts.monthlyLeaves.data.datasets[0].data = data.monthlyLeaves.leaves;
                    this.attendanceCharts.monthlyLeaves.data.datasets[1].data = data.monthlyLeaves.late;

                    this.attendanceCharts.biWeekly.data.labels = data.biWeekly.labels;
                    this.attendanceCharts.biWeekly.data.datasets[0].data = data.biWeekly.punctual;

                    this.attendanceCharts.monthlyAnalysis.data.labels = data.monthlyAnalysis.map(item => item.month);
                    this.attendanceCharts.monthlyAnalysis.data.datasets[0].data = data.monthlyAnalysis.map(item => item.punctual);
                    this.attendanceCharts.monthlyAnalysis.data.datasets[1].data = data.monthlyAnalysis.map(item => item.absent);
                    this.attendanceCharts.monthlyAnalysis.data.datasets[2].data = data.monthlyAnalysis.map(item => item.late);
                    this.attendanceCharts.monthlyAnalysis.data.datasets[3].data = data.monthlyAnalysis.map(item => item.sick);
                    this.attendanceCharts.monthlyAnalysis.data.datasets[4].data = data.monthlyAnalysis.map(item => item.vacation);

                    this.attendanceCharts.yearlyAnalysis.data.datasets[0].data = [
                        data.yearlyTotals.punctual,
                        data.yearlyTotals.absent,
                        data.yearlyTotals.late,
                        data.yearlyTotals.sick,
                        data.yearlyTotals.vacation
                    ];

                    const selectedMonth = monthSelect ? parseInt(monthSelect.value, 10) : 0;
                    this.updateAttendanceMonthlyPercentChart(Number.isNaN(selectedMonth) ? 0 : selectedMonth);

                    this.refreshAttendanceDashboard();
                }

            }

            updateAttendanceMonthlyPercentChart(monthIndex) {
                const chart = this.attendanceCharts.monthlyPercent;
                const valueDisplay = document.getElementById('attendanceMonthlyPercentValue');
                const data = this.attendanceDashboardData;

                if (!chart || !data) {
                    return;
                }

                const safeIndex = Math.min(Math.max(monthIndex, 0), data.months.length - 1);
                const monthName = data.months[safeIndex];
                const percentValue = data.monthlyPercent[safeIndex] || 0;

                chart.data.labels = [monthName];
                chart.data.datasets[0].data = [percentValue];
                chart.update();

                if (valueDisplay) {
                    valueDisplay.textContent = `${percentValue.toFixed(2)}%`;
                }
            }

            renderAttendancePunctualRecognition(entries) {
                const container = document.getElementById('attendancePunctualRecognition');
                if (!container) {
                    return;
                }

                const safeEntries = Array.isArray(entries)
                    ? entries.filter(entry => entry && typeof entry === 'object')
                    : [];

                if (!safeEntries.length) {
                    container.innerHTML = `
                        <div class="attendance-recognition-empty">
                            <i class="fas fa-medal"></i>
                            Recognition updates as attendance is recorded.
                        </div>
                    `;
                    return;
                }

                const ordinalSuffix = (value) => {
                    if (value === 1) return 'st';
                    if (value === 2) return 'nd';
                    if (value === 3) return 'rd';
                    return 'th';
                };

                const html = safeEntries.slice(0, 3).map((entry, index) => {
                    const rank = index + 1;
                    const suffix = ordinalSuffix(rank);
                    const rankHtml = `${rank}<sup>${suffix}</sup>`;
                    const safeName = this.escapeHtml(entry.displayName || entry.name || entry.identifier || 'Team Member');
                    const present = Number(entry.present) || 0;
                    const total = Number(entry.total) || 0;
                    const punctualRate = Number.isFinite(entry.punctualRate)
                        ? entry.punctualRate.toFixed(2)
                        : '0.00';
                    const meta = this.escapeHtml(`On time for ${present} of ${total} tracked shifts (${punctualRate}%)`);
                    const tierClass = ['first', 'second', 'third'][index] || 'other';

                    return `
                        <div class="attendance-recognition-item attendance-recognition-item--${tierClass}">
                            <div class="attendance-recognition-rank" aria-hidden="true">${rankHtml}</div>
                            <div class="attendance-recognition-icon" aria-hidden="true">
                                <i class="fas fa-medal"></i>
                            </div>
                            <div class="attendance-recognition-details">
                                <div class="attendance-recognition-name">${safeName}</div>
                                <div class="attendance-recognition-meta">${meta}</div>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = html;
            }

            resolveAttendanceRecognitionData(data) {
                const fallbackEntries = Array.isArray(data?.topPunctual)
                    ? data.topPunctual.filter(entry => entry && typeof entry === 'object')
                    : [];
                const fallbackYear = Number.isFinite(data?.year)
                    ? data.year
                    : (Number.isFinite(this.attendanceDashboardYear) ? this.attendanceDashboardYear : new Date().getFullYear());
                const recognition = data && typeof data === 'object' ? data.recognition : null;

                const ensureBucket = (bucket, defaultLabel = '') => {
                    if (!bucket || typeof bucket !== 'object') {
                        return { label: defaultLabel, entries: [] };
                    }
                    const label = typeof bucket.label === 'string' ? bucket.label : defaultLabel;
                    const entries = Array.isArray(bucket.entries)
                        ? bucket.entries.filter(entry => entry && typeof entry === 'object')
                        : [];
                    return { label, entries };
                };

                const resolved = {
                    weekly: ensureBucket(recognition?.weekly, 'Most recent week'),
                    biWeekly: ensureBucket(recognition?.biWeekly, 'Most recent bi-weekly period'),
                    monthly: ensureBucket(recognition?.monthly, 'Most recent month'),
                    quarterly: ensureBucket(recognition?.quarterly, 'Most recent quarter'),
                    yearly: ensureBucket(recognition?.yearly, fallbackYear ? `Year to date (${fallbackYear})` : 'Year to date')
                };

                if (!resolved.yearly.entries.length && fallbackEntries.length) {
                    resolved.yearly.entries = fallbackEntries;
                }

                if (!resolved.yearly.label) {
                    resolved.yearly.label = fallbackYear ? `Year to date (${fallbackYear})` : 'Year to date';
                }

                return resolved;
            }

            attachAttendanceRecognitionFilterListeners() {
                const buttons = document.querySelectorAll('[data-recognition-period]');
                buttons.forEach(button => {
                    if (button.dataset.luminaRecognitionListener) {
                        return;
                    }

                    button.addEventListener('click', (event) => {
                        const target = event.currentTarget;
                        const period = target && target.dataset ? target.dataset.recognitionPeriod : null;
                        this.handleAttendanceRecognitionPeriodChange(period);
                    });

                    button.dataset.luminaRecognitionListener = 'true';
                });
            }

            handleAttendanceRecognitionPeriodChange(period) {
                const validPeriods = new Set(['weekly', 'biWeekly', 'monthly', 'quarterly', 'yearly']);
                const normalized = (period || '').toString().trim();
                const selected = validPeriods.has(normalized) ? normalized : 'yearly';
                this.attendanceRecognitionPeriod = selected;
                this.updateAttendanceRecognitionPanel();
            }

            getRecognitionPeriodDescriptor(type) {
                switch (type) {
                    case 'weekly':
                        return 'Weekly leaders';
                    case 'biWeekly':
                        return 'Bi-weekly leaders';
                    case 'monthly':
                        return 'Monthly leaders';
                    case 'quarterly':
                        return 'Quarterly leaders';
                    default:
                        return 'Year-to-date leaders';
                }
            }

            updateAttendanceRecognitionPanel() {
                const validPeriods = ['weekly', 'biWeekly', 'monthly', 'quarterly', 'yearly'];
                const current = validPeriods.includes(this.attendanceRecognitionPeriod)
                    ? this.attendanceRecognitionPeriod
                    : 'yearly';
                this.attendanceRecognitionPeriod = current;

                const data = this.attendanceRecognitionLeaders || {};
                const selection = data[current] || { label: '', entries: [] };

                this.renderAttendancePunctualRecognition(selection.entries);

                const labelElement = document.getElementById('attendanceRecognitionPeriodLabel');
                if (labelElement) {
                    const descriptor = this.getRecognitionPeriodDescriptor(current);
                    const periodLabel = (selection.label || '').toString().trim();
                    labelElement.textContent = periodLabel
                        ? `${descriptor}  ${periodLabel}`
                        : `${descriptor}  No data yet`;
                }

                const buttons = document.querySelectorAll('[data-recognition-period]');
                buttons.forEach(button => {
                    const buttonPeriod = button.dataset ? button.dataset.recognitionPeriod : '';
                    const isActive = buttonPeriod === current;
                    button.classList.toggle('active', isActive);
                    button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });
            }

            handleAttendanceDashboardUserFilterChange(rawValue) {
                const normalizedValue = this.normalizeUserIdValue(rawValue);
                this.attendanceDashboardUserFilter = normalizedValue || '';

                const userSelect = document.getElementById('attendanceDashboardUser');
                if (userSelect) {
                    const options = Array.from(userSelect.options || []);
                    const hasOption = options.some(option => option.value === (this.attendanceDashboardUserFilter || ''));
                    userSelect.value = hasOption ? (this.attendanceDashboardUserFilter || '') : '';
                    if (!hasOption && this.attendanceDashboardUserFilter) {
                        this.attendanceDashboardUserFilter = '';
                    }
                }

                const year = this.attendanceDashboardYear || this.getSelectedAttendanceYear();
                if (!Number.isFinite(year)) {
                    return;
                }

                const filteredRecords = this.filterAttendanceDashboardRecords(this.attendanceDashboardRecords, this.attendanceDashboardUserFilter);
                this.attendanceDashboardData = this.computeAttendanceDashboard(filteredRecords, year);
                this.initializeAttendanceDashboard();
            }

            refreshAttendanceDashboard() {
                Object.values(this.attendanceCharts).forEach(chart => {
                    if (chart && typeof chart.resize === 'function') {
                        chart.resize();
                    }
                    if (chart && typeof chart.update === 'function') {
                        chart.update('none');
                    }
                });
            }

            async loadAttendanceCalendar() {
                const container = document.getElementById('attendanceCalendarContainer');
                let monthContext = null;

                try {
                    await this.ensureScheduleContext();

                    const monthInput = document.getElementById('attendanceMonth');
                    const yearInput = document.getElementById('attendanceYear');
                    const monthValue = monthInput ? monthInput.value : '';
                    const yearValue = yearInput ? yearInput.value : '';
                    monthContext = this.resolveAttendanceMonthContext(monthValue, yearValue);

                    this.updateStatusLegendCard();
                    if (container) {
                        container.innerHTML = this.renderAttendanceCalendarLoading(monthContext.label);
                    }

                    const managerId = this.getCurrentUserId();
                    const campaignId = this.getCurrentCampaignId() || null;

                    let scheduleUsers = Array.isArray(this.availableUsers) ? this.availableUsers.slice() : [];
                    let attendanceUsersRaw = [];
                    let attendanceRecords = [];
                    let attendanceYearRecords = [];
                    const prefetch = this.attendanceCalendarPrefetch;
                    if (
                        prefetch
                        && prefetch.range
                        && prefetch.range.startDate === monthContext.startDate
                        && prefetch.range.endDate === monthContext.endDate
                    ) {
                        console.log(' Using prefetched attendance data for %s', monthContext.label);
                        attendanceUsersRaw = Array.isArray(prefetch.users) ? prefetch.users.slice() : [];
                        attendanceRecords = Array.isArray(prefetch.monthlyRecords) ? prefetch.monthlyRecords.slice() : [];
                        attendanceYearRecords = Array.isArray(prefetch.yearlyRecords)
                            ? prefetch.yearlyRecords.slice()
                            : attendanceRecords.slice();
                    } else {
                        const [attendanceUsersResponse, scheduleUsersResponse] = await Promise.all([
                            this.callServerFunction('clientGetAttendanceUsers', managerId, campaignId),
                            scheduleUsers.length
                                ? Promise.resolve(scheduleUsers)
                                : this.callServerFunction('clientGetScheduleUsers', managerId, campaignId)
                        ]);

                        attendanceUsersRaw = Array.isArray(attendanceUsersResponse) ? attendanceUsersResponse : [];
                        scheduleUsers = Array.isArray(scheduleUsersResponse) ? scheduleUsersResponse : scheduleUsers;

                        let attendanceResponse = null;
                        try {
                            attendanceResponse = await this.callServerFunction(
                                'clientGetAttendanceDataRange',
                                monthContext.startDate,
                                monthContext.endDate,
                                campaignId
                            );
                            if (attendanceResponse && attendanceResponse.success) {
                                attendanceRecords = Array.isArray(attendanceResponse.records)
                                    ? attendanceResponse.records
                                    : [];
                            } else if (attendanceResponse && attendanceResponse.error) {
                                console.warn('Attendance data range request returned an error:', attendanceResponse.error);
                            }
                        } catch (attendanceError) {
                            console.error('Unable to load attendance statuses for calendar:', attendanceError);
                        }

                        attendanceYearRecords = attendanceResponse && attendanceResponse.success
                            ? (Array.isArray(attendanceResponse.records) ? attendanceResponse.records.slice() : [])
                            : attendanceRecords.slice();

                        this.attendanceCalendarPrefetch = {
                            range: monthContext,
                            users: attendanceUsersRaw.slice(),
                            monthlyRecords: attendanceRecords.slice(),
                            yearlyRecords: attendanceYearRecords.slice()
                        };
                    }

                    if (!Array.isArray(this.availableUsers) || !this.availableUsers.length) {
                        this.availableUsers = scheduleUsers.slice();
                    }

                    const employedScheduleUsers = this.filterScheduleUsersByEmployment(
                        scheduleUsers,
                        monthContext.year,
                        monthContext.month
                    );

                    console.log(
                        ' Filtering attendance calendar to %d/%d employed users for %s',
                        employedScheduleUsers.length,
                        scheduleUsers.length,
                        monthContext.label
                    );

                    if (!employedScheduleUsers.length) {
                        if (container) {
                            container.innerHTML = this.renderNoEligibleAttendanceUsersState(monthContext.label);
                        }
                        return;
                    }

                    const employmentKeyLookup = this.buildEmploymentKeyLookup(employedScheduleUsers);

                    const combinedUsers = [];
                    const seenUserKeys = new Set();

                    const appendUserName = (name) => {
                        const normalized = this.normalizePersonKey(name);
                        if (!normalized || seenUserKeys.has(normalized) || !employmentKeyLookup.has(normalized)) {
                            return;
                        }
                        combinedUsers.push(name);
                        seenUserKeys.add(normalized);
                    };

                    employedScheduleUsers.forEach(user => {
                        if (!user) {
                            return;
                        }
                        appendUserName(user.FullName || user.UserName || user.Email);
                    });

                    if (Array.isArray(attendanceUsersRaw)) {
                        attendanceUsersRaw.forEach(name => appendUserName(name));
                    }

                    if (!combinedUsers.length) {
                        if (container) {
                            container.innerHTML = this.renderNoEligibleAttendanceUsersState(monthContext.label);
                        }
                        return;
                    }

                    const userEntries = this.buildAttendanceUserEntries(combinedUsers, employedScheduleUsers);

                    this.attendanceCalendarRecords = attendanceRecords;
                    const mergeSource = attendanceYearRecords.length ? attendanceYearRecords : attendanceRecords;
                    if (mergeSource.length) {
                        this.mergeAttendanceDashboardRecords(mergeSource, monthContext.year);
                    }
                    const attendanceMap = this.buildAttendanceRecordMap(attendanceRecords);

                    const calendar = this.generateAttendanceCalendarGrid(
                        userEntries,
                        monthContext.year,
                        monthContext.month,
                        monthContext.daysInMonth,
                        attendanceMap
                    );

                    if (container) {
                        container.innerHTML = calendar;
                    }

                    this.hideAttendanceContextMenu();
                    this.ensureAttendanceContextMenu();

                    console.log(' Attendance calendar loaded with %d records', attendanceRecords.length);
                } catch (error) {
                    console.error(' Failed to load attendance calendar:', error);
                    if (container) {
                        const label = monthContext?.label || '';
                        container.innerHTML = this.renderAttendanceCalendarErrorState(label);
                    }
                    this.showToast('Failed to load attendance calendar. Please try again.', 'danger');
                }
            }

            collectUserIdentityKeys(user) {
                if (!user) {
                    return [];
                }

                const identityValues = [
                    user.UserName,
                    user.FullName,
                    user.Email
                ];

                return identityValues
                    .map(value => this.normalizePersonKey(value))
                    .filter(Boolean);
            }

            resolveAttendanceMonthContext(monthValue, yearValue) {
                const now = new Date();
                const parsedMonth = parseInt(monthValue, 10);
                const parsedYear = parseInt(yearValue, 10);

                const month = Number.isFinite(parsedMonth) && parsedMonth >= 1 && parsedMonth <= 12
                    ? parsedMonth
                    : now.getMonth() + 1;
                const year = Number.isFinite(parsedYear) ? parsedYear : now.getFullYear();
                const daysInMonth = new Date(year, month, 0).getDate();
                const startDate = `${year}-${String(month).padStart(2, '0')}-01`;
                const endDate = `${year}-${String(month).padStart(2, '0')}-${String(daysInMonth).padStart(2, '0')}`;
                const monthName = this.getMonthName(month) || `Month ${month}`;
                const label = `${monthName} ${year}`.trim();

                return {
                    month,
                    year,
                    daysInMonth,
                    startDate,
                    endDate,
                    label
                };
            }

            renderAttendanceCalendarLoading(monthLabel) {
                const safeLabel = this.escapeHtml(monthLabel || '');
                return `
                        <div class="text-center py-5">
                            <div class="loading-spinner mx-auto mb-3"></div>
                            <p>Loading attendance calendar for ${safeLabel}...</p>
                        </div>
                    `;
            }

            renderAttendanceCalendarErrorState(monthLabel) {
                const safeLabel = this.escapeHtml(monthLabel || '');
                const labelText = safeLabel ? ` for ${safeLabel}` : '';
                return `
                        <div class="text-center py-5 text-danger">
                            <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
                            <p>We couldn't load the attendance calendar${labelText}. Please try again.</p>
                        </div>
                    `;
            }

            renderNoEligibleAttendanceUsersState(monthLabel) {
                const safeLabel = this.escapeHtml(monthLabel || '');
                return `
                        <div class="text-center py-5 text-muted">
                            <i class="fas fa-user-clock fa-3x mb-3 opacity-50"></i>
                            <h5>No Eligible Users</h5>
                            <p>No users were employed during ${safeLabel}.</p>
                            <p>Adjust the selected month or review employment dates.</p>
                        </div>
                    `;
            }

            filterScheduleUsersByEmployment(users, year, month) {
                if (!Array.isArray(users) || !users.length) {
                    return [];
                }

                return users.filter(user => this.isUserEmployedDuringMonth(user, year, month));
            }

            buildEmploymentKeyLookup(users = []) {
                const lookup = new Set();

                if (!Array.isArray(users) || !users.length) {
                    return lookup;
                }

                users.forEach(user => {
                    this.collectUserIdentityKeys(user).forEach(key => lookup.add(key));
                });

                return lookup;
            }

            collectUserIdentityKeys(user) {
                if (!user) {
                    return [];
                }

                const identityValues = [
                    user.UserName,
                    user.FullName,
                    user.Email
                ];

                return identityValues
                    .map(value => this.normalizePersonKey(value))
                    .filter(Boolean);
            }

            buildAttendanceUserEntries(userNames = [], scheduleUsers = []) {
                const metadataIndex = new Map();

                scheduleUsers.forEach(user => {
                    if (!user) {
                        return;
                    }

                    const userName = (user.UserName || '').toString().trim();
                    const fullName = (user.FullName || '').toString().trim();
                    const email = (user.Email || '').toString().trim();
                    const employment = this.getEmploymentPeriod(user);

                    const metadata = {
                        userName,
                        fullName,
                        email,
                        employment
                    };

                    [userName, fullName, email].forEach(value => {
                        const key = this.normalizePersonKey(value);
                        if (key && !metadataIndex.has(key)) {
                            metadataIndex.set(key, metadata);
                        }
                    });
                });

                return userNames.map(name => {
                    const normalizedName = this.normalizePersonKey(name);
                    const metadata = normalizedName ? metadataIndex.get(normalizedName) : null;

                    const recordKeySet = new Set();
                    if (metadata) {
                        [metadata.userName, metadata.fullName, metadata.email].forEach(value => {
                            const key = this.normalizePersonKey(value);
                            if (key) {
                                recordKeySet.add(key);
                            }
                        });
                    }
                    if (normalizedName) {
                        recordKeySet.add(normalizedName);
                    }

                    const identifier = metadata && metadata.userName ? metadata.userName : name;
                    const displayName = metadata && metadata.fullName
                        ? metadata.fullName
                        : (metadata && metadata.userName ? metadata.userName : name);
                    const employment = metadata && metadata.employment
                        ? metadata.employment
                        : { startDate: null, endDate: null, startIso: '', endIso: '' };

                    return {
                        identifier,
                        displayName,
                        original: name,
                        recordKeys: Array.from(recordKeySet),
                        employmentStart: employment && employment.startDate ? new Date(employment.startDate.getTime()) : null,
                        employmentEnd: employment && employment.endDate ? new Date(employment.endDate.getTime()) : null,
                        employmentStartIso: employment && employment.startIso ? employment.startIso : '',
                        employmentEndIso: employment && employment.endIso ? employment.endIso : ''
                    };
                });
            }

            getEmploymentPeriod(user) {
                if (!user) {
                    return { startIso: '', endIso: '', startDate: null, endDate: null };
                }

                const startFieldNames = Array.isArray(this.employmentStartFieldNames)
                    ? this.employmentStartFieldNames
                    : [];
                const endFieldNames = Array.isArray(this.employmentEndFieldNames)
                    ? this.employmentEndFieldNames
                    : [];

                const startIso = this.resolveEmploymentIsoDate(user, startFieldNames);
                const endIso = this.resolveEmploymentIsoDate(user, endFieldNames);

                const startDate = this.parseIsoDateToLocal(startIso);
                if (startDate instanceof Date && !Number.isNaN(startDate.getTime())) {
                    startDate.setHours(0, 0, 0, 0);
                }

                const endDate = this.parseIsoDateToLocal(endIso);
                if (endDate instanceof Date && !Number.isNaN(endDate.getTime())) {
                    endDate.setHours(23, 59, 59, 999);
                }

                return {
                    startIso: startIso || '',
                    endIso: endIso || '',
                    startDate: startDate instanceof Date && !Number.isNaN(startDate.getTime()) ? startDate : null,
                    endDate: endDate instanceof Date && !Number.isNaN(endDate.getTime()) ? endDate : null
                };
            }

            isUserEmployedDuringMonth(user, year, month) {
                if (!user) {
                    return false;
                }

                const normalizedMonth = Number(month);
                const normalizedYear = Number(year);
                if (!Number.isFinite(normalizedMonth) || !Number.isFinite(normalizedYear)) {
                    return false;
                }

                const monthStart = new Date(normalizedYear, normalizedMonth - 1, 1);
                monthStart.setHours(0, 0, 0, 0);
                const monthEnd = new Date(normalizedYear, normalizedMonth, 0);
                monthEnd.setHours(23, 59, 59, 999);
                const monthStartTime = monthStart.getTime();
                const monthEndTime = monthEnd.getTime();

                const employment = this.getEmploymentPeriod(user);
                const hireDate = employment.startDate instanceof Date ? employment.startDate : this.parseIsoDateToLocal(employment.startIso);
                if (hireDate && hireDate.getTime() > monthEndTime) {
                    return false;
                }

                const terminationDate = employment.endDate instanceof Date ? employment.endDate : this.parseIsoDateToLocal(employment.endIso);
                if (terminationDate && terminationDate.getTime() < monthStartTime) {
                    return false;
                }

                return true;
            }

            parseIsoDateToLocal(isoDate) {
                if (typeof isoDate !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(isoDate)) {
                    return null;
                }

                const [yearStr, monthStr, dayStr] = isoDate.split('-');
                const year = parseInt(yearStr, 10);
                const month = parseInt(monthStr, 10);
                const day = parseInt(dayStr, 10);

                if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
                    return null;
                }

                const date = new Date(year, month - 1, day);
                return Number.isNaN(date.getTime()) ? null : date;
            }

            resolveEmploymentIsoDate(user, fieldNames = [], visited = new Set()) {
                if (!user || !Array.isArray(fieldNames) || !fieldNames.length) {
                    return '';
                }

                if (visited.has(user)) {
                    return '';
                }
                visited.add(user);

                for (let index = 0; index < fieldNames.length; index++) {
                    const fieldName = fieldNames[index];
                    if (!fieldName) {
                        continue;
                    }

                    const rawValue = user[fieldName];
                    const normalized = this.normalizeAttendanceDateValue(rawValue);
                    if (normalized) {
                        return normalized;
                    }
                }

                const nestedSources = [
                    user.Employment,
                    user.employment,
                    user.EmploymentDetails,
                    user.employmentDetails,
                    user.EmploymentInfo,
                    user.employmentInfo,
                    user.HRProfile,
                    user.hrProfile,
                    user.HrProfile
                ];

                for (let index = 0; index < nestedSources.length; index++) {
                    const nested = nestedSources[index];
                    if (!nested || typeof nested !== 'object') {
                        continue;
                    }

                    const normalized = this.resolveEmploymentIsoDate(nested, fieldNames, visited);
                    if (normalized) {
                        return normalized;
                    }
                }

                return '';
            }

            renderAttendanceLegend() {
                if (!Array.isArray(this.attendanceStatusLegend) || this.attendanceStatusLegend.length === 0) {
                    return '';
                }

                return this.attendanceStatusLegend.map(item => {
                    const code = this.escapeHtml(item.code || '-');
                    const label = this.escapeHtml(item.label || '');
                    const className = item.className || 'attendance-calendar__status--other';
                    return `
                        <div class="attendance-calendar__legend-item">
                            <span class="attendance-calendar__status ${className}">${code}</span>
                            <span>${label}</span>
                        </div>
                    `;
                }).join('');
            }

            updateStatusLegendCard() {
                const container = document.getElementById('attendanceStatusLegendCard');
                if (!container) {
                    return;
                }

                const legendHtml = this.renderAttendanceLegend();
                if (legendHtml) {
                    container.innerHTML = legendHtml;
                } else {
                    container.innerHTML = '<div class="text-muted small">No attendance statuses configured.</div>';
                }
            }

            resolveAttendanceRecord(recordKeys, dateStr, attendanceMap) {
                if (!Array.isArray(recordKeys) || !dateStr || !attendanceMap) {
                    return null;
                }

                for (let i = 0; i < recordKeys.length; i++) {
                    const key = `${recordKeys[i]}::${dateStr}`;
                    if (attendanceMap.has(key)) {
                        return attendanceMap.get(key);
                    }
                }

                return null;
            }

            generateAttendanceCalendarGrid(userEntries, year, month, daysInMonth, attendanceMap = new Map()) {
                const monthDate = new Date(year, month - 1, 1);
                const monthName = monthDate.toLocaleDateString('en-US', { month: 'long' }).toUpperCase();
                const monthLabel = `${monthName} - ${year}`;
                const safeMonthLabel = this.escapeHtml(monthLabel);
                const participantLabel = `${userEntries.length} Participant${userEntries.length === 1 ? '' : 's'}`;

                let html = `
                        <div class="attendance-calendar">
                            <div class="attendance-calendar__header">
                                <div class="attendance-calendar__header-top">
                                    <div class="attendance-calendar__period">
                                        <span class="attendance-calendar__period-label">${safeMonthLabel}</span>
                                        <span class="attendance-calendar__period-subtitle">${this.escapeHtml(participantLabel)}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="attendance-calendar__table-wrapper">
                                <table class="attendance-calendar__table">
                                    <thead>
                                        <tr>
                                            <th scope="col" class="attendance-calendar__participant-header">Participants</th>
                    `;

                for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(year, month - 1, day);
                    const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
                    const isWeekend = date.getDay() === 0 || date.getDay() === 6;
                    html += `
                                            <th scope="col" class="${isWeekend ? 'attendance-calendar__day attendance-calendar__cell--weekend' : 'attendance-calendar__day'}">
                                                <span class="attendance-calendar__day-number">${day}</span>
                                                <span class="attendance-calendar__day-name">${this.escapeHtml(dayName)}</span>
                                            </th>
                    `;
                }

                html += `
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;

                userEntries.forEach(entry => {
                    const safeDisplay = this.escapeHtml(entry.displayName || entry.identifier || '');
                    const clickIdentifier = this.escapeForInlineEvent(entry.identifier || entry.original || '');
                    const clickDisplay = this.escapeForInlineEvent(entry.displayName || entry.identifier || '');

                    html += `
                                        <tr>
                                            <th scope="row" class="attendance-calendar__participant-cell">
                                                <span class="attendance-calendar__participant-name" title="${safeDisplay}">${safeDisplay}</span>
                                            </th>
                    `;

                    for (let day = 1; day <= daysInMonth; day++) {
                        const dateStr = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                        const date = new Date(year, month - 1, day);
                        const isWeekend = date.getDay() === 0 || date.getDay() === 6;
                        const employmentStart = entry && entry.employmentStart instanceof Date ? entry.employmentStart : null;
                        const employmentEnd = entry && entry.employmentEnd instanceof Date ? entry.employmentEnd : null;
                        const cellTime = date.getTime();
                        const employmentStartTime = employmentStart ? employmentStart.getTime() : null;
                        const employmentEndTime = employmentEnd ? employmentEnd.getTime() : null;
                        const isEmployedOnDay = (!employmentStartTime || cellTime >= employmentStartTime)
                            && (!employmentEndTime || cellTime <= employmentEndTime);

                        const cellClasses = ['attendance-calendar__cell'];
                        if (isWeekend) {
                            cellClasses.push('attendance-calendar__cell--weekend');
                        }
                        if (!isEmployedOnDay) {
                            cellClasses.push('attendance-calendar__cell--inactive');
                        }

                        const record = isEmployedOnDay
                            ? this.resolveAttendanceRecord(entry.recordKeys, dateStr, attendanceMap)
                            : null;
                        const badge = record ? this.getAttendanceStatusBadge(record.status) : null;
                        const badgeLabel = badge
                            ? this.escapeHtml(badge.label)
                            : this.escapeHtml(isEmployedOnDay ? 'Unmarked' : 'Not employed');
                        const statusClass = badge
                            ? `attendance-calendar__status ${badge.className}`
                            : `attendance-calendar__status ${isEmployedOnDay ? 'attendance-calendar__status--empty' : 'attendance-calendar__status--inactive'}`;
                        const badgeCode = badge && badge.code && badge.code !== '-' ? badge.code : '';
                        const statusContent = badgeCode ? this.escapeHtml(badgeCode) : '&#8211;';
                        const safeIdentifierAttr = this.escapeHtml(entry.identifier || entry.original || '');
                        const safeDateAttr = this.escapeHtml(dateStr);
                        const safeStatusAttr = badge && isEmployedOnDay ? this.escapeHtml(record?.status || '') : '';
                        const statusCodeAttr = badgeCode ? this.escapeHtml(badgeCode) : '';
                        const cellClassAttr = cellClasses.join(' ');
                        const displayLabel = (entry.displayName || entry.identifier || '').toString();
                        const cellTitle = this.escapeHtml(isEmployedOnDay
                            ? `Right-click or tap to mark attendance for ${displayLabel} on ${dateStr}`
                            : `${displayLabel} was not employed on ${dateStr}`);
                        const employmentAttr = isEmployedOnDay ? '' : ' data-attendance-employment="inactive"';
                        const interactionAttributes = isEmployedOnDay
                            ? ` onclick="scheduleManager.showAttendanceContextMenu(event, '${clickIdentifier}', '${dateStr}', '${clickDisplay}')" oncontextmenu="scheduleManager.showAttendanceContextMenu(event, '${clickIdentifier}', '${dateStr}', '${clickDisplay}')"`
                            : '';

                        html += `
                                            <td class="${cellClassAttr}"
                                                data-attendance-user="${safeIdentifierAttr}"
                                                data-attendance-date="${safeDateAttr}"
                                                data-attendance-status="${safeStatusAttr}"
                                                data-attendance-status-code="${statusCodeAttr}"${employmentAttr}${interactionAttributes}
                                                title="${cellTitle}">
                                                <span class="${statusClass}" title="${badgeLabel}">${statusContent}</span>
                                            </td>
                        `;
                    }

                    html += `
                                        </tr>
                    `;
                });

                html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;

                return html;
            }

            buildAttendanceRecordMap(records) {
                const map = new Map();

                if (!Array.isArray(records)) {
                    return map;
                }

                records.forEach(record => {
                    const userNameRaw = record?.userName || record?.UserName || record?.user || record?.User || '';
                    const statusRaw = record?.status || record?.Status || record?.state || record?.State || '';
                    const userName = typeof userNameRaw === 'string' ? userNameRaw.trim() : String(userNameRaw || '').trim();
                    const status = typeof statusRaw === 'string' ? statusRaw.trim() : String(statusRaw || '').trim();
                    const rawDate = record?.date || record?.Date || record?.timestamp;

                    const date = rawDate instanceof Date ? new Date(rawDate.getTime()) : (rawDate ? new Date(rawDate) : null);
                    const isoDate = this.toIsoDateString(date);
                    const userKey = this.normalizePersonKey(userName);

                    if (!userKey || !isoDate || !status) {
                        return;
                    }

                    const key = `${userKey}::${isoDate}`;
                    map.set(key, {
                        status,
                        userName,
                        date: isoDate
                    });
                });

                return map;
            }

            getAttendanceStatusBadge(status) {
                const normalizedOriginal = (status || '').toString().trim();
                const normalizedKey = this.normalizeAttendanceStatusKey(normalizedOriginal);

                if (!normalizedKey) {
                    return this.attendanceStatusBadges.empty;
                }

                if (this.attendanceStatusBadgeIndex && this.attendanceStatusBadgeIndex.has(normalizedKey)) {
                    return this.attendanceStatusBadgeIndex.get(normalizedKey);
                }

                const keywordChecks = [
                    { match: ['present', 'on time', 'punctual'], badge: this.attendanceStatusBadges.present },
                    { match: ['bereavement'], badge: this.attendanceStatusBadges.bereavement },
                    { match: ['absent', 'no show'], badge: this.attendanceStatusBadges.absent },
                    { match: ['late', 'tardy'], badge: this.attendanceStatusBadges.late },
                    { match: ['no call', 'no show'], badge: this.attendanceStatusBadges.ncns },
                    { match: ['vacation', 'pto', 'paid time off'], badge: this.attendanceStatusBadges.vacation },
                    { match: ['sick', 'illness', 'medical'], badge: this.attendanceStatusBadges.sick },
                    { match: ['leave of absence', 'loa'], badge: this.attendanceStatusBadges.loa },
                    { match: ['personal'], badge: this.attendanceStatusBadges.personal },
                    { match: ['training', 'workshop', 'session', 'class'], badge: this.attendanceStatusBadges.training }
                ];

                for (const { match, badge } of keywordChecks) {
                    if (!Array.isArray(match) || !badge) {
                        continue;
                    }

                    const isMatch = match.some(keyword => normalizedKey.includes(this.normalizeAttendanceStatusKey(keyword)));
                    if (isMatch) {
                        return badge;
                    }
                }

                const fallbackCode = normalizedOriginal ? normalizedOriginal.substring(0, 3).toUpperCase() : '?';
                return {
                    code: fallbackCode,
                    className: 'attendance-calendar__status--other',
                    label: normalizedOriginal || 'Other'
                };
            }

            ensureAttendanceContextMenu() {
                if (this.attendanceContextMenu) {
                    return this.attendanceContextMenu;
                }

                const menu = document.createElement('div');
                menu.className = 'attendance-context-menu';
                menu.setAttribute('role', 'menu');
                menu.setAttribute('aria-hidden', 'true');

                const list = document.createElement('ul');
                list.className = 'attendance-context-menu__list';

                this.attendanceStatusOptions.forEach(option => {
                    const listItem = document.createElement('li');
                    listItem.setAttribute('role', 'none');
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'attendance-context-menu__item';
                    button.dataset.status = option.value;
                    button.setAttribute('role', 'menuitem');
                    if (option.description) {
                        button.title = option.description;
                    }
                    button.innerHTML = `
                        <span class="attendance-context-menu__code ${option.className}">${option.code}</span>
                        <span class="attendance-context-menu__text">${this.escapeHtml(option.label)}</span>
                    `;
                    listItem.appendChild(button);
                    list.appendChild(listItem);
                });

                list.addEventListener('click', (event) => {
                    const button = event.target.closest('button[data-status]');
                    if (!button) {
                        return;
                    }

                    const status = button.dataset.status;
                    const target = this.attendanceContextMenuTarget;
                    this.hideAttendanceContextMenu();

                    if (target) {
                        this.setAttendanceStatus(target.userName, target.date, status, target.displayName, target.cellElement);
                    }
                });

                menu.appendChild(list);

                document.body.appendChild(menu);
                this.attendanceContextMenu = menu;
                return menu;
            }

            showAttendanceContextMenu(event, userName, date, displayName = null) {
                if (!userName || !date) {
                    return;
                }

                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }

                this.hideAttendanceContextMenu();

                const menu = this.ensureAttendanceContextMenu();
                const cellElement = (event && event.currentTarget instanceof HTMLElement)
                    ? event.currentTarget
                    : (event?.target?.closest?.('td') || null);

                this.attendanceContextMenuTarget = {
                    userName,
                    date,
                    displayName: displayName || userName,
                    cellElement: cellElement instanceof HTMLElement ? cellElement : null
                };

                menu.style.visibility = 'hidden';
                menu.style.display = 'block';
                menu.classList.add('visible');
                menu.setAttribute('aria-hidden', 'false');

                const anchorRect = event?.currentTarget?.getBoundingClientRect?.();
                const pointerX = event?.clientX ?? (anchorRect ? anchorRect.left : window.innerWidth / 2);
                const pointerY = event?.clientY ?? (anchorRect ? anchorRect.bottom : window.innerHeight / 2);

                if (anchorRect) {
                    const anchorWidth = Math.max(140, Math.round(anchorRect.width));
                    menu.style.minWidth = `${anchorWidth}px`;
                } else {
                    menu.style.minWidth = '140px';
                }

                let left = anchorRect ? anchorRect.left : pointerX;
                let top = anchorRect ? anchorRect.bottom + 2 : pointerY;

                const rect = menu.getBoundingClientRect();

                if (left + rect.width > window.innerWidth - 12) {
                    left = window.innerWidth - rect.width - 12;
                }

                if (top + rect.height > window.innerHeight - 12) {
                    if (anchorRect && (anchorRect.top - rect.height - 8) >= 12) {
                        top = anchorRect.top - rect.height - 8;
                    } else {
                        top = window.innerHeight - rect.height - 12;
                    }
                }

                left = Math.max(12, left);
                top = Math.max(12, top);

                menu.style.left = `${left}px`;
                menu.style.top = `${top}px`;
                menu.style.visibility = 'visible';

                if (this.attendanceContextMenuFocusTimer) {
                    cancelAnimationFrame(this.attendanceContextMenuFocusTimer);
                }

                this.attendanceContextMenuFocusTimer = requestAnimationFrame(() => {
                    this.attendanceContextMenuFocusTimer = null;
                    const firstItem = menu.querySelector('button.attendance-context-menu__item');
                    if (firstItem) {
                        firstItem.focus({ preventScroll: true });
                    }
                });

                if (!this.attendanceContextMenuOutsideHandler) {
                    this.attendanceContextMenuOutsideHandler = (evt) => {
                        if (!this.attendanceContextMenu?.contains(evt.target)) {
                            this.hideAttendanceContextMenu();
                        }
                    };
                }

                if (!this.attendanceContextMenuKeyHandler) {
                    this.attendanceContextMenuKeyHandler = (evt) => {
                        if (evt.key === 'Escape') {
                            this.hideAttendanceContextMenu();
                        }
                    };
                }

                document.addEventListener('click', this.attendanceContextMenuOutsideHandler);
                document.addEventListener('contextmenu', this.attendanceContextMenuOutsideHandler);
                document.addEventListener('keydown', this.attendanceContextMenuKeyHandler);
            }

            hideAttendanceContextMenu() {
                if (!this.attendanceContextMenu) {
                    return;
                }

                this.attendanceContextMenu.classList.remove('visible');
                this.attendanceContextMenu.style.display = 'none';
                this.attendanceContextMenu.style.visibility = '';
                this.attendanceContextMenu.style.left = '';
                this.attendanceContextMenu.style.top = '';
                this.attendanceContextMenu.style.minWidth = '';
                this.attendanceContextMenu.setAttribute('aria-hidden', 'true');
                this.attendanceContextMenuTarget = null;

                if (this.attendanceContextMenuOutsideHandler) {
                    document.removeEventListener('click', this.attendanceContextMenuOutsideHandler);
                    document.removeEventListener('contextmenu', this.attendanceContextMenuOutsideHandler);
                }

                if (this.attendanceContextMenuKeyHandler) {
                    document.removeEventListener('keydown', this.attendanceContextMenuKeyHandler);
                }

                if (this.attendanceContextMenuFocusTimer) {
                    cancelAnimationFrame(this.attendanceContextMenuFocusTimer);
                    this.attendanceContextMenuFocusTimer = null;
                }
            }

            async setAttendanceStatus(userName, date, status, displayName = null, cellElement = null) {
                const trimmedStatus = (status || '').toString().trim();
                if (!trimmedStatus) {
                    return;
                }

                const displayValue = displayName || userName;
                const resolvedCell = cellElement instanceof HTMLElement ? cellElement : null;

                try {
                    const result = await this.callServerFunction('clientMarkAttendanceStatus', userName, date, trimmedStatus);
                    if (result && result.success) {
                        this.showToast(`Marked ${displayValue} as ${trimmedStatus} on ${date}`, 'success');
                        this.updateAttendanceRecordCache(userName, date, trimmedStatus);
                        this.updateAttendanceCalendarCell(userName, date, trimmedStatus, resolvedCell);
                    } else {
                        throw new Error(result?.error || 'Failed to mark attendance');
                    }
                } catch (error) {
                    console.error('Error marking attendance:', error);
                    this.showToast('Failed to mark attendance: ' + error.message, 'danger');
                }
            }

            updateAttendanceRecordCache(userName, date, status) {
                const isoDate = this.normalizeAttendanceDateValue(date);
                const normalizedUser = this.normalizePersonKey(userName);

                if (!isoDate || !normalizedUser) {
                    return;
                }

                if (!Array.isArray(this.attendanceCalendarRecords)) {
                    this.attendanceCalendarRecords = [];
                }

                let updated = false;
                for (let i = 0; i < this.attendanceCalendarRecords.length; i++) {
                    const record = this.attendanceCalendarRecords[i];
                    const recordUser = record?.userName || record?.UserName || record?.user || record?.User || '';
                    const recordDate = record?.date || record?.Date || record?.timestamp || record?.Timestamp || '';
                    const recordUserKey = this.normalizePersonKey(recordUser);
                    const recordDateIso = this.normalizeAttendanceDateValue(recordDate);

                    if (recordUserKey === normalizedUser && recordDateIso === isoDate) {
                        this.attendanceCalendarRecords[i] = Object.assign({}, record, {
                            status,
                            Status: status,
                            date: isoDate,
                            Date: isoDate
                        });
                        updated = true;
                        break;
                    }
                }

                if (!updated) {
                    this.attendanceCalendarRecords.push({
                        userName,
                        UserName: userName,
                        date: isoDate,
                        Date: isoDate,
                        status,
                        Status: status
                    });
                }
            }

            updateAttendanceCalendarCell(userName, date, status, cellElement = null) {
                const isoDate = this.normalizeAttendanceDateValue(date);
                const normalizedUser = this.normalizePersonKey(userName);

                if (!isoDate || !normalizedUser) {
                    return;
                }

                if (typeof document === 'undefined') {
                    return;
                }

                let cell = null;

                if (cellElement && cellElement instanceof HTMLElement) {
                    cell = cellElement.closest('[data-attendance-user][data-attendance-date]');
                }

                if (!cell) {
                    const candidateCells = document.querySelectorAll(`[data-attendance-date="${isoDate}"]`);
                    cell = Array.from(candidateCells).find(candidate => {
                        const rawUser = candidate.getAttribute('data-attendance-user') || '';
                        return this.normalizePersonKey(rawUser) === normalizedUser;
                    }) || null;
                }

                if (!cell) {
                    return;
                }

                const badge = this.getAttendanceStatusBadge(status);
                const statusSpan = cell.querySelector('.attendance-calendar__status');

                if (!statusSpan || !badge) {
                    return;
                }

                const trimmedStatus = (status || '').toString().trim();
                const classes = ['attendance-calendar__status'];
                if (badge.className) {
                    classes.push(badge.className);
                }

                statusSpan.className = classes.join(' ');
                const displayCode = badge.code && badge.code !== '-' ? badge.code : '';
                statusSpan.textContent = displayCode;
                statusSpan.setAttribute('title', badge.label || '');

                if (trimmedStatus) {
                    cell.setAttribute('data-attendance-status', trimmedStatus);
                    if (badge.code && badge.code !== '-') {
                        cell.setAttribute('data-attendance-status-code', badge.code);
                    } else {
                        cell.removeAttribute('data-attendance-status-code');
                    }
                } else {
                    cell.removeAttribute('data-attendance-status');
                    cell.removeAttribute('data-attendance-status-code');
                }
            }

            normalizeAttendanceDateValue(value) {
                if (!value) {
                    return '';
                }

                if (value instanceof Date) {
                    return this.toIsoDateString(value);
                }

                if (Array.isArray(value)) {
                    for (let index = 0; index < value.length; index++) {
                        const candidate = this.normalizeAttendanceDateValue(value[index]);
                        if (candidate) {
                            return candidate;
                        }
                    }
                    return '';
                }

                if (value && typeof value === 'object') {
                    const objectCandidates = [
                        value.iso,
                        value.ISO,
                        value.date,
                        value.Date,
                        value.value,
                        value.Value,
                        value.start,
                        value.Start,
                        value.startDate,
                        value.StartDate,
                        value.end,
                        value.End,
                        value.endDate,
                        value.EndDate,
                        value.timestamp,
                        value.Timestamp,
                        value.time,
                        value.Time
                    ];

                    for (let index = 0; index < objectCandidates.length; index++) {
                        const candidate = this.normalizeAttendanceDateValue(objectCandidates[index]);
                        if (candidate) {
                            return candidate;
                        }
                    }

                    if (Number.isFinite(value.year) && Number.isFinite(value.month) && Number.isFinite(value.day)) {
                        const composed = new Date(value.year, value.month - 1, value.day);
                        if (!Number.isNaN(composed.getTime())) {
                            return this.toIsoDateString(composed);
                        }
                    }

                    return '';
                }

                if (typeof value === 'string') {
                    const trimmed = value.trim();
                    if (!trimmed) {
                        return '';
                    }

                    if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
                        return trimmed;
                    }

                    const isoWithTimeMatch = trimmed.match(/^(\d{4}-\d{2}-\d{2})[T\s]/);
                    if (isoWithTimeMatch && isoWithTimeMatch[1]) {
                        return isoWithTimeMatch[1];
                    }

                    const parsedStringDate = new Date(trimmed);
                    if (!Number.isNaN(parsedStringDate.getTime())) {
                        return this.toIsoDateString(parsedStringDate);
                    }

                    return '';
                }

                const parsedDate = new Date(value);
                if (!Number.isNaN(parsedDate.getTime())) {
                    return this.toIsoDateString(parsedDate);
                }

                return '';
            }

            normalizeAttendanceStatusKey(value) {
                const raw = (value || '').toString().trim().toLowerCase();
                if (!raw) {
                    return '';
                }

                return raw
                    .replace(/[^a-z0-9]+/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }

            async markAttendance(userName, date, displayName = null, status = null) {
                if (!status) {
                    this.showAttendanceContextMenu(null, userName, date, displayName);
                    return;
                }

                await this.setAttendanceStatus(userName, date, status, displayName, null);
            }

            async handleScheduleImport() {
                try {
                    this.showLoading(true);

                    const startDate = document.getElementById('importStartDate')?.value;
                    const endDate = document.getElementById('importEndDate')?.value;
                    const sourceMonth = parseInt(document.getElementById('importMonth')?.value, 10);
                    const sourceYear = parseInt(document.getElementById('importYear')?.value, 10);
                    const replaceExisting = document.getElementById('importReplace')?.checked === true;
                    const fileInput = document.getElementById('scheduleFile');
                    const file = fileInput?.files?.[0];
                    const googleSheetUrl = document.getElementById('googleSheetUrl')?.value?.trim();
                    const googleSheetTab = document.getElementById('googleSheetTab')?.value?.trim();
                    const googleSheetRange = document.getElementById('googleSheetRange')?.value?.trim();

                    if (!file && !googleSheetUrl) {
                        throw new Error('Please select a schedule file or provide a Google Sheets link to import.');
                    }
                    if (!startDate) {
                        throw new Error('Please select the starting date.');
                    }
                    if (!endDate) {
                        throw new Error('Please select the ending date.');
                    }

                    const rangeValidation = this.validateImportDateRange(startDate, endDate);
                    if (!rangeValidation.valid) {
                        throw new Error(rangeValidation.message || 'Please provide a valid date range.');
                    }
                    if (!sourceMonth || Number.isNaN(sourceMonth)) {
                        throw new Error('Please select the source month.');
                    }
                    if (!sourceYear || Number.isNaN(sourceYear)) {
                        throw new Error('Please provide the source year.');
                    }

                    const options = {
                        startDate,
                        endDate,
                        sourceMonth,
                        sourceYear,
                        fileName: file?.name || ''
                    };

                    let parseResult = { schedules: [], summary: null };
                    let googleSheetMetadata = null;

                    if (file) {
                        parseResult = await this.parseScheduleFile(file, options);
                    } else if (googleSheetUrl) {
                        googleSheetMetadata = await this.fetchGoogleSheetRows({
                            url: googleSheetUrl,
                            sheetName: googleSheetTab || undefined,
                            range: googleSheetRange || undefined
                        });

                        if (!googleSheetMetadata || !Array.isArray(googleSheetMetadata.rows)) {
                            throw new Error('The Google Sheets link did not return any data to import.');
                        }

                        if (googleSheetMetadata.spreadsheetName) {
                            options.fileName = googleSheetMetadata.sheetName
                                ? `${googleSheetMetadata.spreadsheetName}  ${googleSheetMetadata.sheetName}`
                                : googleSheetMetadata.spreadsheetName;
                        } else {
                            options.fileName = 'Google Sheets Import';
                        }

                        parseResult = this.transformScheduleRows(googleSheetMetadata.rows, options || {});
                        this.pendingImportSchedules = parseResult.schedules;
                        this.pendingImportSummary = parseResult.summary;
                    }

                    const schedules = parseResult && Array.isArray(parseResult.schedules)
                        ? parseResult.schedules
                        : [];
                    const summary = parseResult ? parseResult.summary : null;

                    if (!schedules.length) {
                        this.renderImportPreview([], options, summary);
                        this.showToast('No schedules were detected in the provided data.', 'warning');
                        return;
                    }

                    this.renderImportPreview(schedules, options, summary);

                    const importDays = summary?.dayCount ?? this.countDaysInRange(startDate, endDate);
                    const dateStartLabel = summary?.startDate ? this.formatDate(summary.startDate) : this.formatDate(startDate);
                    const dateEndLabel = summary?.endDate ? this.formatDate(summary.endDate) : this.formatDate(endDate);
                    const message = `Import ${schedules.length} schedule${schedules.length === 1 ? '' : 's'} covering ${importDays} day${importDays === 1 ? '' : 's'} from ${dateStartLabel} to ${dateEndLabel}?`;
                    if (!confirm(message)) {
                        return;
                    }

                    const payload = {
                        metadata: {
                            startDate,
                            endDate,
                            dayCount: summary?.dayCount ?? importDays,
                            sourceMonth,
                            sourceYear,
                            fileName: options.fileName || file?.name || '',
                            importedBy: this.getCurrentUserId(),
                            replaceExisting,
                            summary,
                            sourceType: file ? 'FILE_UPLOAD' : 'GOOGLE_SHEET'
                        },
                        schedules
                    };

                    if (!file && googleSheetMetadata) {
                        payload.metadata.googleSheet = {
                            url: googleSheetUrl,
                            sheetName: googleSheetMetadata.sheetName || '',
                            spreadsheetName: googleSheetMetadata.spreadsheetName || '',
                            range: googleSheetMetadata.range || '',
                            sheetId: googleSheetMetadata.sheetId || '',
                            rowCount: googleSheetMetadata.rowCount || 0,
                            columnCount: googleSheetMetadata.columnCount || 0
                        };
                    }

                    const result = await this.callServerFunction('clientImportSchedules', payload);

                    if (result && result.success) {
                        this.lastImportResult = result;
                        this.showToast(`Imported ${result.importedCount} schedule${result.importedCount === 1 ? '' : 's'} successfully!`, 'success');
                        this.renderImportSummary(result);

                        const fileControl = document.getElementById('scheduleFile');
                        if (fileControl) {
                            fileControl.value = '';
                        }
                        if (!file && googleSheetUrl) {
                            const googleSheetStatus = document.getElementById('googleSheetStatus');
                            if (googleSheetStatus) {
                                googleSheetStatus.textContent = 'Google Sheets import completed successfully.';
                            }
                        }
                        this.updateImportFileName();

                        await this.loadSchedules();
                    } else {
                        throw new Error(result?.error || 'Failed to import schedules.');
                    }
                } catch (error) {
                    console.error(' Schedule import failed:', error);
                    this.showToast('Schedule import failed: ' + error.message, 'danger');
                } finally {
                    this.showLoading(false);
                }
            }

            async parseScheduleFile(file, options) {
                const text = await this.readFileAsText(file);
                const rows = this.parseCsv(text);
                if (!rows || rows.length === 0) {
                    return {
                        schedules: [],
                        summary: {
                            totalRows: 0,
                            totalShifts: 0,
                            skippedEntries: 0,
                            totalAgents: 0,
                            totalAssignments: 0,
                            weekCount: 0,
                            startDate: '',
                            endDate: '',
                            duplicatesSkipped: 0,
                            agentsWithoutSchedules: []
                        }
                    };
                }

                const result = this.transformScheduleRows(rows, options || {});
                this.pendingImportSchedules = result.schedules;
                this.pendingImportSummary = result.summary;
                return result;
            }

            async fetchGoogleSheetRows(requestOptions = {}) {
                try {
                    const payload = typeof requestOptions === 'string'
                        ? { url: requestOptions }
                        : (requestOptions || {});

                    const result = await this.callServerFunction('clientFetchScheduleSheetData', payload);
                    if (!result || result.success !== true) {
                        throw new Error(result?.error || 'Unable to retrieve data from Google Sheets.');
                    }

                    return result;
                } catch (error) {
                    console.error(' Error fetching Google Sheet data:', error);
                    throw error;
                }
            }

            readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    try {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = () => reject(new Error('Unable to read the selected file.'));
                        reader.readAsText(file);
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            parseCsv(text) {
                if (!text) {
                    return [];
                }

                const rows = [];
                let current = '';
                let inQuotes = false;
                let row = [];

                for (let i = 0; i < text.length; i++) {
                    const char = text[i];

                    if (char === '"') {
                        if (inQuotes && text[i + 1] === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if ((char === ',' || char === '\t') && !inQuotes) {
                        row.push(current);
                        current = '';
                    } else if ((char === '\n' || char === '\r') && !inQuotes) {
                        if (char === '\r' && text[i + 1] === '\n') {
                            i++;
                        }
                        row.push(current);
                        rows.push(row);
                        row = [];
                        current = '';
                    } else {
                        current += char;
                    }
                }

                if (current.length > 0 || row.length > 0) {
                    row.push(current);
                    rows.push(row);
                }

                return rows.map(columns => columns.map(value => {
                    if (value === null || value === undefined) {
                        return '';
                    }
                    return value.toString().replace(/\uFEFF/g, '');
                }));
            }

            transformScheduleRows(rows, options = {}) {
                const cleanedRows = rows
                    .map(row => row.map(cell => this.normalizeCellValue(cell)))
                    .filter(row => row.some(cell => cell !== ''));

                const summary = {
                    totalRows: Math.max(cleanedRows.length - 1, 0),
                    totalShifts: 0,
                    totalAssignments: 0,
                    skippedEntries: 0,
                    totalAgents: 0,
                    dayCount: 0,
                    startDate: '',
                    endDate: '',
                    duplicatesSkipped: 0,
                    agentsWithoutSchedules: [],
                    sourceMonth: options.sourceMonth,
                    sourceYear: options.sourceYear
                };

                if (cleanedRows.length <= 1) {
                    return { schedules: [], summary };
                }

                const headerRow = cleanedRows[0];
                const headerKeys = headerRow.map(value => this.normalizeHeaderKey(value));

                const dayColumns = [];
                headerKeys.forEach((key, index) => {
                    if (!key) return;
                    if (key.startsWith('sun')) dayColumns.push({ index, dayOfWeek: 0, label: headerRow[index] || 'Sunday' });
                    else if (key.startsWith('mon')) dayColumns.push({ index, dayOfWeek: 1, label: headerRow[index] || 'Monday' });
                    else if (key.startsWith('tue')) dayColumns.push({ index, dayOfWeek: 2, label: headerRow[index] || 'Tuesday' });
                    else if (key.startsWith('wed')) dayColumns.push({ index, dayOfWeek: 3, label: headerRow[index] || 'Wednesday' });
                    else if (key.startsWith('thu')) dayColumns.push({ index, dayOfWeek: 4, label: headerRow[index] || 'Thursday' });
                    else if (key.startsWith('fri')) dayColumns.push({ index, dayOfWeek: 5, label: headerRow[index] || 'Friday' });
                    else if (key.startsWith('sat')) dayColumns.push({ index, dayOfWeek: 6, label: headerRow[index] || 'Saturday' });
                });

                if (dayColumns.length === 0) {
                    throw new Error('The importer could not find any day columns (Sunday through Saturday).');
                }

                const dayColumnIndexes = new Set(dayColumns.map(column => column.index));

                let agentColumnIndex = headerKeys.findIndex(key => key.includes('agent') || key.includes('employee') || key.includes('name'));
                if (agentColumnIndex === -1 || dayColumnIndexes.has(agentColumnIndex)) {
                    agentColumnIndex = headerKeys.findIndex((key, index) => !dayColumnIndexes.has(index));
                }

                if (agentColumnIndex === -1) {
                    throw new Error('The importer could not identify an agent column in the uploaded file or sheet.');
                }

                const slotIndex = headerKeys.findIndex((key, index) => {
                    if (dayColumnIndexes.has(index)) {
                        return false;
                    }
                    if (index === agentColumnIndex) {
                        return false;
                    }
                    return key.includes('slot') || key.includes('shift') || key.includes('time');
                });
                const effectiveSlotIndex = slotIndex !== -1 ? slotIndex : -1;

                const dateRange = this.generateDateRange(options.startDate, options.endDate);
                if (dateRange.length === 0) {
                    throw new Error('Please provide a valid start and end date to import the monthly schedule.');
                }

                const dayColumnMap = new Map();
                dayColumns.forEach(column => {
                    if (!dayColumnMap.has(column.dayOfWeek)) {
                        dayColumnMap.set(column.dayOfWeek, column);
                    }
                });

                const relevantDates = dateRange.filter(dateInfo => dayColumnMap.has(dateInfo.dayOfWeek));
                if (relevantDates.length === 0) {
                    throw new Error('The importer could not match the selected dates to any day columns in the file.');
                }

                summary.dayCount = relevantDates.length;

                const excludedColumns = new Set(dayColumnIndexes);
                if (agentColumnIndex !== -1) {
                    excludedColumns.add(agentColumnIndex);
                }
                if (effectiveSlotIndex !== -1) {
                    excludedColumns.add(effectiveSlotIndex);
                }

                const breakColumns = this.identifyBreakAndLunchColumns(headerKeys, excludedColumns);

                const schedules = [];
                const agentSet = new Set();
                const seenAssignments = new Set();

                cleanedRows.slice(1).forEach((row, rowIndex) => {
                    const agentName = agentColumnIndex !== -1 ? this.normalizeCellValue(row[agentColumnIndex]) : '';
                    if (!agentName) {
                        summary.skippedEntries++;
                        return;
                    }

                    const agentKey = this.normalizePersonKey(agentName);
                    const slotCellValue = effectiveSlotIndex !== -1 ? this.normalizeCellValue(row[effectiveSlotIndex]) : '';
                    const slotRange = this.parseTimeRange(slotCellValue);
                    const baseSlotLabel = slotRange?.label || slotCellValue || '';

                    const break1Times = this.extractTimeWindowFromRow(row, breakColumns.break1);
                    const lunchTimes = this.extractTimeWindowFromRow(row, breakColumns.lunch);
                    const break2Times = this.extractTimeWindowFromRow(row, breakColumns.break2);

                    let rowAssignments = 0;
                    let agentHasSchedule = false;

                    relevantDates.forEach(dateInfo => {
                        const dayColumn = dayColumnMap.get(dateInfo.dayOfWeek);
                        if (!dayColumn) {
                            return;
                        }

                        const cellValue = this.normalizeCellValue(row[dayColumn.index]);
                        if (!cellValue) {
                            return;
                        }

                        if (this.isSkippableAssignmentValue(cellValue)) {
                            summary.skippedEntries++;
                            return;
                        }

                        const assignmentRange = this.parseTimeRange(cellValue) || slotRange;
                        const slotLabel = (assignmentRange?.label || baseSlotLabel || cellValue || `Imported Slot ${rowIndex + 1}`).trim();
                        const date = dateInfo.iso;
                        const assignmentKey = `${agentKey}::${date}`;
                        if (seenAssignments.has(assignmentKey)) {
                            summary.duplicatesSkipped++;
                            return;
                        }

                        seenAssignments.add(assignmentKey);
                        agentSet.add(agentKey);
                        agentHasSchedule = true;

                        const schedule = {
                            UserName: agentName,
                            Date: date,
                            StartTime: assignmentRange?.start || '',
                            EndTime: assignmentRange?.end || '',
                            SlotName: slotLabel,
                            Status: 'PENDING',
                            SourceDayLabel: dayColumn.label || '',
                            SourceMonth: options.sourceMonth,
                            SourceYear: options.sourceYear,
                            SourceCell: cellValue
                        };

                        if (slotCellValue && !slotRange && slotCellValue !== cellValue) {
                            schedule.Notes = `Slot: ${slotCellValue}`;
                        }

                        if (break1Times.start) {
                            schedule.BreakStart = break1Times.start;
                        }
                        if (break1Times.end) {
                            schedule.BreakEnd = break1Times.end;
                        }
                        if (lunchTimes.start) {
                            schedule.LunchStart = lunchTimes.start;
                        }
                        if (lunchTimes.end) {
                            schedule.LunchEnd = lunchTimes.end;
                        }
                        if (break2Times.start) {
                            schedule.Break2Start = break2Times.start;
                        }
                        if (break2Times.end) {
                            schedule.Break2End = break2Times.end;
                        }

                        schedules.push(schedule);
                        summary.totalShifts++;
                        summary.totalAssignments++;
                        rowAssignments++;
                    });

                    if (!agentHasSchedule) {
                        if (!summary.agentsWithoutSchedules.includes(agentName)) {
                            summary.agentsWithoutSchedules.push(agentName);
                        }
                    } else if (rowAssignments === 0 && baseSlotLabel) {
                        if (!summary.agentsWithoutSchedules.includes(agentName)) {
                            summary.agentsWithoutSchedules.push(agentName);
                        }
                    }
                });

                if (schedules.length > 0) {
                    const dates = schedules
                        .map(item => new Date(item.Date))
                        .filter(date => !isNaN(date.getTime()));

                    if (dates.length > 0) {
                        const minDate = new Date(Math.min.apply(null, dates));
                        const maxDate = new Date(Math.max.apply(null, dates));
                        summary.startDate = this.toIsoDateString(minDate);
                        summary.endDate = this.toIsoDateString(maxDate);
                    }
                } else if (relevantDates.length > 0) {
                    summary.startDate = relevantDates[0].iso;
                    summary.endDate = relevantDates[relevantDates.length - 1].iso;
                }

                if (!summary.weekCount || summary.weekCount < 0) {
                    const weekSpanStart = summary.startDate || options.startDate || (relevantDates[0]?.iso ?? '');
                    const weekSpanEnd = summary.endDate || options.endDate || (relevantDates[relevantDates.length - 1]?.iso ?? '');
                    summary.weekCount = this.calculateWeekSpanCount(weekSpanStart, weekSpanEnd, options.startDate, options.endDate);
                }

                summary.totalAgents = agentSet.size;
                return { schedules, summary };
            }

            validateImportDateRange(startDate, endDate) {
                if (!startDate || !endDate) {
                    return { valid: false, message: 'Start and end dates are required.' };
                }

                const start = new Date(startDate);
                const end = new Date(endDate);

                if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                    return { valid: false, message: 'Invalid date selection. Please use valid dates.' };
                }

                if (end < start) {
                    return { valid: false, message: 'The ending date must be the same as or after the starting date.' };
                }

                return { valid: true };
            }

            resolveDateInput(value) {
                if (value === undefined || value === null || value === '') {
                    return null;
                }

                if (value instanceof Date) {
                    const clone = new Date(value);
                    return isNaN(clone.getTime()) ? null : clone;
                }

                if (typeof value === 'object' && value.iso) {
                    return this.resolveDateInput(value.iso);
                }

                if (typeof value === 'number' && !Number.isNaN(value)) {
                    const asDate = new Date(value);
                    return isNaN(asDate.getTime()) ? null : asDate;
                }

                const parsed = new Date(value);
                return isNaN(parsed.getTime()) ? null : parsed;
            }

            countDaysInRange(startDate, endDate) {
                const start = this.resolveDateInput(startDate);
                const end = this.resolveDateInput(endDate);

                if (!start || !end || end < start) {
                    return 0;
                }

                const diff = Math.floor((end - start) / (24 * 60 * 60 * 1000)) + 1;
                return diff > 0 ? diff : 0;
            }

            calculateWeekSpanCount(startDate, endDate, minDate, maxDate) {
                let start = this.resolveDateInput(startDate) || this.resolveDateInput(minDate);
                let end = this.resolveDateInput(endDate) || this.resolveDateInput(maxDate);

                if (!start || !end || end < start) {
                    return 0;
                }

                const diff = Math.floor((end - start) / (24 * 60 * 60 * 1000)) + 1;
                return diff > 0 ? Math.ceil(diff / 7) : 0;
            }

            generateDateRange(startDate, endDate) {
                const start = this.resolveDateInput(startDate);
                const end = this.resolveDateInput(endDate);

                if (!start || !end || end < start) {
                    return [];
                }

                const dates = [];
                const cursor = new Date(start.getTime());

                while (cursor <= end) {
                    dates.push({
                        iso: this.toIsoDateString(cursor),
                        dayOfWeek: cursor.getDay()
                    });
                    cursor.setDate(cursor.getDate() + 1);
                }

                return dates;
            }

            extractAgentNames(cellValue) {
                if (!cellValue) {
                    return [];
                }

                const parts = cellValue
                    .split(/[,&;\/\n]+/)
                    .map(part => part.trim())
                    .filter(part => part);

                return parts.filter(part => !this.isSkippableAssignmentValue(part));
            }

            isSkippableAssignmentValue(value) {
                const normalized = value.toLowerCase().replace(/[^a-z]/g, '');
                if (!normalized) {
                    return true;
                }

                const skipValues = new Set(['off', 'na', 'none', 'vacation', 'holiday', 'leave', 'pto']);
                if (skipValues.has(normalized)) {
                    return true;
                }

                return Array.from(skipValues).some(keyword => normalized.startsWith(keyword));
            }

            normalizePersonKey(value) {
                return (value || '').toString().trim().toLowerCase().replace(/\s+/g, ' ');
            }

            normalizeCellValue(value) {
                if (value === undefined || value === null) {
                    return '';
                }
                return value.toString().replace(/\uFEFF/g, '').trim();
            }

            normalizeHeaderKey(value) {
                return this.normalizeCellValue(value).toLowerCase().replace(/[^a-z0-9]/g, '');
            }

            parseTimeRange(value) {
                if (value === undefined || value === null) {
                    return null;
                }

                const raw = value.toString().trim();
                if (!raw) return null;
                if (/^(n\/a|na|off|-|none)$/i.test(raw)) {
                    return null;
                }

                const normalizedRaw = raw
                    .replace(/[]/g, '-')
                    .replace(/\bto\b/gi, '-')
                    .replace(/\s+-\s+/g, ' - ');

                const dashIndex = normalizedRaw.indexOf('-');
                if (dashIndex === -1) {
                    return null;
                }

                const start = normalizedRaw.slice(0, dashIndex).trim();
                const endSegment = normalizedRaw.slice(dashIndex + 1).trim();
                const end = endSegment.split(/[(/]/)[0].trim();

                if (!start || !end) {
                    return null;
                }

                return { start, end, label: raw };
            }

            identifyBreakAndLunchColumns(headerKeys, excludedColumns = new Set()) {
                const findIndex = (keywords) => {
                    return headerKeys.findIndex((key, index) => {
                        if (excludedColumns.has(index)) {
                            return false;
                        }

                        return keywords.some(keyword => key.includes(keyword));
                    });
                };

                const break1RangeIndex = findIndex(['break1', 'firstbreak']);
                const break1StartIndex = findIndex(['break1start', 'startbreak1', 'firstbreakstart']);
                const break1EndIndex = findIndex(['break1end', 'endbreak1', 'firstbreakend']);

                let genericBreakIndex = -1;
                if (break1RangeIndex === -1) {
                    genericBreakIndex = headerKeys.findIndex((key, index) => {
                        if (excludedColumns.has(index)) {
                            return false;
                        }

                        const matchesBreak = key.includes('break');
                        const isBreak2 = key.includes('break2') || key.includes('secondbreak');
                        return matchesBreak && !isBreak2;
                    });
                }

                const lunchRangeIndex = findIndex(['lunch']);
                const lunchStartIndex = findIndex(['lunchstart', 'startlunch']);
                const lunchEndIndex = findIndex(['lunchend', 'endlunch']);

                const break2RangeIndex = findIndex(['break2', 'secondbreak']);
                const break2StartIndex = findIndex(['break2start', 'startbreak2', 'secondbreakstart']);
                const break2EndIndex = findIndex(['break2end', 'endbreak2', 'secondbreakend']);

                return {
                    break1: {
                        range: break1RangeIndex !== -1 ? break1RangeIndex : genericBreakIndex,
                        start: break1StartIndex,
                        end: break1EndIndex
                    },
                    lunch: {
                        range: lunchRangeIndex,
                        start: lunchStartIndex,
                        end: lunchEndIndex
                    },
                    break2: {
                        range: break2RangeIndex,
                        start: break2StartIndex,
                        end: break2EndIndex
                    }
                };
            }

            extractTimeWindowFromRow(row, columnConfig = {}) {
                if (!columnConfig || Object.keys(columnConfig).length === 0) {
                    return { start: '', end: '' };
                }

                const rangeValue = columnConfig.range !== undefined && columnConfig.range !== -1
                    ? this.normalizeCellValue(row[columnConfig.range])
                    : '';
                const startValue = columnConfig.start !== undefined && columnConfig.start !== -1
                    ? this.normalizeCellValue(row[columnConfig.start])
                    : '';
                const endValue = columnConfig.end !== undefined && columnConfig.end !== -1
                    ? this.normalizeCellValue(row[columnConfig.end])
                    : '';

                let start = '';
                let end = '';

                const applyRange = (value) => {
                    if (!value) {
                        return false;
                    }

                    if (this.isSkippableAssignmentValue(value)) {
                        return false;
                    }

                    const parsed = this.parseTimeRange(value);
                    if (parsed) {
                        start = start || parsed.start;
                        end = end || parsed.end;
                        return true;
                    }

                    if (!start) {
                        start = value;
                    }

                    return false;
                };

                applyRange(rangeValue);

                if (!start && startValue) {
                    if (!applyRange(startValue)) {
                        start = startValue || start;
                    }
                }

                if (!end && endValue) {
                    if (!applyRange(endValue)) {
                        end = endValue || end;
                    }
                }

                if (!end && rangeValue && start && rangeValue !== start && !this.isSkippableAssignmentValue(rangeValue)) {
                    const normalized = rangeValue.replace(start, '').replace(/[]/g, '-');
                    const parts = normalized.split('-').map(part => part.trim()).filter(Boolean);
                    if (parts.length > 0) {
                        end = parts[parts.length - 1];
                    }
                }

                return {
                    start: start || '',
                    end: end || ''
                };
            }

            toIsoDateString(date) {
                if (!(date instanceof Date) || isNaN(date.getTime())) {
                    return '';
                }

                const local = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
                return local.toISOString().split('T')[0];
            }

            resolveIsoDate(value, fallback = null) {
                const parsed = this.parseDateValue(value);
                if (parsed) {
                    return this.toIsoDateString(parsed);
                }

                if (fallback) {
                    return this.resolveIsoDate(fallback);
                }

                return '';
            }

            renderImportPreview(schedules, options = {}, summary = {}) {
                const container = document.getElementById('importPreview');
                if (!container) return;

                if (!Array.isArray(schedules) || schedules.length === 0) {
                    container.innerHTML = `
                        <div class="alert alert-warning-modern">
                            <i class="fas fa-info-circle me-2"></i>No schedules detected in the provided data.
                        </div>
                    `;
                    this.pendingImportSchedules = [];
                    this.pendingImportSummary = summary;
                    return;
                }

                this.pendingImportSchedules = schedules;
                this.pendingImportSummary = summary;

                const total = schedules.length;
                const sample = schedules.slice(0, Math.min(total, 10));
                const monthName = this.getMonthName(options.sourceMonth);
                const dateRange = summary?.startDate && summary?.endDate
                    ? `${this.formatDate(summary.startDate)} - ${this.formatDate(summary.endDate)}`
                    : '';
                const startDateLabel = this.formatDate(options.startDate);
                const endDateLabel = this.formatDate(options.endDate);
                const fallbackRange = startDateLabel && endDateLabel
                    ? `${startDateLabel} - ${endDateLabel}`
                    : (startDateLabel || endDateLabel || '');
                const dayCount = summary?.dayCount ?? this.countDaysInRange(options.startDate, options.endDate);

                container.innerHTML = `
                    <div class="alert alert-info-modern">
                        <div class="d-flex flex-wrap gap-3">
                            <span><strong>Date range:</strong> ${dateRange || fallbackRange || 'N/A'}</span>
                            <span><strong>Source month:</strong> ${monthName || 'N/A'} ${options.sourceYear || ''}</span>
                            <span><strong>Days covered:</strong> ${dayCount}</span>
                            <span><strong>Assignments:</strong> ${total}</span>
                            <span><strong>Unique agents:</strong> ${summary?.totalAgents ?? 0}</span>
                        </div>
                        ${summary?.skippedEntries ? `<div class="mt-2 text-warning"><i class="fas fa-exclamation-triangle me-2"></i>${summary.skippedEntries} cell${summary.skippedEntries === 1 ? '' : 's'} skipped.</div>` : ''}
                        ${summary?.duplicatesSkipped ? `<div class="mt-2 text-warning"><i class="fas fa-clone me-2"></i>${summary.duplicatesSkipped} duplicate assignment${summary.duplicatesSkipped === 1 ? '' : 's'} skipped.</div>` : ''}
                    </div>
                    <div class="table-responsive">
                        <table class="table table-modern table-sm">
                            <thead>
                                <tr>
                                    <th>Agent</th>
                                    <th>Date</th>
                                    <th>Slot</th>
                                    <th>Start</th>
                                    <th>End</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sample.map(item => `
                                    <tr>
                                        <td>${item.UserName}</td>
                                        <td>${this.formatDate(item.Date)}</td>
                                        <td>${item.SlotName || ''}</td>
                                        <td>${item.StartTime || ''}</td>
                                        <td>${item.EndTime || ''}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    <p class="text-muted small mb-0">Showing first ${sample.length} of ${total} schedule entries detected.</p>
                    ${summary?.agentsWithoutSchedules && summary.agentsWithoutSchedules.length ? `
                        <div class="alert alert-warning-modern mt-3">
                            <strong>Heads up:</strong> ${summary.agentsWithoutSchedules.length} agent${summary.agentsWithoutSchedules.length === 1 ? '' : 's'} had no scheduled days: ${summary.agentsWithoutSchedules.join(', ')}.
                        </div>
                    ` : ''}
                `;
            }

            renderImportSummary(result) {
                const container = document.getElementById('importSummary');
                if (!container) return;

                if (!result || !result.success) {
                    container.innerHTML = '';
                    return;
                }

                const range = result.range?.start && result.range?.end
                    ? `${this.formatDate(result.range.start)} - ${this.formatDate(result.range.end)}`
                    : (result.range?.start ? this.formatDate(result.range.start) : '');

                const metadata = result.metadata || {};
                const daysCovered = metadata?.summary?.dayCount ?? metadata.dayCount ?? '';
                const startDateLabel = metadata.startDate ? this.formatDate(metadata.startDate) : '';
                const endDateLabel = metadata.endDate ? this.formatDate(metadata.endDate) : '';
                const googleSheetMeta = metadata.googleSheet || null;
                const sourceLabel = googleSheetMeta
                    ? `${googleSheetMeta.spreadsheetName || 'Google Sheet'}${googleSheetMeta.sheetName ? `  ${googleSheetMeta.sheetName}` : ''}`
                    : (metadata.fileName || '');

                container.innerHTML = `
                    <div class="alert alert-success-modern">
                        <h6 class="mb-2"><i class="fas fa-check-circle me-2"></i>Import Complete</h6>
                        <ul class="mb-0">
                            <li><strong>Imported:</strong> ${result.importedCount}</li>
                            <li><strong>Replaced:</strong> ${result.replacedCount || 0}</li>
                            <li><strong>Total schedules now:</strong> ${result.totalAfterImport ?? 'N/A'}</li>
                            ${sourceLabel ? `<li><strong>Source:</strong> ${sourceLabel}${googleSheetMeta?.range ? ` (${googleSheetMeta.range})` : ''}</li>` : ''}
                            ${metadata.sourceType === 'GOOGLE_SHEET' && googleSheetMeta?.url ? `<li><strong>Sheet link:</strong> <a href="${googleSheetMeta.url}" target="_blank" rel="noopener">Open in Google Sheets</a></li>` : ''}
                            ${range ? `<li><strong>Date range affected:</strong> ${range}</li>` : ''}
                            ${daysCovered ? `<li><strong>Days covered:</strong> ${daysCovered}</li>` : ''}
                            ${startDateLabel && endDateLabel ? `<li><strong>Date span:</strong> ${startDateLabel} - ${endDateLabel}</li>` : ''}
                        </ul>
                    </div>
                `;
            }

            clearImportPreview() {
                const container = document.getElementById('importPreview');
                if (container) {
                    container.innerHTML = '';
                }
                this.pendingImportSchedules = [];
                this.pendingImportSummary = null;
            }

            clearImportSummary() {
                const container = document.getElementById('importSummary');
                if (container) {
                    container.innerHTML = '';
                }
            }

            handleScheduleFileSelect(event) {
                const file = event?.target?.files?.[0];
                this.updateImportFileName(file?.name || '');
                this.clearImportPreview();
                this.clearImportSummary();
                if (file) {
                    const googleSheetUrl = document.getElementById('googleSheetUrl');
                    if (googleSheetUrl) {
                        googleSheetUrl.value = '';
                    }
                    const status = document.getElementById('googleSheetStatus');
                    if (status) {
                        status.textContent = '';
                    }
                }
            }

            handleGoogleSheetUrlChange(event) {
                const urlValue = event?.target?.value?.trim();
                const fileInput = document.getElementById('scheduleFile');
                if (urlValue && fileInput) {
                    fileInput.value = '';
                }
                const status = document.getElementById('googleSheetStatus');
                if (status) {
                    status.textContent = urlValue ? 'Using Google Sheets link for this import.' : '';
                }
                this.updateImportFileName();
                this.clearImportPreview();
                this.clearImportSummary();
            }

            updateImportFileName(fileName) {
                const label = document.getElementById('importFileName');
                if (!label) return;

                if (fileName) {
                    label.textContent = `Selected file: ${fileName}`;
                    return;
                }

                const googleSheetUrl = document.getElementById('googleSheetUrl');
                if (googleSheetUrl && googleSheetUrl.value.trim()) {
                    label.textContent = 'Importing from the provided Google Sheets link.';
                } else {
                    label.textContent = 'Upload a CSV export of the schedule grid or provide a Google Sheets link.';
                }
            }

            getMonthName(monthNumber) {
                const months = [
                    'January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'
                ];

                const index = Number(monthNumber) - 1;
                return months[index] || '';
            }

            buildHolidaySummaryMarkup(response) {
                const countryNames = {
                    'JM': 'Jamaica',
                    'US': 'United States',
                    'DO': 'Dominican Republic',
                    'PH': 'Philippines'
                };

                const holidays = Array.isArray(response?.holidays) ? response.holidays : [];
                const countryCode = response?.country || response?.countryCode || '';
                const countryName = countryNames[countryCode] || countryCode || 'Selected Country';
                const year = response?.year || new Date().getFullYear();
                const isPrimary = !!response?.isPrimary;

                if (!holidays.length) {
                    return `
                        <div class="alert alert-info-modern">
                            <h6><i class="fas fa-info-circle me-2"></i>No holidays imported yet</h6>
                            <p class="mb-0">Use the form above to import holidays for ${this.escapeHtml(countryName)} ${this.escapeHtml(String(year))}.</p>
                        </div>
                    `;
                }

                const rows = holidays.map(holiday => `
                    <div class="col-md-6 mb-1">
                        <small>
                            <strong>${this.escapeHtml(holiday.name || holiday.Name || 'Holiday')}</strong> - ${this.formatDate(holiday.date || holiday.Date || '')}
                        </small>
                    </div>
                `).join('');

                return `
                    <div class="alert ${isPrimary ? 'alert-success' : 'alert-info'}-modern">
                        <h6>
                            <i class="fas fa-calendar-day me-2"></i>
                            ${this.escapeHtml(countryName)} Holidays ${this.escapeHtml(String(year))} ${isPrimary ? '(PRIMARY - Takes Precedence)' : ''}
                        </h6>
                        <div class="row">
                            ${rows}
                        </div>
                    </div>
                `;
            }

            async importHolidays() {
                try {
                    this.showLoading(true);

                    const countrySelect = document.getElementById('holidayCountry');
                    const yearSelect = document.getElementById('holidayYear');
                    const countryCode = this.resolveHolidayCountryCode(countrySelect ? countrySelect.value : '');
                    const year = this.resolveHolidayYear(yearSelect ? yearSelect.value : '');

                    if (!countryCode || !year) {
                        throw new Error('Please select both country and year');
                    }

                    this.setSelectValueIfAvailable(countrySelect, countryCode);
                    this.setSelectValueIfAvailable(yearSelect, year);

                    const result = await this.callServerFunction('clientGetCountryHolidays', countryCode, year);

                    if (result && result.success) {
                        const countryNames = {
                            'JM': 'Jamaica',
                            'US': 'United States',
                            'DO': 'Dominican Republic',
                            'PH': 'Philippines'
                        };

                        const resolvedCountryCode = result.country || result.countryCode || countryCode;
                        const countryName = countryNames[resolvedCountryCode] || resolvedCountryCode;
                        const resolvedYear = result.year || year;
                        const priority = result.isPrimary ? ' (PRIMARY)' : '';

                        if (countrySelect) {
                            this.setSelectValueIfAvailable(countrySelect, resolvedCountryCode);
                        }
                        if (yearSelect) {
                            this.setSelectValueIfAvailable(yearSelect, resolvedYear);
                        }

                        const successMessage = `Successfully loaded ${result.holidays.length} holidays for ${countryName} ${resolvedYear}${priority}`;
                        if (result.fallbackApplied && result.note) {
                            this.showToast(successMessage, 'success');
                            this.showToast(result.note, 'warning');
                        } else {
                            this.showToast(successMessage, 'success');
                        }

                        // Display holidays
                        this.displayHolidayPreview(result.holidays, countryName, resolvedYear, result.isPrimary);

                    } else {
                        throw new Error(result?.error || 'Failed to load holidays');
                    }

                } catch (error) {
                    console.error(' Error importing holidays:', error);
                    this.showToast('Failed to import holidays: ' + error.message, 'danger');
                } finally {
                    this.showLoading(false);
                }
            }

            displayHolidayPreview(holidays, countryName, year, isPrimary) {
                const container = document.getElementById('holidayPreview');
                if (!container) return;

                container.style.display = 'block';
                container.innerHTML = `
                        <div class="alert ${isPrimary ? 'alert-success' : 'alert-info'}-modern">
                            <h6>
                                <i class="fas fa-calendar-day me-2"></i>
                                ${countryName} Holidays ${year} ${isPrimary ? '(PRIMARY - Takes Precedence)' : ''}
                            </h6>
                            <div class="row">
                                ${holidays.map(holiday => `
                                    <div class="col-md-6 mb-1">
                                        <small>
                                            <strong>${holiday.name}</strong> - ${this.formatDate(holiday.date)}
                                        </small>
                                    </div>
                                `).join('')}
                            </div>
                            <div class="mt-2">
                                <button class="btn btn-success-modern btn-sm btn-modern" onclick="scheduleManager.applyHolidays('${countryName}', '${year}')">
                                    <i class="fas fa-check me-1"></i>Apply These Holidays
                                </button>
                            </div>
                        </div>
                    `;
            }

            async applyHolidays(countryName, year) {
                this.showToast(`Applied ${countryName} holidays for ${year} to the system`, 'success');
                await this.refreshHolidays();
            }

            async refreshHolidays(force = false) {
                const container = document.getElementById('currentHolidays');
                if (!container) return;

                const countrySelect = document.getElementById('holidayCountry');
                const yearSelect = document.getElementById('holidayYear');
                const prefetchCountry = this.holidayPrefetch?.country || this.holidayPrefetch?.countryCode || '';
                const prefetchYear = this.holidayPrefetch?.year || '';

                const usePrefetch = !force && this.holidayPrefetch && this.holidayPrefetch.success;
                if (usePrefetch) {
                    if (countrySelect) {
                        const resolvedPrefetchCountry = this.resolveHolidayCountryCode(prefetchCountry);
                        this.setSelectValueIfAvailable(countrySelect, resolvedPrefetchCountry);
                    }
                    if (yearSelect) {
                        const resolvedPrefetchYear = this.resolveHolidayYear(prefetchYear);
                        this.setSelectValueIfAvailable(yearSelect, resolvedPrefetchYear);
                    }
                    container.innerHTML = this.buildHolidaySummaryMarkup(this.holidayPrefetch);
                    return;
                }

                container.innerHTML = `
                        <div class="text-center py-4">
                            <div class="loading-spinner mx-auto mb-3"></div>
                            <p class="text-muted">Loading current holidays...</p>
                        </div>
                `;

                try {
                    const resolvedCountry = this.resolveHolidayCountryCode(
                        countrySelect ? countrySelect.value : prefetchCountry
                    );
                    const resolvedYear = this.resolveHolidayYear(
                        yearSelect ? yearSelect.value : prefetchYear
                    );

                    this.setSelectValueIfAvailable(countrySelect, resolvedCountry);
                    this.setSelectValueIfAvailable(yearSelect, resolvedYear);

                    const response = await this.callServerFunction('clientGetCountryHolidays', resolvedCountry, resolvedYear);

                    if (response && response.success) {
                        this.holidayPrefetch = response;
                        const resolvedResponseCountry = this.resolveHolidayCountryCode(
                            response.country || response.countryCode || resolvedCountry
                        );
                        const resolvedResponseYear = this.resolveHolidayYear(response.year || resolvedYear);
                        this.setSelectValueIfAvailable(countrySelect, resolvedResponseCountry);
                        this.setSelectValueIfAvailable(yearSelect, resolvedResponseYear);
                        container.innerHTML = this.buildHolidaySummaryMarkup(response);
                        if (response.fallbackApplied && response.note) {
                            this.showToast(response.note, 'warning');
                        }
                        return;
                    }

                    throw new Error(response?.error || 'Failed to load holidays');
                } catch (error) {
                    console.error('Unable to refresh holidays:', error);
                    container.innerHTML = `
                        <div class="alert alert-info-modern">
                            <h6><i class="fas fa-info-circle me-2"></i>Holiday System</h6>
                            <p class="mb-0">Unable to load holiday data automatically. Use the import form above to configure holidays.</p>
                        </div>
                    `;
                }
            }

            onTabChange(target) {
                switch (target) {
                    case '#attendance':
                        this.loadAttendanceCalendar();
                        break;
                    case '#attendance-dashboard':
                        this.loadAttendanceDashboard(true);
                        break;
                    case '#dashboard':
                        this.refreshDashboard();
                        break;
                    case '#shifts':
                        this.loadShiftSlots();
                        break;
                    case '#holidays':
                        this.refreshHolidays();
                        break;
                    case '#import':
                        const manualManager = this.manualShiftManager
                            || (typeof window !== 'undefined' ? window.manualShiftManager : null);
                        if (manualManager && typeof manualManager.renderUserList === 'function') {
                            manualManager.renderUserList();
                        }
                        break;
                }
            }

            async approveSchedule(scheduleId) {
                try {
                    this.showLoading(true);
                    const result = await this.callServerFunction('clientApproveSchedules', [scheduleId], this.getCurrentUserId());

                    if (result && result.success) {
                        this.showToast('Schedule approved successfully!', 'success');
                        await this.loadSchedules();
                    } else {
                        throw new Error(result?.error || 'Failed to approve schedule');
                    }
                } catch (error) {
                    console.error('Error approving schedule:', error);
                    this.showToast('Failed to approve schedule: ' + error.message, 'danger');
                } finally {
                    this.showLoading(false);
                }
            }

            async rejectSchedule(scheduleId) {
                try {
                    const reason = prompt('Please provide a reason for rejection (optional):');
                    this.showLoading(true);

                    const result = await this.callServerFunction('clientRejectSchedules', [scheduleId], this.getCurrentUserId(), reason || '');

                    if (result && result.success) {
                        this.showToast('Schedule rejected successfully!', 'success');
                        await this.loadSchedules();
                    } else {
                        throw new Error(result?.error || 'Failed to reject schedule');
                    }
                } catch (error) {
                    console.error('Error rejecting schedule:', error);
                    this.showToast('Failed to reject schedule: ' + error.message, 'danger');
                } finally {
                    this.showLoading(false);
                }
            }

            viewScheduleDetails(scheduleId) {
                this.showToast('Schedule details view - coming soon!', 'info');
                console.log('Viewing schedule details for:', scheduleId);
            }

            async callServerFunction(functionName, ...params) {
                try {
                    console.log(` Calling backend function: ${functionName}`, params);

                    return new Promise((resolve, reject) => {
                        if (typeof google !== 'undefined' && google.script && google.script.run) {
                            google.script.run
                                .withSuccessHandler((result) => {
                                    console.log(` Backend response for ${functionName}:`, result);
                                    resolve(result);
                                })
                                .withFailureHandler((error) => {
                                    console.error(` Backend error for ${functionName}:`, error);
                                    reject(new Error(error.message || error.toString()));
                                })
                                [functionName](...params);
                        } else {
                            // Google Apps Script not available
                            reject(new Error('Google Apps Script not available. Please ensure this is running in the correct environment.'));
                        }
                    });
                } catch (error) {
                    console.error(` Error calling ${functionName}:`, error);
                    throw error;
                }
            }

            // Utility methods
            getCurrentUserId() {
                const resolvedId = this.normalizeUserIdValue(this.resolvedManagerId);
                if (resolvedId) {
                    return resolvedId;
                }

                const potentialIds = [
                    this.currentUser?.ID,
                    this.currentUser?.Id,
                    this.currentUser?.id,
                    this.currentUser?.UserID,
                    this.currentUser?.UserId
                ]
                    .map(id => this.normalizeUserIdValue(id))
                    .filter(id => id);

                return potentialIds.length > 0 ? potentialIds[0] : 'system-user';
            }

            getCurrentCampaignId() {
                const resolvedCampaign = this.normalizeCampaignIdValue(this.resolvedCampaignId);
                if (resolvedCampaign) {
                    return resolvedCampaign;
                }

                const candidateValues = [
                    this.currentUser?.CampaignID,
                    this.currentUser?.campaignID,
                    this.currentUser?.CampaignId,
                    this.currentUser?.campaignId,
                    this.currentUser?.Campaign,
                    typeof document !== 'undefined' ? document.documentElement?.getAttribute('data-campaign-id') : null,
                    typeof document !== 'undefined' ? document.documentElement?.dataset?.campaignId : null,
                    typeof document !== 'undefined' ? document.body?.getAttribute('data-campaign-id') : null,
                    typeof document !== 'undefined' ? document.body?.dataset?.campaignId : null,
                    typeof window !== 'undefined' ? window.__layoutCampaignId : null,
                    typeof window !== 'undefined' ? window.__LAYOUT_CAMPAIGN_ID : null,
                    typeof window !== 'undefined' ? window.__LAYOUT_CAMPAIGNID : null,
                    typeof window !== 'undefined' ? window.__absorbedBannerData?.campaignId : null,
                    typeof window !== 'undefined' ? window.__absorbedBannerData?.campaignID : null
                ];

                for (const value of candidateValues) {
                    const normalized = this.normalizeCampaignIdValue(value);
                    if (normalized) {
                        return normalized;
                    }
                }

                const sidebarCampaign = document.querySelector('[data-campaign-id]')?.getAttribute('data-campaign-id');
                const normalizedSidebarCampaign = this.normalizeCampaignIdValue(sidebarCampaign);
                if (normalizedSidebarCampaign) {
                    return normalizedSidebarCampaign;
                }

                return '';
            }

            normalizeCampaignIdValue(value) {
                if (value === null || typeof value === 'undefined') {
                    return '';
                }

                if (Array.isArray(value)) {
                    for (const candidate of value) {
                        const normalizedCandidate = this.normalizeCampaignIdValue(candidate);
                        if (normalizedCandidate) {
                            return normalizedCandidate;
                        }
                    }
                    return '';
                }

                if (typeof value === 'object') {
                    const objectCandidates = [value.ID, value.Id, value.id, value.campaignId, value.CampaignID, value.value];
                    for (const candidate of objectCandidates) {
                        const normalizedCandidate = this.normalizeCampaignIdValue(candidate);
                        if (normalizedCandidate) {
                            return normalizedCandidate;
                        }
                    }
                    return '';
                }

                const text = String(value).trim();
                if (!text || text.toLowerCase() === 'undefined' || text.toLowerCase() === 'null') {
                    return '';
                }

                return text;
            }

            setSelectValueIfAvailable(selectElement, value) {
                if (!selectElement) {
                    return false;
                }

                if (value === null || typeof value === 'undefined') {
                    return false;
                }

                const normalizedValue = typeof value === 'number'
                    ? String(value)
                    : String(value).trim();

                if (!normalizedValue) {
                    return false;
                }

                const options = Array.from(selectElement.options || []);
                for (const option of options) {
                    if (!option) {
                        continue;
                    }

                    const optionValue = String(option.value);
                    if (optionValue === normalizedValue) {
                        selectElement.value = optionValue;
                        return true;
                    }

                    if (optionValue.trim().toUpperCase() === normalizedValue.toUpperCase()) {
                        selectElement.value = optionValue;
                        return true;
                    }

                    const optionNumber = Number(optionValue);
                    const candidateNumber = Number(normalizedValue);
                    if (Number.isFinite(optionNumber) && Number.isFinite(candidateNumber) && optionNumber === candidateNumber) {
                        selectElement.value = optionValue;
                        return true;
                    }
                }

                return false;
            }

            resolveSupportedHolidayCountries() {
                const resolved = [];
                const appendList = (list) => {
                    if (!Array.isArray(list)) {
                        return;
                    }
                    for (const value of list) {
                        const normalized = typeof value === 'string'
                            ? value.trim().toUpperCase()
                            : String(value || '').trim().toUpperCase();
                        if (normalized && !resolved.includes(normalized)) {
                            resolved.push(normalized);
                        }
                    }
                };

                appendList(this.holidayPrefetch?.supportedCountries);
                appendList(this.holidayPrefetch?.SUPPORTED_COUNTRIES);
                appendList(this.unifiedState?.holidays?.supportedCountries);
                appendList(this.unifiedState?.holidays?.SUPPORTED_COUNTRIES);

                const scheduleSettingsCandidates = [
                    typeof window !== 'undefined' ? window.SCHEDULE_SETTINGS : null,
                    typeof window !== 'undefined' ? window.scheduleSettings : null,
                    typeof window !== 'undefined' ? window.__SCHEDULE_SETTINGS : null
                ];

                for (const settings of scheduleSettingsCandidates) {
                    if (settings && typeof settings === 'object') {
                        appendList(settings.supportedCountries);
                        appendList(settings.SUPPORTED_COUNTRIES);
                    }
                }

                appendList(this.defaultHolidayCountries);

                return resolved.length ? resolved : ['JM', 'US', 'DO', 'PH'];
            }

            resolvePrimaryHolidayCountry() {
                const supportedCountries = this.resolveSupportedHolidayCountries();
                const candidates = [
                    this.holidayPrefetch?.primaryCountry,
                    this.holidayPrefetch?.PRIMARY_COUNTRY,
                    this.unifiedState?.holidays?.primaryCountry,
                    this.unifiedState?.holidays?.PRIMARY_COUNTRY,
                    this.identitySummary?.country,
                    this.currentUser?.country,
                    this.currentUser?.Country,
                    typeof window !== 'undefined' && window.SCHEDULE_SETTINGS ? window.SCHEDULE_SETTINGS.PRIMARY_COUNTRY : null,
                    typeof window !== 'undefined' && window.scheduleSettings ? window.scheduleSettings.PRIMARY_COUNTRY : null,
                    typeof window !== 'undefined' && window.__SCHEDULE_SETTINGS ? window.__SCHEDULE_SETTINGS.PRIMARY_COUNTRY : null
                ];

                for (const candidate of candidates) {
                    if (!candidate) {
                        continue;
                    }
                    const normalized = typeof candidate === 'string'
                        ? candidate.trim().toUpperCase()
                        : String(candidate || '').trim().toUpperCase();
                    if (normalized && supportedCountries.includes(normalized)) {
                        return normalized;
                    }
                }

                return supportedCountries.length ? supportedCountries[0] : 'JM';
            }

            resolveHolidayCountryCode(rawValue) {
                const supportedCountries = this.resolveSupportedHolidayCountries();
                const fallbackCountry = this.resolvePrimaryHolidayCountry();
                const candidates = Array.isArray(rawValue) ? rawValue : [rawValue];

                candidates.push(
                    this.holidayPrefetch?.country,
                    this.holidayPrefetch?.countryCode,
                    this.unifiedState?.holidays?.country,
                    this.unifiedState?.holidays?.countryCode,
                    this.identitySummary?.country,
                    this.currentUser?.country,
                    this.currentUser?.Country
                );

                for (const candidate of candidates) {
                    if (!candidate && candidate !== 0) {
                        continue;
                    }
                    const normalized = typeof candidate === 'string'
                        ? candidate.trim().toUpperCase()
                        : String(candidate || '').trim().toUpperCase();
                    if (normalized && supportedCountries.includes(normalized)) {
                        return normalized;
                    }
                }

                return fallbackCountry || (supportedCountries[0] || 'JM');
            }

            resolveHolidayYear(rawValue) {
                const candidates = Array.isArray(rawValue) ? rawValue : [rawValue];
                candidates.push(
                    this.holidayPrefetch?.year,
                    this.unifiedState?.holidays?.year,
                    new Date().getFullYear()
                );

                for (const candidate of candidates) {
                    if (candidate === null || typeof candidate === 'undefined') {
                        continue;
                    }
                    const parsed = parseInt(String(candidate), 10);
                    if (Number.isFinite(parsed) && parsed > 1900 && parsed < 10000) {
                        return parsed;
                    }
                }

                return new Date().getFullYear();
            }

            normalizeUserIdValue(value) {
                if (value === null || typeof value === 'undefined') {
                    return '';
                }

                const text = String(value).trim();
                if (!text || text.toLowerCase() === 'undefined' || text.toLowerCase() === 'null') {
                    return '';
                }

                return text;
            }

            escapeHtml(value) {
                if (value === null || typeof value === 'undefined') {
                    return '';
                }

                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            escapeForInlineEvent(value) {
                if (value === null || typeof value === 'undefined') {
                    return '';
                }

                return String(value)
                    .replace(/\\/g, '\\\\')
                    .replace(/'/g, "\\'")
                    .replace(/"/g, '\\"')
                    .replace(/\r/g, '\\r')
                    .replace(/\n/g, '\\n');
            }

            formatSchedulePeriod(schedule) {
                if (!schedule || typeof schedule !== 'object') {
                    return '';
                }

                const start = schedule.PeriodStart || schedule.Date;
                const end = schedule.PeriodEnd || schedule.Date || start;

                if (!start && !end) {
                    return '';
                }

                if (!end || start === end) {
                    return this.formatDate(start);
                }

                return this.formatPeriodLabel(start, end);
            }

            formatDate(dateStr) {
                try {
                    return dateStr ? new Date(dateStr).toLocaleDateString() : '';
                } catch (error) {
                    return dateStr;
                }
            }

            formatPeriodLabel(start, end) {
                const resolvedStart = start || end;
                const resolvedEnd = end || start;

                if (!resolvedStart && !resolvedEnd) {
                    return '';
                }

                const startLabel = this.formatDate(resolvedStart);
                const endLabel = this.formatDate(resolvedEnd);

                if (!resolvedEnd || startLabel === endLabel) {
                    return startLabel;
                }

                return `${startLabel} - ${endLabel}`;
            }

            formatDateTime(dateValue) {
                if (!dateValue) {
                    return '';
                }

                try {
                    const date = new Date(dateValue);
                    if (isNaN(date.getTime())) {
                        return String(dateValue);
                    }

                    return date.toLocaleString(undefined, {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                } catch (error) {
                    console.warn('Unable to format date time value:', dateValue, error);
                    return String(dateValue);
                }
            }

            formatTimeValue(timeValue) {
                if (!timeValue && timeValue !== 0) {
                    return '';
                }

                try {
                    if (typeof timeValue === 'string') {
                        if (/^\d{1,2}:\d{2}(:\d{2})?$/.test(timeValue)) {
                            const [hours, minutes] = timeValue.split(':');
                            const date = new Date();
                            date.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
                            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        }

                        const parsed = new Date(timeValue);
                        if (!isNaN(parsed.getTime())) {
                            return parsed.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        }

                        return timeValue;
                    }

                    if (timeValue instanceof Date) {
                        return timeValue.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }

                    if (typeof timeValue === 'number') {
                        if (timeValue >= 0 && timeValue < 1) {
                            const totalMinutes = Math.round(timeValue * 24 * 60);
                            const hours = Math.floor(totalMinutes / 60).toString().padStart(2, '0');
                            const minutes = (totalMinutes % 60).toString().padStart(2, '0');
                            return `${hours}:${minutes}`;
                        }

                        const date = new Date(timeValue);
                        if (!isNaN(date.getTime())) {
                            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        }
                    }

                    return String(timeValue);
                } catch (error) {
                    console.warn('Unable to format time value:', timeValue, error);
                    return String(timeValue);
                }
            }

            formatDaysOfWeek(daysArray) {
                const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                return Array.isArray(daysArray) ?
                    daysArray.map(day => dayNames[day] || day).join(', ') :
                    'Mon-Fri';
            }

            getStatusBadgeClass(status) {
                switch (status) {
                    case 'APPROVED': return 'status-approved';
                    case 'REJECTED': return 'status-rejected';
                    default: return 'status-pending';
                }
            }

            getPriorityClass(priority) {
                switch (priority) {
                    case 4: return 'bg-danger text-white';
                    case 3: return 'bg-warning text-dark';
                    case 2: return 'bg-primary text-white';
                    default: return 'bg-secondary text-white';
                }
            }

            getPriorityText(priority) {
                switch (priority) {
                    case 4: return 'Critical';
                    case 3: return 'High';
                    case 2: return 'Normal';
                    default: return 'Low';
                }
            }

            getInsightIcon(type) {
                switch (type) {
                    case 'coverage': return 'chart-area';
                    case 'fairness': return 'balance-scale';
                    case 'compliance': return 'shield-alt';
                    case 'insight': return 'lightbulb';
                    case 'positive': return 'thumbs-up';
                    case 'warning': return 'exclamation-triangle';
                    case 'critical': return 'exclamation-circle';
                    default: return 'info-circle';
                }
            }
        }

        // Global functions for button clicks
        window.scheduleManager = null;

        function runSystemDiagnostics() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('System diagnostics: All systems operational', 'success');
            }
        }

        function refreshAllData() {
            if (window.scheduleManager) {
                window.scheduleManager.loadInitialData();
            }
        }

        function refreshSchedules() {
            if (window.scheduleManager) {
                window.scheduleManager.loadSchedules()
                    .then(() => window.scheduleManager.showToast('Schedules refreshed', 'success'))
                    .catch(error => {
                        console.error(' Failed to refresh schedules:', error);
                        window.scheduleManager.showToast('Failed to refresh schedules. Please try again.', 'danger');
                    });
            }
        }

        function refreshShiftSlots() {
            if (window.scheduleManager) {
                window.scheduleManager.loadShiftSlots();
            }
        }

        function refreshDashboard() {
            if (window.scheduleManager) {
                window.scheduleManager.refreshDashboard();
            }
        }

        function refreshUsers() {
            if (window.scheduleManager) {
                window.scheduleManager.loadUsers();
            }
        }

        function loadAttendanceCalendar() {
            if (window.scheduleManager) {
                window.scheduleManager.loadAttendanceCalendar();
            }
        }

        function applyScheduleFilters() {
            if (window.scheduleManager) {
                window.scheduleManager.loadSchedules()
                    .then(() => window.scheduleManager.showToast('Filters applied', 'success'))
                    .catch(error => {
                        console.error(' Failed to apply schedule filters:', error);
                        window.scheduleManager.showToast('Failed to apply filters. Please try again.', 'danger');
                    });
            }
        }

        function previewSchedules() {
            if (window.scheduleManager) {
                window.scheduleManager.previewSchedules().catch(() => {});
            }
        }

        function generateThisWeek() {
            if (window.scheduleManager) {
                window.scheduleManager.generateSchedules({ autoCommit: true }).catch(() => {});
            }
        }

        function generateNextWeek() {
            if (window.scheduleManager) {
                window.scheduleManager.generateSchedules({ autoCommit: true }).catch(() => {});
            }
        }

        function bulkApproveSchedules() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Bulk approve functionality - coming soon!', 'info');
            }
        }

        function markBulkAttendance() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Bulk attendance marking - coming soon!', 'info');
            }
        }

        function quickMarkAttendance() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Quick attendance marking - coming soon!', 'info');
            }
        }

        function exportAttendanceReport() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Report export - coming soon!', 'info');
            }
        }

        function previewHolidays() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Holiday preview - coming soon!', 'info');
            }
        }

        function assignManagerUsers() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Manager assignment - coming soon!', 'info');
            }
        }

        function editShiftSlot(slotId) {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Edit shift slot #' + slotId, 'info');
            }
        }

        function previewShiftSlot() {
            if (window.scheduleManager) {
                const slotName = document.getElementById('slotName').value || 'Unnamed Shift';
                const startTime = document.getElementById('slotStartTime').value;
                const endTime = document.getElementById('slotEndTime').value;
                const enableOT = document.getElementById('enableOvertime')?.checked ?? false;
                const enableStaggered = document.getElementById('enableStaggeredBreaks')?.checked ?? false;

                const preview = `
                        <strong>${slotName}</strong><br>
                        Time: ${startTime} - ${endTime}<br>
                        Overtime: ${enableOT ? 'Enabled' : 'Disabled'}<br>
                        Staggered Breaks: ${enableStaggered ? 'Enabled' : 'Disabled'}
                    `;

                window.scheduleManager.showToast(`Shift Preview: ${preview}`, 'info');
            }
        }

        function createDefaultShifts() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Creating default shift templates...', 'info');
                // This would call a backend function to create standard shifts
                setTimeout(() => {
                    window.scheduleManager.showToast('Default shifts created successfully!', 'success');
                    if (window.scheduleManager) {
                        window.scheduleManager.loadShiftSlots();
                    }
                }, 2000);
            }
        }

        function bulkEditShifts() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Bulk edit functionality - coming soon!', 'info');
            }
        }

        function exportShiftSchedule() {
            if (window.scheduleManager) {
                window.scheduleManager.showToast('Shift schedule export - coming soon!', 'info');
            }
        }

        function validateShiftCoverage() {
            if (window.scheduleManager) {
                window.scheduleManager.showLoading(true);
                setTimeout(() => {
                    window.scheduleManager.showLoading(false);
                    window.scheduleManager.showToast('Shift coverage validated - all schedules have adequate coverage', 'success');
                }, 1500);
            }
        }

        // Manual shift assignment manager for the Schedule Management import tab
        class ManualShiftAssignmentManager {
            constructor(scheduleManager) {
                this.scheduleManager = scheduleManager || null;

                this.form = document.getElementById('manualShiftForm');
                this.feedbackArea = document.getElementById('feedbackArea');
                this.startDateInput = document.getElementById('startDate');
                this.endDateInput = document.getElementById('endDate');
                this.shiftSlotSelect = document.getElementById('manualShiftSlot');
                this.notesInput = document.getElementById('additionalNotes');
                this.replaceExistingToggle = document.getElementById('replaceExisting');
                this.userSearchInput = document.getElementById('userSearch');
                this.selectAllToggle = document.getElementById('selectAllUsers');
                this.userList = document.getElementById('userList');
                this.userLoadingState = document.getElementById('userLoadingState');
                this.selectedCountLabel = document.getElementById('selectedUserCount');
                this.totalCountLabel = document.getElementById('totalUserCount');
                this.clearSelectionBtn = document.getElementById('clearSelection');
                this.submitButton = document.getElementById('submitManualShift');
                this.activityLog = document.getElementById('activityLog');
                this.activityEmptyState = document.getElementById('activityEmptyState');

                this.users = [];
                this.userMap = new Map();
                this.selectedUserIds = new Set();
                this.shiftSlots = [];
                this.shiftSlotMap = new Map();

                if (this.form) {
                    this.form.addEventListener('submit', (event) => this.handleSubmit(event));
                }
                this.userSearchInput?.addEventListener('input', () => this.renderUserList());
                this.selectAllToggle?.addEventListener('change', () => this.toggleSelectAll());
                this.clearSelectionBtn?.addEventListener('click', () => this.clearSelection());
                this.startDateInput?.addEventListener('change', () => this.handleStartDateChange());
                this.endDateInput?.addEventListener('change', () => this.handleEndDateChange());

                if (this.scheduleManager && typeof this.scheduleManager === 'object') {
                    this.scheduleManager.manualShiftManager = this;
                }

                this.initializeDateRange();

                if (this.scheduleManager && Array.isArray(this.scheduleManager.cachedShiftSlots) && this.scheduleManager.cachedShiftSlots.length) {
                    this.setShiftSlots(this.scheduleManager.cachedShiftSlots);
                } else if (this.shiftSlotSelect) {
                    this.setShiftSlots([]);
                }

                const initialUsers = this.scheduleManager && Array.isArray(this.scheduleManager.availableUsers)
                    ? this.scheduleManager.availableUsers
                    : [];
                if (initialUsers.length) {
                    this.setUsers(initialUsers);
                } else {
                    this.setUserLoading(true);
                }
            }

            initializeDateRange() {
                const today = new Date();
                const isoToday = today.toISOString().split('T')[0];

                if (this.startDateInput && !this.startDateInput.value) {
                    this.startDateInput.value = isoToday;
                }
                if (this.endDateInput && !this.endDateInput.value) {
                    this.endDateInput.value = this.startDateInput?.value || isoToday;
                }

                this.syncDateConstraints();
            }

            syncDateConstraints() {
                if (this.startDateInput && this.endDateInput) {
                    const startValue = this.startDateInput.value || '';
                    this.endDateInput.min = startValue || this.endDateInput.min || '';
                    const endValue = this.endDateInput.value;
                    if (startValue && endValue && endValue < startValue) {
                        this.endDateInput.value = startValue;
                    }
                }
            }

            handleStartDateChange() {
                this.syncDateConstraints();
            }

            handleEndDateChange() {
                this.syncDateConstraints();
            }

            setShiftSlots(slots = []) {
                if (!Array.isArray(slots)) {
                    slots = [];
                }

                this.shiftSlots = slots.slice();
                if (!(this.shiftSlotMap instanceof Map)) {
                    this.shiftSlotMap = new Map();
                } else {
                    this.shiftSlotMap.clear();
                }

                slots.forEach(slot => {
                    const id = this.normalizeSlotId(slot);
                    if (id) {
                        this.shiftSlotMap.set(id, slot);
                    }
                });

                if (!this.shiftSlotSelect) {
                    return;
                }

                const currentValue = this.shiftSlotSelect.value;
                this.shiftSlotSelect.innerHTML = '';

                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = slots.length ? 'Select a shift slot' : 'No shift slots available';
                placeholder.disabled = true;
                this.shiftSlotSelect.appendChild(placeholder);

                slots.forEach(slot => {
                    const id = this.normalizeSlotId(slot);
                    if (!id) {
                        return;
                    }
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = this.buildSlotLabel(slot);
                    this.shiftSlotSelect.appendChild(option);
                });

                if (currentValue && this.shiftSlotMap.has(currentValue)) {
                    this.shiftSlotSelect.value = currentValue;
                    placeholder.selected = false;
                } else if (slots.length) {
                    const firstOption = this.shiftSlotSelect.querySelector('option[value]');
                    if (firstOption) {
                        firstOption.selected = true;
                    }
                } else {
                    placeholder.selected = true;
                }

                this.shiftSlotSelect.disabled = slots.length === 0;
            }

            normalizeSlotId(slot) {
                if (!slot) {
                    return '';
                }

                if (typeof slot === 'string' || typeof slot === 'number') {
                    return String(slot).trim();
                }

                if (this.scheduleManager && typeof this.scheduleManager.resolveShiftSlotId === 'function') {
                    const resolved = this.scheduleManager.resolveShiftSlotId(slot);
                    if (resolved) {
                        return resolved;
                    }
                }

                const candidates = [
                    slot.ID, slot.Id, slot.id,
                    slot.SlotID, slot.SlotId, slot.slotId,
                    slot.Guid, slot.UUID, slot.Uuid
                ];

                for (let index = 0; index < candidates.length; index++) {
                    const candidate = candidates[index];
                    if (candidate === null || candidate === undefined) {
                        continue;
                    }
                    const normalized = String(candidate).trim();
                    if (normalized) {
                        return normalized;
                    }
                }

                return '';
            }

            getSlotLabel(slotId) {
                if (!slotId) {
                    return '';
                }

                const normalized = this.normalizeSlotId(slotId);
                if (!normalized) {
                    return '';
                }

                if (this.shiftSlotMap && this.shiftSlotMap.has(normalized)) {
                    return this.buildSlotLabel(this.shiftSlotMap.get(normalized));
                }

                if (this.scheduleManager && Array.isArray(this.scheduleManager.cachedShiftSlots)) {
                    const match = this.scheduleManager.cachedShiftSlots.find(slot => this.normalizeSlotId(slot) === normalized);
                    if (match) {
                        if (this.shiftSlotMap) {
                            this.shiftSlotMap.set(normalized, match);
                        }
                        return this.buildSlotLabel(match);
                    }
                }

                return '';
            }

            buildSlotLabel(slot = {}) {
                if (this.scheduleManager && typeof this.scheduleManager.buildShiftSlotOptionLabel === 'function') {
                    return this.scheduleManager.buildShiftSlotOptionLabel(slot);
                }

                const name = (slot.Name || slot.SlotName || 'Manual Shift').toString().trim();
                const formatTime = this.scheduleManager && typeof this.scheduleManager.formatTimeValue === 'function'
                    ? (value) => this.scheduleManager.formatTimeValue(value)
                    : (value) => (value || '').toString();
                const startTime = formatTime(slot.StartTime);
                const endTime = formatTime(slot.EndTime);
                const timeLabel = startTime && endTime ? ` (${startTime} - ${endTime})` : '';
                return `${name}${timeLabel}`.trim();
            }

            resolveUserName(userId) {
                if (!userId) {
                    return '';
                }

                const normalized = this.normalizeUserId(userId);
                if (normalized && this.userMap.has(normalized)) {
                    const user = this.userMap.get(normalized);
                    return user?.FullName || user?.UserName || '';
                }

                return '';
            }

            parseDateValue(value) {
                if (!value) {
                    return null;
                }

                if (value instanceof Date) {
                    return isNaN(value.getTime()) ? null : new Date(value);
                }

                if (typeof value === 'number' && !Number.isNaN(value)) {
                    const dateFromNumber = new Date(value);
                    return isNaN(dateFromNumber.getTime()) ? null : dateFromNumber;
                }

                if (typeof value === 'object' && value.iso) {
                    return this.parseDateValue(value.iso);
                }

                if (typeof value === 'string') {
                    const normalized = value.trim();
                    if (!normalized) {
                        return null;
                    }
                    const dateFromString = new Date(normalized);
                    return isNaN(dateFromString.getTime()) ? null : dateFromString;
                }

                return null;
            }

            formatDateForDisplay(value) {
                const date = this.parseDateValue(value);
                if (!date) {
                    return value || '';
                }

                try {
                    return new Intl.DateTimeFormat('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: '2-digit',
                        timeZone: 'America/Jamaica'
                    }).format(date);
                } catch (error) {
                    return date.toISOString().split('T')[0];
                }
            }

            formatDateRange(start, end) {
                const startLabel = this.formatDateForDisplay(start);
                const endLabel = this.formatDateForDisplay(end);

                if (startLabel && endLabel) {
                    return startLabel === endLabel ? startLabel : `${startLabel}  ${endLabel}`;
                }

                return startLabel || endLabel || '';
            }

            formatTimestamp(value = new Date()) {
                const date = this.parseDateValue(value) || new Date();
                try {
                    return new Intl.DateTimeFormat('en-US', {
                        dateStyle: 'medium',
                        timeStyle: 'short',
                        timeZone: 'America/Jamaica'
                    }).format(date);
                } catch (error) {
                    return date.toLocaleString();
                }
            }

            normalizeResultDetails(result) {
                if (!result) {
                    return [];
                }

                if (Array.isArray(result.details) && result.details.length) {
                    return result.details;
                }

                if (Array.isArray(result.assignments) && result.assignments.length) {
                    return result.assignments;
                }

                return [];
            }

            buildSuccessMessage(result, slotLabel, startDate, endDate, userCount) {
                const details = this.normalizeResultDetails(result);
                const createdCount = typeof result?.created === 'number'
                    ? result.created
                    : (details.length || userCount || 0);
                const countLabel = createdCount === 1 ? 'user' : 'users';
                const rangeLabel = this.formatDateRange(startDate, endDate);
                const slotText = slotLabel || 'the selected shift slot';

                if (createdCount > 0 && rangeLabel) {
                    return `Assigned ${createdCount} ${countLabel} to ${slotText} for ${rangeLabel}.`;
                }

                if (createdCount > 0) {
                    return `Assigned ${createdCount} ${countLabel} to ${slotText}.`;
                }

                return `Assignments saved for ${slotText}.`;
            }

            focusElement(element) {
                if (element && typeof element.focus === 'function') {
                    element.focus();
                }
            }

            setUsers(users) {
                if (!Array.isArray(users)) {
                    users = [];
                }

                const normalized = users
                    .filter(user => user && (user.ID || user.UserName || user.FullName))
                    .map(user => {
                        const id = this.normalizeUserId(user.ID || user.UserID || user.id || user.userId);
                        return {
                            ID: id,
                            UserName: user.UserName || user.username || '',
                            FullName: user.FullName || user.fullName || user.UserName || '',
                            Email: user.Email || user.email || '',
                            campaignName: user.campaignName || user.CampaignName || user.Campaign || ''
                        };
                    })
                    .filter(user => user.ID);

                this.users = normalized;
                this.userMap.clear();
                normalized.forEach(user => this.userMap.set(user.ID, user));

                const retainedSelections = new Set();
                this.selectedUserIds.forEach(id => {
                    if (this.userMap.has(id)) {
                        retainedSelections.add(id);
                    }
                });
                this.selectedUserIds = retainedSelections;

                if (this.totalCountLabel) {
                    this.totalCountLabel.textContent = String(this.users.length);
                }

                this.setUserLoading(false);
                this.renderUserList();
                this.updateSelectionCounters();
            }

            normalizeUserId(value) {
                if (value === null || typeof value === 'undefined') {
                    return '';
                }
                if (typeof value === 'object') {
                    if (value.ID || value.id) {
                        return this.normalizeUserId(value.ID || value.id);
                    }
                    return '';
                }
                return String(value).trim();
            }

            setUserLoading(isLoading) {
                if (this.userLoadingState) {
                    this.userLoadingState.style.display = isLoading ? 'flex' : 'none';
                }
            }

            getFilteredUsers() {
                const term = this.userSearchInput?.value.trim().toLowerCase() || '';
                if (!term) {
                    return this.users;
                }

                return this.users.filter(user => {
                    const name = (user.FullName || user.UserName || '').toLowerCase();
                    const email = (user.Email || '').toLowerCase();
                    const campaign = (user.campaignName || '').toLowerCase();
                    return name.includes(term) || email.includes(term) || campaign.includes(term);
                });
            }

            renderUserList() {
                if (!this.userList) {
                    return;
                }

                const filteredUsers = this.getFilteredUsers();
                this.userList.innerHTML = '';

                if (!filteredUsers.length) {
                    const emptyState = document.createElement('div');
                    emptyState.className = 'user-list-empty';
                    emptyState.textContent = this.users.length
                        ? 'No users match your search.'
                        : 'No eligible users were found.';
                    this.userList.appendChild(emptyState);
                    this.updateSelectionCounters();
                    if (this.selectAllToggle) {
                        this.selectAllToggle.checked = false;
                        this.selectAllToggle.disabled = this.users.length === 0;
                    }
                    return;
                }

                const fragment = document.createDocumentFragment();
                filteredUsers.forEach(user => {
                    const userId = user.ID;
                    const isChecked = this.selectedUserIds.has(userId);

                    const item = document.createElement('label');
                    item.className = 'user-list-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'form-check-input';
                    checkbox.checked = isChecked;
                    checkbox.dataset.userId = userId;
                    checkbox.addEventListener('change', (event) => this.toggleUser(event));

                    const details = document.createElement('div');
                    details.style.flex = '1';

                    const name = document.createElement('div');
                    name.className = 'user-name';
                    name.textContent = user.FullName || user.UserName || 'Unnamed User';
                    details.appendChild(name);

                    const metaParts = [];
                    if (user.UserName && user.FullName && user.UserName !== user.FullName) {
                        metaParts.push(user.UserName);
                    }
                    if (user.Email) {
                        metaParts.push(user.Email);
                    }
                    if (user.campaignName) {
                        metaParts.push(user.campaignName);
                    }
                    if (metaParts.length) {
                        const meta = document.createElement('div');
                        meta.className = 'user-meta';
                        meta.textContent = metaParts.join('  ');
                        details.appendChild(meta);
                    }

                    item.appendChild(checkbox);
                    item.appendChild(details);
                    fragment.appendChild(item);
                });

                this.userList.appendChild(fragment);
                this.updateSelectionCounters();
                this.syncSelectAllState(filteredUsers);
                if (this.selectAllToggle) {
                    this.selectAllToggle.disabled = false;
                }
            }

            toggleUser(event) {
                const checkbox = event.target;
                const userId = checkbox?.dataset?.userId;
                if (!userId) {
                    return;
                }

                if (checkbox.checked) {
                    this.selectedUserIds.add(userId);
                } else {
                    this.selectedUserIds.delete(userId);
                }

                this.updateSelectionCounters();
                this.syncSelectAllState();
            }

            toggleSelectAll() {
                const shouldSelectAll = this.selectAllToggle?.checked;
                const filteredUsers = this.getFilteredUsers();
                if (typeof shouldSelectAll !== 'boolean') {
                    return;
                }

                filteredUsers.forEach(user => {
                    if (!user || !user.ID) {
                        return;
                    }
                    if (shouldSelectAll) {
                        this.selectedUserIds.add(user.ID);
                    } else {
                        this.selectedUserIds.delete(user.ID);
                    }
                });

                this.renderUserList();
            }

            syncSelectAllState(filteredUsers = this.getFilteredUsers()) {
                if (!this.selectAllToggle) {
                    return;
                }

                if (!filteredUsers.length) {
                    this.selectAllToggle.checked = false;
                    return;
                }

                const allSelected = filteredUsers.every(user => this.selectedUserIds.has(user.ID));
                this.selectAllToggle.checked = allSelected && filteredUsers.length > 0;
            }

            clearSelection(options = {}) {
                this.selectedUserIds.clear();
                this.renderUserList();
                if (!options.silent) {
                    this.showFeedback('User selection cleared.', 'info');
                }
            }

            updateSelectionCounters() {
                if (this.selectedCountLabel) {
                    this.selectedCountLabel.textContent = String(this.selectedUserIds.size);
                }
                if (this.totalCountLabel) {
                    this.totalCountLabel.textContent = String(this.users.length);
                }
            }

            async handleSubmit(event) {
                event.preventDefault();

                if (!this.form || !this.submitButton) {
                    return;
                }

                const slotId = (this.shiftSlotSelect?.value || '').trim();
                if (!slotId) {
                    this.showFeedback('Select a shift slot before assigning users.', 'danger');
                    this.focusElement(this.shiftSlotSelect);
                    return;
                }

                const startDateValue = this.startDateInput?.value || '';
                if (!startDateValue) {
                    this.showFeedback('Choose a start date for this assignment.', 'danger');
                    this.focusElement(this.startDateInput);
                    return;
                }

                const endDateRaw = this.endDateInput?.value || '';
                const endDateValue = endDateRaw || startDateValue;
                if (!endDateValue) {
                    this.showFeedback('Choose an end date for this assignment.', 'danger');
                    this.focusElement(this.endDateInput);
                    return;
                }

                if (endDateValue < startDateValue) {
                    this.showFeedback('End date must be on or after the start date.', 'warning');
                    this.focusElement(this.endDateInput);
                    return;
                }

                const selectedIds = Array.from(this.selectedUserIds);
                if (!selectedIds.length) {
                    this.showFeedback('Select at least one user before assigning the shift slot.', 'warning');
                    return;
                }

                const notesValue = (this.notesInput?.value || '').trim();
                const replaceExisting = !!this.replaceExistingToggle?.checked;
                const slotLabel = this.getSlotLabel(slotId) || 'Manual Shift';

                const payload = {
                    slotId,
                    startDate: startDateValue,
                    endDate: endDateValue,
                    notes: notesValue,
                    replaceExisting,
                    users: selectedIds
                };

                const originalButtonContent = this.submitButton.innerHTML;
                this.submitButton.disabled = true;
                this.submitButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving...';

                try {
                    const result = await this.callServerFunction('clientAddManualShiftSlots', payload);
                    if (result && result.success) {
                        const message = result.message || this.buildSuccessMessage(result, slotLabel, startDateValue, endDateValue, selectedIds.length);
                        this.showFeedback(message, 'success');
                        this.appendActivity(result, { slotId, slotLabel, startDate: startDateValue, endDate: endDateValue, userIds: selectedIds });

                        if (!replaceExisting) {
                            this.clearSelection({ silent: true });
                        }

                        if (this.scheduleManager && typeof this.scheduleManager.loadSchedules === 'function') {
                            this.scheduleManager.loadSchedules().catch(error => {
                                console.warn('Unable to refresh schedules after manual assignment:', error);
                            });
                        }
                    } else {
                        const errorMessage = (result && result.error) || 'Unable to assign the selected shift slot.';
                        this.showFeedback(errorMessage, 'danger');
                    }

                    if (result && Array.isArray(result.failed) && result.failed.length) {
                        const skippedNames = result.failed.map(item => item.userName || this.resolveUserName(item.userId) || item.userId || 'Unknown').join(', ');
                        this.showFeedback(`Skipped ${result.failed.length} user${result.failed.length === 1 ? '' : 's'}: ${skippedNames}`, 'warning');
                    }
                } catch (error) {
                    console.error('Manual shift slot assignment failed:', error);
                    this.showFeedback(error.message || 'An unexpected error occurred while saving shift assignments.', 'danger');
                } finally {
                    this.submitButton.disabled = false;
                    this.submitButton.innerHTML = originalButtonContent;
                }
            }

            appendActivity(result, context = {}) {
                if (!this.activityLog) {
                    return;
                }

                if (this.activityEmptyState) {
                    this.activityEmptyState.remove();
                    this.activityEmptyState = null;
                }

                const details = this.normalizeResultDetails(result);
                const hasDetails = Array.isArray(details) && details.length;
                const hasContextUsers = Array.isArray(context.userIds) && context.userIds.length;

                if (!hasDetails && !hasContextUsers) {
                    return;
                }

                const entry = document.createElement('div');
                entry.className = 'activity-entry';

                const primaryDetail = hasDetails ? details[0] : null;
                const slotId = context.slotId || (primaryDetail && (primaryDetail.slotId || primaryDetail.SlotId));
                const slotLabel = context.slotLabel || (primaryDetail?.slotName || primaryDetail?.SlotName) || this.getSlotLabel(slotId) || 'Manual Shift';
                const startDate = context.startDate || (primaryDetail?.startDate || primaryDetail?.StartDate);
                const endDate = context.endDate || (primaryDetail?.endDate || primaryDetail?.EndDate || startDate);
                const rangeLabel = this.formatDateRange(startDate, endDate);
                const timestampLabel = this.formatTimestamp(new Date());

                const namesSource = hasDetails ? details : context.userIds;
                const userNames = namesSource.map(detail => {
                    if (typeof detail === 'string') {
                        return this.resolveUserName(detail) || detail;
                    }
                    return detail.userName || detail.UserName || this.resolveUserName(detail.userId || detail.UserId) || detail.userId || detail.UserId || 'Unknown';
                }).filter(Boolean).join(', ');

                const rangeMarkup = rangeLabel
                    ? `<i class="far fa-calendar-alt me-1"></i>${this.escapeHtml(rangeLabel)}&nbsp;&nbsp;`
                    : '';

                entry.innerHTML = `
                    <strong>${this.escapeHtml(slotLabel)}</strong>
                    <div>${this.escapeHtml(userNames || 'Users assigned')}</div>
                    <div class="activity-meta">
                        ${rangeMarkup}<i class="far fa-clock me-1"></i>${this.escapeHtml(timestampLabel)}
                    </div>
                `;

                this.activityLog.prepend(entry);

                const maxEntries = 8;
                while (this.activityLog.children.length > maxEntries) {
                    this.activityLog.removeChild(this.activityLog.lastElementChild);
                }
            }

            showFeedback(message, type) {
                if (!this.feedbackArea) {
                    return;
                }

                const icons = {
                    success: 'fas fa-check-circle',
                    danger: 'fas fa-exclamation-triangle',
                    warning: 'fas fa-exclamation-circle',
                    info: 'fas fa-info-circle'
                };

                const alert = document.createElement('div');
                alert.className = `alert-modern alert-${type}-modern`;
                alert.innerHTML = `
                    <i class="${icons[type] || icons.info}"></i>
                    <div>
                        <p>${this.escapeHtml(message)}</p>
                    </div>
                    <button type="button" class="alert-close" aria-label="Dismiss" title="Dismiss alert">&times;</button>
                `;

                alert.querySelector('.alert-close')?.addEventListener('click', () => alert.remove());

                this.feedbackArea.prepend(alert);

                const timeout = type === 'info' ? 3500 : 6000;
                setTimeout(() => {
                    alert.style.opacity = '0';
                    alert.style.transform = 'translateY(-6px)';
                    setTimeout(() => alert.remove(), 250);
                }, timeout);
            }

            escapeHtml(value) {
                const div = document.createElement('div');
                div.textContent = value || '';
                return div.innerHTML;
            }

            callServerFunction(functionName, ...args) {
                if (this.scheduleManager && typeof this.scheduleManager.callServerFunction === 'function') {
                    return this.scheduleManager.callServerFunction(functionName, ...args);
                }

                return new Promise((resolve, reject) => {
                    if (typeof google !== 'undefined' && google.script && google.script.run) {
                        google.script.run
                            .withSuccessHandler(resolve)
                            .withFailureHandler(reject)
                            [functionName](...args);
                    } else {
                        reject(new Error('Google Apps Script not available.'));
                    }
                });
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.scheduleManager = new LuminaScheduleManager();
            window.manualShiftManager = new ManualShiftAssignmentManager(window.scheduleManager);
            if (window.scheduleManager) {
                window.scheduleManager.manualShiftManager = window.manualShiftManager;
            }
            window.calculateWeekSpanCount = (startDate, endDate, minDate, maxDate) => {
                if (window.scheduleManager && typeof window.scheduleManager.calculateWeekSpanCount === 'function') {
                    return window.scheduleManager.calculateWeekSpanCount(startDate, endDate, minDate, maxDate);
                }

                const resolveDate = (value) => {
                    if (value === undefined || value === null || value === '') {
                        return null;
                    }

                    if (value instanceof Date) {
                        const clone = new Date(value);
                        return isNaN(clone.getTime()) ? null : clone;
                    }

                    if (typeof value === 'object' && value.iso) {
                        return resolveDate(value.iso);
                    }

                    if (typeof value === 'number' && !Number.isNaN(value)) {
                        const fromNumber = new Date(value);
                        return isNaN(fromNumber.getTime()) ? null : fromNumber;
                    }

                    const parsed = new Date(value);
                    return isNaN(parsed.getTime()) ? null : parsed;
                };

                const start = resolveDate(startDate) || resolveDate(minDate);
                const end = resolveDate(endDate) || resolveDate(maxDate);
                if (!start || !end || end < start) {
                    return 0;
                }

                const diff = Math.floor((end - start) / (24 * 60 * 60 * 1000)) + 1;
                return diff > 0 ? Math.ceil(diff / 7) : 0;
            };
            console.log(' LUMINA Schedule Management System v4.0 - Modern Edition initialized');
        });
    </script>
  </body>
</html>
